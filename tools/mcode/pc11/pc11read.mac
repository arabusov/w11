; $Id: pc11read.mac 1275 2022-08-10 08:10:40Z mueller $
; SPDX-License-Identifier: GPL-3.0-or-later
; Copyright 2019-2022 by Walter F.J. Mueller <W.F.J.Mueller@gsi.de>
;
; Revision History:
; Date         Rev Version  Comment
; 2022-08-09  1275   1.0.1  use call/return
; 2019-04-21  1134   1.0    Initial version
;
; write test tape
;
; definitions ----------------------------------------------
;
        .include  |lib/defs_cpu.mac|
        .include  |lib/defs_pc.mac|
;
        lcnt = 1000.                    ; number of lines to print
;
        CR  = 015
        LF  = 012
;
; vector area ----------------------------------------------
;
        .include  |lib/vec_cpucatch.mac|
        .include  |lib/vec_devcatch.mac|

        . = v..ptr
        .word   vh.ptr
        .word   cp.pr7
;
; stack area -----------------------------------------------
;
        . = 1000                        ; stack (below); code (above)
stack:  
;
; code area ------------------------------------------------
;
; gobal register usage
;   r0   line count                     ; !! visible in wait !!
;   r1   read buffer pointer
;
; start/stop area ---------------------------------
;
start:  br      start1
stop:   halt                            ; sucessfull stop
        reset                           ; and allow re-start
;
; main program ------------------------------------
;
start1: mov     #stack,sp               ; setup stack
2$:     tst     @#pr.csr                ; wait reader online
        bmi     2$
;
        clr     r0                      ; clear line count
        mov     #bnum,r1                ; read buffer pointer
        clr     r2
        clr     r3
        clr     r4
        clr     r5
        mov     #"00,bnum
        mov     #"00,bnum+2
;
        mov     #<pr.ie!pr.ena>,@#pr.csr ; start reader
        spl     0                       ; allow interrupts
3$:     wait                            ; and idle
        br      3$
;
; reader interrupt handler -----------------------
;
vh.ptr: tst     @#pr.csr                ; reader error
        bpl     10$
        cmp     #bnum,r1                ; at begin of buffer ?
        bne     rerr                    ; if not, unexpected EOT
        cmp     r0,#lcnt                ; all lines seen ?
        bne     rerr                    ; if not, unexpected EOT
        br      200$                    ; otherwise success halt
10$:    movb    @#pr.buf,r2             ; read byte
        cmpb    r2,(r1)+                ; check byte
        bne     derr
        cmp     r1,#bend                ; end of buffer ?
        blo     100$
        mov     #bnum+3,r1              ; if yes, increment number
        call    incnum
        inc     r0                      ; inc line counter
        mov     #bnum,r1                ; ready for next line
100$:   inc     @#pr.csr                ; go for next char
        rti

200$:   jmp     stop

rerr:   halt                            ; reader error halt
        br      rerr
derr:   halt                            ; data error halt
        br      derr


;
; increment 4 digit decimal number ---------------
;
incnum: mov     #4,r5                   ; max 4 digits
1$:     incb    (r1)
        cmpb    (r1),#'9                ; went above 9
        ble     100$                    ; if not, done
        movb    #'0,(r1)                ; if yes, restore 0
        dec     r1                      ; and go for next digit
        sob     r5,1$
100$:   return
;
; data area ------------------------------------------------
;
bnum:   .ascii  /0000/
btxt:   .ascii  /: /
        .ascii  /ABCDEFGHIJKLMNOPQRSTUVWXYZ/
        .ascii  /abcdefghijklmnopqrstuvwxyz/
        .ascii  /!@#$%^&*()/
        .byte   CR,LF
bend:

        .end    start
