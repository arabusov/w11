## 2022-08-03: tests with SimH V3.11-0 and 2.11BSD 447 (plus 453 patch)

### Background
The `MMR1` response after an MMU abort in an FPP instruction depends on the CPU.
In an 11/70, the registers reflect the state at abort and `MMR1` shows the
change. In a J11, the registers are unchanged, and `MMR1` shows zero.

SimH V3.11-0 used the FPP MMU abort handling for _all_ CPU models.
So even when an 11/70 is modeled, the behavior is like a J11.

The 2.11BSD stack extension logic checks whether the `sp` is below the
current stack allocation, and only in that case, the stack is extended.
On a J11-based system that fails, that's why 2.11BSD up to #473 has a
workaround and shifts the `sp` down by 4 _if and only if_ a J11 was
probed at boot time. The pertinent code in `/usr/src/sys/pdp/trap.c` is
```
    osp = sp;
    if (kdj11)
        osp -= 4;
    if (backup(u.u_ar0) == 0)
        if (!(u.u_sigstk.ss_flags & SA_ONSTACK) && grow((u_int)osp))
            goto out;
    i = SIGSEGV;
```

That leads to two vulnerabilities:
- a `double` push of 8 bytes might fail on J11 systems, real or simulated,
- in a SimH 11/70, which probes as an 11/70 but behaves like a J11, any
  push from an FPP instruction might fail.

The first is a 2.11BSD issue, the second is a SimH issue.

The tests were run under `tcsh`, it gives "Segmentation fault" in case of
a problem. Under `sh` one gets "Memory fault".

### SimH in 11/94 mode
SimH pdp11 started with
```
set cpu 11/94
```
and 2.11BSD starts with
```
94Boot from xp(0,0,0) at 0176700
```
Extending the stack with `float` pushes is no problem until the stack segment
has grown to 020000 and memory is really exhausted:
```
./stktst f ' 1024'
  # stktst-I: before sp 177334 (0,  4,36); 177334 (0,  4,36);
  # stktst-I: after  sp 177334 (0,  4,36); 177334 (0,  4,36); 167334 (0, 68,36);
./stktst f '14263'
  # stktst-I: before sp 177334 (0,  4,36); 177334 (0,  4,36);
  # stktst-I: after  sp 177334 (0,  4,36); 177334 (0,  4,36); 020000 (6,127,64);
./stktst f '14264'
  # stktst-I: before sp 177334 (0,  4,36); 177334 (0,  4,36);
  # Segmentation fault (core dumped)

```

Extending with `double` pushes works when the `double` is aligned on an
8 byte border. In this case the 4 byte correction done in 2.11BSD #473
ensures that the `sp` is interpreted as below current allocation.
The alignment is set up with `-c 2 -o 0`:
```
./stktst d ' 512' -c '   2' -o '   0'
  # stktst-I: before sp 177304 (0,  4,60); 177200 (0,  5,64);
  # stktst-I: after  sp 177304 (0,  4,60); 177200 (0,  5,64); 167200 (0, 69,64);
./stktst d '7120' -c '   2' -o '   0'
  # stktst-I: before sp 177304 (0,  4,60); 177200 (0,  5,64);
  # stktst-I: after  sp 177304 (0,  4,60); 177200 (0,  5,64); 020000 (6,127,64);
./stktst d '7121' -c '   2' -o '   0'
  # stktst-I: before sp 177304 (0,  4,60); 177200 (0,  5,64);
  # Segmentation fault (core dumped)
```

Misaligned `double` pushes fail as expected.
A 4 byte misalignment is set up with `-c 2 -o -4`.
Even with the 4 byte correction the `sp` appears to be in the allocated area,
and a `SIGSEGV` is taken:
```
./stktst d '   1' -c '   2' -o '  -4'
  # stktst-I: before sp 177304 (0,  4,60); 177174 (0,  6, 4);
  # stktst-I: after  sp 177304 (0,  4,60); 177174 (0,  6, 4); 177164 (0,  6,12);
./stktst d ' 319' -c '   2' -o '  -4'
  # stktst-I: before sp 177304 (0,  4,60); 177174 (0,  6, 4);
  # stktst-I: after  sp 177304 (0,  4,60); 177174 (0,  6, 4); 172204 (0, 45,60);
./stktst d ' 320' -c '   2' -o '  -4'
  # stktst-I: before sp 177304 (0,  4,60); 177174 (0,  6, 4);
  # Segmentation fault (core dumped)
```

The initial stack size is 20 clicks
(see [SSIZE](https://www.retro11.de/ouxr/211bsd/usr/src/sys/pdp/machparam.h.html#m:SSIZE)),
the stack increment is also 20 clicks
(see [SINCR](https://www.retro11.de/ouxr/211bsd/usr/src/sys/pdp/machparam.h.html#m:SINCR)).
The initial stack segment size is a bit larger due to argument and environment
allocations.
In the tests it was 24 clicks as tests with the **r** command show:
```
./stktst r 0175004
  # OK
./stktst r 0175000
  # OK
./stktst r 0174776
  # Segmentation fault (core dumped)
```

It is therefore a bit surprising that the failure happens at the border
expected for the second stack extend and not around 0175000.
