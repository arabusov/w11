#!/usr/bin/perl -w
# $Id: asm-11 1356 2023-01-26 15:10:23Z mueller $
# SPDX-License-Identifier: GPL-3.0-or-later
# Copyright 2013-2023 by Walter F.J. Mueller <W.F.J.Mueller@gsi.de>
#
#  Revision History:
# Date         Rev Version  Comment
# 2023-01-25  1355   1.2.2  rewrite macro args handling; add .narg,.nchr,.ntype
# 2023-01-24  1354   1.2.1  add .error,.print,.mcall,.mdelete; add -L; add ...top
# 2023-01-22  1353   1.2    add .if, .if(f|t|tf), .endc, .rept, .endr, .mexit
#                           add flag (MRmrd) column in output format
# 2023-01-13  1352   1.1.5  BUGFIX: misused # and @ don't cause BUGCHECK anymore
# 2023-01-12  1351   1.1.4  BUGFIX: support @(R) modifier with omitted offset
# 2022-07-28  1264   1.1.3  add -E and -M options
# 2022-07-23  1262   1.1.2  BUGFIX: '100(pc)' was compiled as '100'
# 2019-07-13  1189   1.1.1  drop superfluous exists for $opts
# 2019-05-25  1152   1.1    add .macro,.endm,.list,.nlist
# 2019-04-25  1138   1.0.7  print lines with errors to stderr unless -lst seen
# 2019-04-19  1133   1.0.6  .end directive autocreates '...end' label
# 2018-11-03  1065   1.0.5  add and use bailout
# 2015-11-01   712   1.0.4  BUGFIX: fix '.' handling in instructions
# 2014-07-26   575   1.0.3  add 'call' and 'return' to pst (as in macro-11)
# 2013-04-07   503   1.0.2  list dot for .even,.dot,.blkb,.blkw
# 2013-04-01   502   1.0.1  BUGFIX: -2(r0),@-2(r0) was broken, parser fixed
#                           add -lsm (lsmem format) output; add implicit .word
# 2013-03-29   501   1.0    Initial version
# 2013-03-22   498   0.5    Second draft (functional, but very limited...)
# 2013-03-07   496   0.1    First draft
#

use 5.14.0;                                 # require Perl 5.14 or higher
use strict;                                 # require strict checking
use FileHandle;

use Getopt::Long;

use constant TMASK_STRING     => 0x0001;
use constant TMASK_STRINGEXP  => 0x0002;
use constant TMASK_MACROARG   => 0x0004;

my %opts = ();

GetOptions(\%opts, "help", "E", "M",
                   "tpass1", "tpass2",
                   "dsym1",  "dsym2",
                   "ttoken", "tparse", "temit", "tout",
                   "I=s@",
                   "L=s@",
                   "lst", "olst=s",
                   "lda", "olda=s",
                   "cof", "ocof=s",
                   "lsm", "olsm=s"
          )
  or bailout("bad command options");

unshift @{$opts{I}}, ".";                  # ./ is first in include path
push @{$opts{I}}, "$ENV{RETROBASE}/tools/asm-11" if defined $ENV{RETROBASE};
push @{$opts{L}}, "$ENV{RETROBASE}/tools/asm-11/mlib" if defined $ENV{RETROBASE};

# Permanant symbol table
my %pst = (
# directives
 '.include' => {typ=>'dir'},                #
 '.word'    => {typ=>'dir'},                #
 '.byte'    => {typ=>'dir'},                #
 '.blkw'    => {typ=>'dir'},                #
 '.blkb'    => {typ=>'dir'},                #
 '.ascii'   => {typ=>'dir'},                #
 '.asciz'   => {typ=>'dir'},                #
 '.even'    => {typ=>'dir'},                #
 '.odd'     => {typ=>'dir'},                #
 '.asect'   => {typ=>'dir'},                #
 '.macro'   => {typ=>'dir'},                #
 '.endm'    => {typ=>'dir'},                #
 '.mexit'   => {typ=>'dir'},                #
 '.mcall'   => {typ=>'dir'},                #
 '.mdelete' => {typ=>'dir'},                #
 '.narg'    => {typ=>'dir'},                #
 '.nchr'    => {typ=>'dir'},                #
 '.ntype'   => {typ=>'dir'},                #
 '.rept'    => {typ=>'dir'},                #
 '.endr'    => {typ=>'dir'},                #
 '.if'      => {typ=>'dir'},                #
 '.iff'     => {typ=>'dir'},                #
 '.ift'     => {typ=>'dir'},                #
 '.iftf'    => {typ=>'dir'},                #
 '.endc'    => {typ=>'dir'},                #
 '.error'   => {typ=>'dir'},                #
 '.print'   => {typ=>'dir'},                #
 '.list'    => {typ=>'dir'},                #
 '.nlist'   => {typ=>'dir'},                #
 '.end'     => {typ=>'dir'},                #
#register defs
 'r0'     => {typ=>'reg', val=>0},
 'r1'     => {typ=>'reg', val=>1},
 'r2'     => {typ=>'reg', val=>2},
 'r3'     => {typ=>'reg', val=>3},
 'r4'     => {typ=>'reg', val=>4},
 'r5'     => {typ=>'reg', val=>5},
 'sp'     => {typ=>'reg', val=>6},
 'pc'     => {typ=>'reg', val=>7},
#opcodes
 'halt'   => {typ=>'op', val=>0000000, fmt=>'-'  },
 'wait'   => {typ=>'op', val=>0000001, fmt=>'-'  },
 'rti'    => {typ=>'op', val=>0000002, fmt=>'-'  },
 'bpt'    => {typ=>'op', val=>0000003, fmt=>'-'  },
 'iot'    => {typ=>'op', val=>0000004, fmt=>'-'  },
 'reset'  => {typ=>'op', val=>0000005, fmt=>'-'  },
 'rtt'    => {typ=>'op', val=>0000006, fmt=>'-'  },
 'mfpt'   => {typ=>'op', val=>0000007, fmt=>'-'  },
 'jmp'    => {typ=>'op', val=>0000100, fmt=>'g'  },
 'rts'    => {typ=>'op', val=>0000200, fmt=>'r'  },
 'return' => {typ=>'op', val=>0000207, fmt=>'-'  }, # alias for rts pc
 'spl'    => {typ=>'op', val=>0000230, fmt=>'n3' },
 'nop'    => {typ=>'op', val=>0000240, fmt=>'-'  },
 'clc'    => {typ=>'op', val=>0000241, fmt=>'-'  },
 'clv'    => {typ=>'op', val=>0000242, fmt=>'-'  },
 'clz'    => {typ=>'op', val=>0000244, fmt=>'-'  },
 'cln'    => {typ=>'op', val=>0000250, fmt=>'-'  },
 'ccc'    => {typ=>'op', val=>0000257, fmt=>'-'  },
 'sec'    => {typ=>'op', val=>0000261, fmt=>'-'  },
 'sev'    => {typ=>'op', val=>0000262, fmt=>'-'  },
 'sez'    => {typ=>'op', val=>0000264, fmt=>'-'  },
 'sen'    => {typ=>'op', val=>0000270, fmt=>'-'  },
 'scc'    => {typ=>'op', val=>0000277, fmt=>'-'  },
 'swab'   => {typ=>'op', val=>0000300, fmt=>'g'  },
 'br'     => {typ=>'op', val=>0000400, fmt=>'s8' },
 'bne'    => {typ=>'op', val=>0001000, fmt=>'s8' },
 'beq'    => {typ=>'op', val=>0001400, fmt=>'s8' },
 'bge'    => {typ=>'op', val=>0002000, fmt=>'s8' },
 'blt'    => {typ=>'op', val=>0002400, fmt=>'s8' },
 'bgt'    => {typ=>'op', val=>0003000, fmt=>'s8' },
 'ble'    => {typ=>'op', val=>0003400, fmt=>'s8' },
 'jsr'    => {typ=>'op', val=>0004000, fmt=>'rg' },
 'call'   => {typ=>'op', val=>0004700, fmt=>'g'  }, # alias for jsr pc,<dst>
 'clr'    => {typ=>'op', val=>0005000, fmt=>'g'  },
 'com'    => {typ=>'op', val=>0005100, fmt=>'g'  },
 'inc'    => {typ=>'op', val=>0005200, fmt=>'g'  },
 'dec'    => {typ=>'op', val=>0005300, fmt=>'g'  },
 'neg'    => {typ=>'op', val=>0005400, fmt=>'g'  },
 'adc'    => {typ=>'op', val=>0005500, fmt=>'g'  },
 'sbc'    => {typ=>'op', val=>0005600, fmt=>'g'  },
 'tst'    => {typ=>'op', val=>0005700, fmt=>'g'  },
 'ror'    => {typ=>'op', val=>0006000, fmt=>'g'  },
 'rol'    => {typ=>'op', val=>0006100, fmt=>'g'  },
 'asr'    => {typ=>'op', val=>0006200, fmt=>'g'  },
 'asl'    => {typ=>'op', val=>0006300, fmt=>'g'  },
 'mark'   => {typ=>'op', val=>0006400, fmt=>'n6' },
 'mfpi'   => {typ=>'op', val=>0006500, fmt=>'g'  },
 'mtpi'   => {typ=>'op', val=>0006600, fmt=>'g'  },
 'sxt'    => {typ=>'op', val=>0006700, fmt=>'g'  },
 'csm'    => {typ=>'op', val=>0007000, fmt=>'g'  },
 'tstset' => {typ=>'op', val=>0007200, fmt=>'g'  },
 'wrtlck' => {typ=>'op', val=>0007300, fmt=>'g'  },
 'mov'    => {typ=>'op', val=>0010000, fmt=>'gg' },
 'cmp'    => {typ=>'op', val=>0020000, fmt=>'gg' },
 'bit'    => {typ=>'op', val=>0030000, fmt=>'gg' },
 'bic'    => {typ=>'op', val=>0040000, fmt=>'gg' },
 'bis'    => {typ=>'op', val=>0050000, fmt=>'gg' },
 'add'    => {typ=>'op', val=>0060000, fmt=>'gg' },
 'mul'    => {typ=>'op', val=>0070000, fmt=>'gr' },
 'div'    => {typ=>'op', val=>0071000, fmt=>'gr' },
 'ash'    => {typ=>'op', val=>0072000, fmt=>'gr' },
 'ashc'   => {typ=>'op', val=>0073000, fmt=>'gr' },
 'xor'    => {typ=>'op', val=>0074000, fmt=>'rg' },
 'sob'    => {typ=>'op', val=>0077000, fmt=>'ru6'},
 'bpl'    => {typ=>'op', val=>0100000, fmt=>'s8' },
 'bmi'    => {typ=>'op', val=>0100400, fmt=>'s8' },
 'bhi'    => {typ=>'op', val=>0101000, fmt=>'s8' },
 'blos'   => {typ=>'op', val=>0101400, fmt=>'s8' },
 'bvc'    => {typ=>'op', val=>0102000, fmt=>'s8' },
 'bvs'    => {typ=>'op', val=>0102400, fmt=>'s8' },
 'bcc'    => {typ=>'op', val=>0103000, fmt=>'s8' },
 'bhis'   => {typ=>'op', val=>0103000, fmt=>'s8' }, #alias
 'bcs'    => {typ=>'op', val=>0103400, fmt=>'s8' },
 'blo'    => {typ=>'op', val=>0103400, fmt=>'s8' }, #alias
 'emt'    => {typ=>'op', val=>0104000, fmt=>'n8' },
 'trap'   => {typ=>'op', val=>0104400, fmt=>'n8' },
 'clrb'   => {typ=>'op', val=>0105000, fmt=>'g'  },
 'comb'   => {typ=>'op', val=>0105100, fmt=>'g'  },
 'incb'   => {typ=>'op', val=>0105200, fmt=>'g'  },
 'decb'   => {typ=>'op', val=>0105300, fmt=>'g'  },
 'negb'   => {typ=>'op', val=>0105400, fmt=>'g'  },
 'adcb'   => {typ=>'op', val=>0105500, fmt=>'g'  },
 'sbcb'   => {typ=>'op', val=>0105600, fmt=>'g'  },
 'tstb'   => {typ=>'op', val=>0105700, fmt=>'g'  },
 'rorb'   => {typ=>'op', val=>0106000, fmt=>'g'  },
 'rolb'   => {typ=>'op', val=>0106100, fmt=>'g'  },
 'asrb'   => {typ=>'op', val=>0106200, fmt=>'g'  },
 'aslb'   => {typ=>'op', val=>0106300, fmt=>'g'  },
 'mtps'   => {typ=>'op', val=>0106400, fmt=>'g'  },
 'mfpd'   => {typ=>'op', val=>0106500, fmt=>'g'  },
 'mtpd'   => {typ=>'op', val=>0106600, fmt=>'g'  },
 'mfps'   => {typ=>'op', val=>0106700, fmt=>'g'  },
 'movb'   => {typ=>'op', val=>0110000, fmt=>'gg' },
 'cmpb'   => {typ=>'op', val=>0120000, fmt=>'gg' },
 'bitb'   => {typ=>'op', val=>0130000, fmt=>'gg' },
 'bicb'   => {typ=>'op', val=>0140000, fmt=>'gg' },
 'bisb'   => {typ=>'op', val=>0150000, fmt=>'gg' },
 'sub'    => {typ=>'op', val=>0160000, fmt=>'gg' },
 'cfcc'   => {typ=>'op', val=>0170000, fmt=>'-'  ,fpp=>1 },
 'setf'   => {typ=>'op', val=>0170001, fmt=>'-'  ,fpp=>1 },
 'setd'   => {typ=>'op', val=>0170011, fmt=>'-'  ,fpp=>1 },
 'seti'   => {typ=>'op', val=>0170002, fmt=>'-'  ,fpp=>1 },
 'setl'   => {typ=>'op', val=>0170012, fmt=>'-'  ,fpp=>1 },
 'ldfps'  => {typ=>'op', val=>0170100, fmt=>'g'  ,fpp=>1 },
 'stfps'  => {typ=>'op', val=>0170200, fmt=>'g'  ,fpp=>1 },
 'stst'   => {typ=>'op', val=>0170300, fmt=>'g'  ,fpp=>1 },
 'clrf'   => {typ=>'op', val=>0170400, fmt=>'g'  ,fpp=>1 },
 'clrd'   => {typ=>'op', val=>0170400, fmt=>'g'  ,fpp=>1 }, # alias
 'tstf'   => {typ=>'op', val=>0170500, fmt=>'g'  ,fpp=>1 },
 'tstd'   => {typ=>'op', val=>0170500, fmt=>'g'  ,fpp=>1 }, # alias
 'absf'   => {typ=>'op', val=>0170600, fmt=>'g'  ,fpp=>1 },
 'absd'   => {typ=>'op', val=>0170600, fmt=>'g'  ,fpp=>1 }, # alias
 'negf'   => {typ=>'op', val=>0170700, fmt=>'g'  ,fpp=>1 },
 'negd'   => {typ=>'op', val=>0170700, fmt=>'g'  ,fpp=>1 }, # alias
 'mulf'   => {typ=>'op', val=>0171000, fmt=>'gr' ,fpp=>1 },
 'muld'   => {typ=>'op', val=>0171000, fmt=>'gr' ,fpp=>1 }, # alias
 'modf'   => {typ=>'op', val=>0171400, fmt=>'gr' ,fpp=>1 },
 'modd'   => {typ=>'op', val=>0171400, fmt=>'gr' ,fpp=>1 }, # alias
 'addf'   => {typ=>'op', val=>0172000, fmt=>'gr' ,fpp=>1 },
 'addd'   => {typ=>'op', val=>0172000, fmt=>'gr' ,fpp=>1 }, # alias
 'ldf'    => {typ=>'op', val=>0172400, fmt=>'gr' ,fpp=>1 },
 'ldd'    => {typ=>'op', val=>0172400, fmt=>'gr' ,fpp=>1 }, # alias
 'subf'   => {typ=>'op', val=>0173000, fmt=>'gr' ,fpp=>1 },
 'subd'   => {typ=>'op', val=>0173000, fmt=>'gr' ,fpp=>1 }, # alias
 'cmpf'   => {typ=>'op', val=>0173400, fmt=>'gr' ,fpp=>1 },
 'cmpd'   => {typ=>'op', val=>0173400, fmt=>'gr' ,fpp=>1 }, # alias
 'stf'    => {typ=>'op', val=>0174000, fmt=>'rg' ,fpp=>1 },
 'std'    => {typ=>'op', val=>0174000, fmt=>'rg' ,fpp=>1 }, # alias
 'divf'   => {typ=>'op', val=>0174400, fmt=>'gr' ,fpp=>1 },
 'divd'   => {typ=>'op', val=>0174400, fmt=>'gr' ,fpp=>1 }, # alias
 'stexp'  => {typ=>'op', val=>0175000, fmt=>'rg' ,fpp=>1 },
 'stcfi'  => {typ=>'op', val=>0175400, fmt=>'rg' ,fpp=>1 },
 'stcfl'  => {typ=>'op', val=>0175400, fmt=>'rg' ,fpp=>1 }, # alias
 'stcdi'  => {typ=>'op', val=>0175400, fmt=>'rg' ,fpp=>1 }, # alias
 'stcdl'  => {typ=>'op', val=>0175400, fmt=>'rg' ,fpp=>1 }, # alias
 'stcfd'  => {typ=>'op', val=>0176000, fmt=>'rg' ,fpp=>1 },
 'stcdf'  => {typ=>'op', val=>0176000, fmt=>'rg' ,fpp=>1 }, # alias
 'ldexp'  => {typ=>'op', val=>0176400, fmt=>'gr' ,fpp=>1 },
 'ldcif'  => {typ=>'op', val=>0177000, fmt=>'gr' ,fpp=>1 },
 'ldcid'  => {typ=>'op', val=>0177000, fmt=>'gr' ,fpp=>1 }, # alias
 'ldclf'  => {typ=>'op', val=>0177000, fmt=>'gr' ,fpp=>1 }, # alias
 'ldcld'  => {typ=>'op', val=>0177000, fmt=>'gr' ,fpp=>1 }, # alias
 'ldcdf'  => {typ=>'op', val=>0177400, fmt=>'gr' ,fpp=>1 },
 'ldcfd'  => {typ=>'op', val=>0177400, fmt=>'gr' ,fpp=>1 }  # alias
);

# operand formats
my %opfmt = (
 '-'   => [],                                                  # halt,...
 'n3'  => [{typ=>'e', pref=>''}],                              # spl
 'n6'  => [{typ=>'e', pref=>''}],                              # mark
 'n8'  => [{typ=>'e', pref=>''}],                              # trap,emt
 'r'   => [{typ=>'r', pref=>'o1'}],                            # rts
 'g'   => [{typ=>'g', pref=>'o1'}],                            # inc,...
 'rg'  => [{typ=>'r', pref=>'o1'}, {typ=>'g', pref=>'o2'}],    # xor,jsr
 'gr'  => [{typ=>'g', pref=>'o2'}, {typ=>'r', pref=>'o1'}],    # ash,...
 'gg'  => [{typ=>'g', pref=>'o1'}, {typ=>'g', pref=>'o2'}],    # add,...
 's8'  => [{typ=>'e', pref=>''}],                              # br,...
 'ru6' => [{typ=>'r', pref=>'o1'}, {typ=>'e', pref=>''}]       # sob
);

# psect table
my %psect =
('.abs.'  => {dot=>0, dotmax=>0}
);
my $cur_psect = '.abs.';                    # current psect

# local symbol table
my %lst =
  ('.'       => {name=>'.',      typ=>'dot', val=>0,  psect=>'.abs.'},
   '...top'  => {name=>'...top', typ=>'lbl', val=>0,  psect=>'.abs.'}
);
my $llbl_scope = '0';                       # current local label scope
my $llbl_ascope = 0;                        # annonymous local label scope count

# macro table
my %mst;
my $mdefnam;                                # macro currently being defined
my $mdeflvl = 0;                            # .macro definition depth
my @mexecstk;                               # macro execution stack
my $mexit = 0;                              # mexit flag
my $mautolbl = 30000;                       # auto-generated label
# rept stack
my @reptstk;                                # active .rept stack
my $reptlvl = 0;                            # .rept definition depth
# conditional assembly stack
my @ifstk;                                  # if stack {tst=>0|1, cur=>0|1}
my $ifcond;                                 # current if condition
# .end handlinh
my $end = 0;

# files
my @flist;                                  # list of filenames
my $fstem;                                  # stem of last file name
my $lst_do;                                 # generate listing
my $lst_fname;                              # listing file name
my $lda_do;                                 # generate lda output
my $lda_fname;                              # lda file name
my $cof_do;                                 # generate cof output
my $cof_fname;                              # cof file name
my $lsm_do;                                 # generate lsm output
my $lsm_fname;                              # lsm file name

my @src;
my %errcnt;                                 # error tag counter
my $errcnt_tot=0;                           # total error count
my $pass;

my @t_pushback;

my $defincdot = 0;                          # defered increment for '.'
my $out_dot;                                # current . for output
my @out_data;                               # output data

autoflush STDOUT 1 if (-p STDOUT);          # autoflush if output into pipe

if ($opts{help}) {
  print_help();
  exit 0;
}

bailout("no input files specified") if scalar(@ARGV) == 0;

# find stem of last file name
$fstem = $ARGV[-1];
$fstem =~ s|^.*/||;                         # drop leading dirs
$fstem =~ s|\.mac$||;                       # drop trailing '.mac'

if ($opts{lst} || $opts{olst}) {
  $lst_do = 1;
  $lst_fname = create_fname($opts{olst},'.lst');
}

if ($opts{lda} || $opts{olda}) {
  $lda_do = 1;
  $lda_fname = create_fname($opts{olda},'.lda');
}

if ($opts{cof} || $opts{ocof}) {
  $cof_do = 1;
  $cof_fname = create_fname($opts{ocof},'.cof');
}

if ($opts{lsm} || $opts{olsm}) {
  $lsm_do = 1;
  $lsm_fname = create_fname($opts{olsm},'.lsm');
}

# do pass 1
$pass = 1;
foreach my $fname (@ARGV) {
  read_file($fname);
}
if ($end == 0 && ($mdeflvl + $reptlvl +     # no .end but .macro or .rept open
                  scalar(@ifstk) != 0)) {     # or .endc open
  pass1_line(1, 0, '', ' ');                  # add dummy line
  add_err($src[-1], 'E');                     # and signal E error
}
exit 0 if $opts{E} || $opts{M};             # stop after pass1 for -E -M
$lst{'...top'}->{val} = $psect{'.abs.'}{dotmax};
dump_sym() if $opts{dsym1};

# prepare pass 2

foreach (keys %psect) {
  $psect{$_}{dot} = 0;
}

$lst{'.'}->{val} = 0;
$lst{'.'}->{psect} = '.abs.';

$cur_psect  = '.abs.';
$llbl_scope = '0';

# do pass 2
$pass = 2;
pass2();
dump_sym() if $opts{dsym2};

# create object output files
write_lda($lda_fname) if $lda_do;
write_cof($cof_fname) if $cof_do;
write_lsm($lsm_fname) if $lsm_do;

# and exit
if ($errcnt_tot > 0) {
  print STDERR "asm-11-E: compilation errors:";
  foreach my $err (sort keys %errcnt) {
    printf STDERR "  %s: %d", $err, $errcnt{$err};
  }
  print STDERR "\n";
  exit 1;
}
exit 0;

#-------------------------------------------------------------------------------

sub create_fname {
  my ($fname,$suff) = @_;
  if (defined $fname) {
    $fname =~ s|\%|$fstem|;
    return $fname;
  }
  $fname = $fstem;
  $fname .= $suff unless $fname eq '-';
  return $fname;
}

#-------------------------------------------------------------------------------

sub read_file {
  my ($fname) = @_;
  my $fh;
  if ($fname eq "-") {
    $fh = *STDIN;
  } else {
    bailout("'$fname' not found or readable") if (not -r $fname);
    $fh = new FileHandle;
    $fh->open($fname) or bailout("failed to open '$fname': $!");
  }

  push @flist, $fname;
  if ($opts{M}) {
    printf "%s : %s\n", create_fname($opts{olda},'.lda'), $fname;
    printf "%s : %s\n", create_fname($opts{olda},'.lst'), $fname;
  }

  my $lineno = 0;
  my $fileno = scalar(@flist);
  while (<$fh>) {
    chomp;
    my $line = $_;
    if ($opts{E} && $line !~ m/\s*\.(include|mcall)/) {   # if -E and no include
      printf "$line\n";                           # write to stdout
    }
    $lineno += 1;
    pass1_line($fileno, $lineno, $line, ' ');
    last if $end;
  }

  return;
}

#-------------------------------------------------------------------------------

sub exec_macro {
  my ($rmexec) = @_;
  my $mname = $rmexec->{name};
  my $ifstklvl = scalar(@ifstk);            # remember initial .if stack depth
  push @mexecstk, {name => $mname,
                   narg => $rmexec->{narg}};
  foreach my $rmline (@{$mst{$mname}{body}}) {
    my $lrest  = $rmline->{line};
    my $fileno = $rmline->{fileno};
    my $lineno = $rmline->{lineno};
    my $line   = '';
    while ($lrest =~ m/([a-zA-Z\$\.][a-zA-Z0-9\$\.]*)/) {
      $line .= $`;
      $line .= (defined $rmexec->{vals}{$1}) ? $rmexec->{vals}{$1} : $1;
      $lrest = $';
      if (length($lrest) > 0 && substr($lrest,0,1) eq "'") { # concatenation
        $lrest = substr($lrest,1);
      }
    }
    $line .= $lrest;
    $mexit = 0;
    pass1_line($fileno, $lineno, $line, 'm');
    last if $mexit;
  }
  $mexit = 0;
  pop @mexecstk;
  while (scalar(@ifstk) > $ifstklvl) {pop @ifstk;} # drop dangling .if's
  return;
}

#-------------------------------------------------------------------------------
sub delete_macro {
  my ($mname) = @_;
  return 1 unless exists $mst{$mname};
  delete $mst{$mname};
  return 0;
}

#-------------------------------------------------------------------------------

sub pass1_line {
  my ($fileno,$lineno,$line,$flag) = @_;

  my $rl = parse_line($fileno, $lineno, $line, $flag);
  dump_rl($rl) if $opts{tpass1};
  push @src, $rl;

  # handle .include ----------------------------------------
  if (defined $$rl{oper} && $$rl{oper} eq '.include' && defined $$rl{ifile}) {
    my $fnam = $$rl{ifile};
    unless ($fnam =~ m|^/|) {
      foreach (@{$opts{I}}) {
        if (-r "$_/$fnam") {
          $fnam = "$_/$fnam";
          last;
        }
      }
    }
    read_file($fnam);
  }

  # handle .mcall ------------------------------------------
  if (defined $$rl{oper} && $$rl{oper} eq '.mcall') {
    foreach my $mname (@{$$rl{mcall}}) {
      my $fname;
      foreach (@{$opts{L}}) {
        if (-r "$_/${mname}.mac") {
          $fname = "$_/${mname}.mac";
          last;
        }
      }
      if (defined $fname) {
        my $fh = new FileHandle;
        $fh->open($fname) or bailout("failed to open '$fname': $!");

        push @flist, $fname;
        if ($opts{M}) {
          printf "%s : %s\n", create_fname($opts{olda},'.lda'), $fname;
          printf "%s : %s\n", create_fname($opts{olda},'.lst'), $fname;
        }
        my $lineno = 0;
        my $fileno = scalar(@flist);
        my $mseen;
        while (<$fh>) {
          chomp;
          my $line = $_;
          $lineno += 1;
          $mseen = 1 if $line =~m/^\s*\.macro/; # .macro seen ?
          next unless $mseen;
          pass1_line($fileno, $lineno, $line, ' ');
          printf "$line\n" if $opts{E};     # if -E write to stdout
          last if $mdeflvl == 0;                # final .endm seen ?
        }
      } else {
        add_err($rl,'U');
      }
    }
  }

  # handle .rept expansions --------------------------------
  if (defined $$rl{oper} && $$rl{oper} eq '.endr') {
    if (scalar(@reptstk) > 0) {
      my $ifstklvl = scalar(@ifstk);    # remember initial .if stack depth
      my $cnt = $reptstk[-1]{cnt};
      for (my $i=0; $i<$cnt; $i++) {    # repeat body cnt times
        foreach my $rline (@{$reptstk[-1]{body}}) {
          $mexit = 0;
          pass1_line($rline->{fileno}, $rline->{lineno}, $rline->{line}, 'r');
          last if $mexit;
        }
        last if $mexit;
      }
      $mexit = 0;
      pop @reptstk;
      while (scalar(@ifstk) > $ifstklvl) {pop @ifstk;} # drop dangling .if's
    }
  }

  # handle macro expansions --------------------------------
  if (defined $$rl{oper} && defined $$rl{mexec}) {
    exec_macro($$rl{mexec});
  }
  return;
}

#-------------------------------------------------------------------------------

sub parse_line {
  my ($fileno,$lineno,$line,$flag) = @_;

  my %l = ( fileno => $fileno,              # file number
            lineno => $lineno,              # line number
            line   => $line,                # line
            cl     => [split '',$line],     # char list
            tl     => [],                   # token list
            err    => '',                   # error tags
            flag   => $flag,                # line flag
            psect  => $cur_psect,           # current psect
            dot    => getdot(),             # current dot
            outw   => [],                   # output: words
            outb   => []                    # output: bytes
          );

  my $state = 'start';                      # parser state

  my $op_code;                              # op code
  my $op_fmt;                               # op format
  my $op_fpp;                               # true if floating opcode
  my @op_ops;                               # list of operands
  my $op_rop;                               # ref of current operand dsc

  my $s_incok;
  my $op_ibeg;
  my $op_creg;                              # current register
  my $op_cmod;                              # current modifier
  my $op_crel;                              # current pc relative flag
  my $op_cmod_def;

  my @e_pbeg;
  my $e_ibeg;
  my $e_iend;

  my $a_sym;
  my $a_typ;

  my $d_dire;
  my @d_elist;

  my $c;
  my $rt;
  my $tmask = 0;

  my @stack;

  @t_pushback = ();

  printf "-- parse: '$line'\n" if $opts{tparse} || $opts{ttoken};

  # quit if invalid character found (non 7 bit ascii in asm-11)
  foreach my $c (@{$l{cl}}) {
    if (ord($c) > 127) {
      add_err(\%l, 'I');
      return \%l;
    }
  }

  # handling for .macro and .rept definitions and conditional blocks
  my $dnam = '';
  my $ltrim = $line;
  $ltrim =~ s/^[a-zA-Z\$\.][a-zA-Z0-9\$\.]*://; # trim label
  $ltrim =~ s/^[0-9]+\$]://;                    # trim local label
  $ltrim =~ s/^\s*//;                           # trim leading white
  if ($ltrim =~ m/^(\.[a-zA-Z\$\.][a-zA-Z0-9\$\.]*)/) {  # directive seen
    $dnam = $1;
  }

  if (scalar(@ifstk)) {                     # is .if conditional block active ?
    unless ($dnam =~ m/^\.(iff|ift|iftf|endc)$/) { # and not sub-cond or end
      unless ($ifstk[-1]{cur}) {            # if (sub-)cond false
        $l{flag} = 'd';                       # mark condition drop
        return \%l;                           # ignore line
      }
    }
  }

  if ($reptlvl > 0) {                       # handle .rept definition
    $reptlvl += 1 if $dnam eq '.rept';      #   nested .rept found ?
    $reptlvl -= 1 if $dnam eq '.endr';      #   .endr found ?
    if ($reptlvl > 0) {                     # final .endr not yet seen
      $l{flag} = 'R';
      push @{$reptstk[-1]{body}}, {line   => $l{line},
                                   fileno => $l{fileno},
                                   lineno => $l{lineno}
                                  };
      return \%l;
    }
  }

  if (defined $mdefnam) {                   # handle .macro definition
    $mdeflvl += 1 if $dnam eq '.macro';     #   nested .macro found ?
    $mdeflvl -= 1 if $dnam eq '.endm';      #   .endm found ?
    if ($mdeflvl > 0) {
      $l{flag} = 'M';
      push @{$mst{$mdefnam}{body}}, {line   => $l{line},
                                     fileno => $l{fileno},
                                     lineno => $l{lineno}
                                    };
      return \%l;
    }
  }

  STATE: while (1) {
    if ($opts{tparse}) {
      printf "-- state = %-8s",$state;
      my $rest = '';
      foreach my $t (@t_pushback) { $rest .= $t->{val} if defined $t->{val}; }
      foreach my $c (@{$l{cl}})   { $rest .= $c; }
      $rest =~ s/\s+/ /g;
      if (length($rest)>17) {
        $rest = substr($rest,0,17) . '...';
      }
      while (length($rest) < 20) { $rest .= ' ' }
      printf "@ \"%s\"", $rest;
      printf ", nest = %d", scalar(@e_pbeg) if $state =~ m/^e_/;
      print  "\n";
    }

    if ($state eq 'start') {                # state: start -------------------
      $rt = get_token(\%l, $tmask);

      # end of line seen ?
      if      ($$rt{tag} eq 'EOL') {
        last;

      # name seen
      } elsif ($$rt{tag} eq 'SYM') {
        # directive name seen ?
        if (exists $pst{$$rt{val}} && $pst{$$rt{val}}{typ} eq 'dir') {
          $state = 'oper';
        # macro name seen ?
        } elsif (exists $mst{$$rt{val}}) {
          $state = 'oper';

        # otherwise check for label or assignment
        } else {
          my $isllbl = check_llbl($$rt{val});
          $rt = get_token(\%l, $tmask);
          # handle local labels
          if      ($isllbl) {
            if ($$rt{tag} eq 'LBL') {
              setsym(\%l, 'lbl' ,$l{tl}[-2]{val}, getdot());
              $l{lscope} = $llbl_scope;
              $l{label} = $l{tl}[-2]{val};
              $state = 'start1';
            } else {
              $state = 'q';
            }
          # handle assignments
          } elsif ($$rt{tag} eq 'ASS') {
            $a_sym = $l{tl}[-2]{val};
            $a_typ = $l{tl}[-1]{val};
            push @stack, 'a_end';
            $state = 'e_beg';
          # handle normal labels
          } elsif ($$rt{tag} eq 'LBL') {
            setsym(\%l, 'lbl' ,$l{tl}[-2]{val}, getdot());
            $llbl_scope = $l{tl}[-2]{val};
            $l{lscope} = $l{tl}[-2]{val};
            $l{label} = $l{tl}[-2]{val};
            $state = 'start1';
          # if neither label or assigmnent, handle as operation or directive
          } else {
            pushback_token(\%l);
            $state = 'oper';
          }
        }

      # anything else seen, treat as implicit .word
      } else {
        pushback_token(\%l);
        $state = 'iword';
      }

    } elsif ($state eq 'start1') {          # state: start1 ------------------
      $rt = get_token(\%l, $tmask);
      if      ($$rt{tag} eq 'EOL') {
        last;
      } elsif ($$rt{tag} eq 'SYM') {
        $state = 'oper';
      } else {                              # not symbol -> implicit .word
        pushback_token(\%l);
        $state = 'iword';
      }

    } elsif ($state eq 'oper') {            # state: oper --------------------
      # Note: state oper is entered with token already on tl list !!
      my $rt0 = $l{tl}[-1];
      my $op = $$rt0{val};
      $l{oper} = $op;
      if (exists $pst{$op}) {
        my $rs = $pst{$op};
        if ($$rs{typ} eq 'dir') {           # directives ------------------
          $d_dire = $op;
          if      ($op eq '.word' ||          # .word ----------------
                   $op eq '.byte') {          # .byte ----------------
            $state = 'dl_beg';

          } elsif ($op eq '.blkw' ||          # .blkw ----------------
                   $op eq '.blkb') {          # .blkb ----------------
            $state = 'dl_beg';

          } elsif ($op eq '.ascii' ||         # .ascii ---------------
                   $op eq '.asciz') {         # .asciz ---------------
            $tmask = TMASK_STRING;
            $state = 'al_next';

          } elsif ($op eq '.even' ||          # .even ----------------
                   $op eq '.odd') {           # .odd -----------------
            my $dot = getdot();
            my $inc = 0;
            $inc = 1 if $op eq '.even' && ($dot&01)==1;
            $inc = 1 if $op eq '.odd'  && ($dot&01)==0;
            incdot(1) if $inc;
            $l{typ}    = 'data';
            $l{incdot} = $inc;
            $l{lstdot} = 1;
            $state = 'end';

          } elsif ($op eq '.asect') {         # .asect ---------------
            # .asect is currently a noop because asect is start default
            $l{lstdot} = 1;
            $state = 'end';

          } elsif ($op eq '.include') {       # .include -------------
            $rt = get_token(\%l, TMASK_STRING);
            if ($$rt{tag} eq 'STR') {
              my $ifile = $$rt{val};
              my $rt = get_token(\%l, TMASK_STRING);
              if ($$rt{tag} eq 'EOL') {
                $l{ifile} = substr($ifile,1,-1) unless $l{err} ne '';
                $state = 'end';
              } else {
                $state = 'q';
              }
            } else {
              $state = 'q';
            }

          } elsif ($op eq '.if') {            # .if ------------------
            my $tst = 0;
            $rt = get_token(\%l, $tmask);     # get condition
            if ($$rt{tag} eq 'SYM') {         # if SYM found
              my $cond = $$rt{val};

              if ($cond =~ m/^(eq|ne|gt|le|lt|ge)$/) { # eq|ne|gt|le|lt|ge
                $rt = get_token(\%l, $tmask);     #  drop ',' delimiter
                pushback_token(\%l) unless check_token($rt, 'DEL', ',');
                $ifcond = $cond;
                $state = 'dl_beg';
                next STATE;

              } elsif ($cond =~ m/^(df|ndf)$/) {  # df|ndf -----------
                $rt = get_token(\%l, $tmask);     #  drop ',' delimiter
                pushback_token(\%l) unless check_token($rt, 'DEL', ',');
                my $op = '=';
                while (1) {
                  $rt = get_token(\%l, $tmask);     #  get symbol name
                  if ($$rt{tag} eq 'SYM') {
                    my $def = defined getsym(\%l, $$rt{val});
                    $tst  = $def if $op eq '=';
                    $tst &= $def if $op eq '&';
                    $tst |= $def if $op eq '|';
                  } else {
                    add_err(\%l, 'A');              # quit with A error
                    last;
                  }
                  $rt = get_token(\%l, $tmask);   # get & or ! operator
                  last if ($$rt{tag} eq 'EOL');   # quit if EOL
                  $op = undef;
                  $op = '&' if check_token($rt, 'OP', '&');
                  $op = '|' if check_token($rt, 'OP', '!');
                  if (not defined $op) {
                    add_err(\%l, 'A');            # quit with A error
                    last;
                  }
                }
                $tst = not $tst if $cond eq 'ndf';

              } elsif ($cond =~ m/^(b|nb)$/) {    # b|nb --------------
                $rt = get_token(\%l, $tmask);     #  drop ',' delimiter
                pushback_token(\%l) unless check_token($rt, 'DEL', ',');
                my $cnt = 0;
                while (1) {
                  $rt = get_token(\%l, $tmask);   # count all tokens
                  last if ($$rt{tag} eq 'EOL');   # quit if EOL
                  $cnt += 1;
                }
                $tst = ($cond eq 'b') ? $cnt == 0 : $cnt > 0;

              } elsif ($cond =~ m/^(idn|dif)$/) { # idn|dif ----------
                my $val1;
                my $val2;
                $rt = get_token(\%l, TMASK_MACROARG);  #  get 1st value
                $rt = get_token(\%l, TMASK_MACROARG) if $$rt{tag} eq 'DEL';
                if ($$rt{tag} eq 'SYM' || $$rt{tag} eq 'MVAL') {
                  $val1 = $$rt{val};
                  $rt = get_token(\%l, TMASK_MACROARG);  #  get 2nd value
                  $rt = get_token(\%l, TMASK_MACROARG) if $$rt{tag} eq 'DEL';
                  if ($$rt{tag} eq 'SYM' || $$rt{tag} eq 'MVAL') {
                    $val2 = $$rt{val};
                  }
                }
                if (defined $val1 && defined $val2) {
                  $tst = ($cond eq 'idn') ? ($val1 eq $val2) : ($val1 ne $val2);
                } else {
                  add_err(\%l, 'A');
                }

              } else {                      # bad condition -> A error
                add_err(\%l, 'A');
              }
            } else {                        # no conditiion -> A error
              add_err(\%l, 'A');
            }
            push @ifstk, {tst => $tst, cur => $tst};
            $state = 'end';

          } elsif ($op =~ m/^\.if(t|f|tf)$/) {  # .if(f|t|tf) ----------
            if (scalar(@ifstk) == 0) {          # .if block not active ?
              add_err(\%l, 'O');                  # quit with O error
              last STATE;
            }
            my $tst = $ifstk[-1]{tst};        # test value
            my $cur = $tst;                   # for .itf
            $cur = $tst ? 0 : 1 if $op eq '.iff';
            $cur = 1            if $op eq '.iftf';
            $ifstk[-1]{cur} = $cur;
            $state = 'end';

          } elsif ($op eq '.endc') {          # .endc ----------------
            if (scalar(@ifstk) == 0) {          # .if block not active ?
              add_err(\%l, 'O');                  # quit with O error
              last STATE;
            }
            pop @ifstk;
            $state = 'end';

          } elsif ($op eq '.macro') {         # .macro ---------------
            $rt = get_token(\%l, $tmask);
            if ($$rt{tag} eq 'SYM') {
              $l{flag} = 'M';
              $mdeflvl = 1;
              $mdefnam = $$rt{val};
              $mst{$mdefnam} = {name => $mdefnam,
                                args => [],
                                body => []
                               };
              while (1) {                   # loop over argument definitions
                $rt = get_token(\%l, TMASK_MACROARG);
                last if $$rt{tag} eq 'EOL';
                next if $$rt{tag} eq 'DEL'; # FIXME_code: is that OK ?

                my $mod;
                my $key;
                my $val;
                if ($$rt{tag} eq 'MMOD') {  # modifier seen ?
                  if ($$rt{val} eq '?') {   # modifier '?' ?
                    $mod = $$rt{val};
                    $rt = get_token(\%l, TMASK_MACROARG);
                    if ($$rt{tag} eq 'SYM') {   # ensure it's symbol
                      $key = $$rt{val};
                    } else {
                      add_err(\%l, 'AQ');   # no symbol after ? -> AQ error
                    }
                  } else {
                    add_err(\%l, 'AQ');     # other then ? modifier -> AQ error
                  }
                } elsif ($$rt{tag} eq 'SYM') {     # if symbol
                  $key = $$rt{val};
                } elsif ($$rt{tag} eq 'MKEY') {    # if key
                  $key = $$rt{val};
                  $rt = get_token(\%l, TMASK_MACROARG);
                  if ($$rt{tag} eq 'SYM' || $$rt{tag} eq 'MVAL') {
                    $val = $$rt{val};
                  } else {
                    add_err(\%l, 'Q');      # no value after key= -> Q error
                  }
                } else {
                 add_err(\%l, 'AQ');        # neither mod,sym,key -> AQ error
                }
                foreach my $rarg (@{$mst{$mdefnam}{args}}) {
                  if ($rarg->{key} eq $key) { # key already seen ?
                    add_err(\%l, 'A');        # key already defined -> A error
                    $key = undef;
                    last;
                  }
                }
                if (defined $key) {
                  push @{$mst{$mdefnam}{args}}, {key => $key,
                                                 val => $val,
                                                 mod => $mod
                                                };
                }
              }
            } else {
              add_err(\%l, 'O');            # no macro name -> O error
            }
            $state = 'end';

          } elsif ($op eq '.endm') {          # .endm ----------------
            if (not defined $mdefnam) {       # .macro not active ?
              add_err(\%l, 'O');                  # quit with O error
            } else {
              $l{flag} = "M";
              $rt = get_token(\%l, $tmask);
              if ($$rt{tag} eq 'SYM') {       # if non-matching name -> A error
                add_err(\%l, 'A') if $$rt{val} ne $mdefnam;
              }
            }
            $mdefnam = undef;
            $state = 'end';

          } elsif ($op eq '.mexit') {         # .mexit ---------------
            if (scalar(@mexecstk)+scalar(@reptstk) == 0) { # outside macro|rept?
              add_err(\%l, 'O');                # quit with O error
            } else {
              $mexit = 1;
            }
            $state = 'end';

          } elsif ($op eq '.mcall') {         # .mcall ---------------
            while(1) {
              $rt = get_token(\%l, $tmask);
              $rt = get_token(\%l, $tmask) if check_token($rt, 'DEL', ',');
              last if $$rt{tag} eq 'EOL';
              if ($$rt{tag} eq 'SYM') {       # name found
                push @{$l{mcall}}, $$rt{val};
              } else {
                add_err(\%l, 'A');            # signal A error
              }
            }
            $state = 'end';

          } elsif ($op eq '.mdelete') {       # .mdelete -------------
            while(1) {
              $rt = get_token(\%l, $tmask);
              $rt = get_token(\%l, $tmask) if check_token($rt, 'DEL', ',');
              last if $$rt{tag} eq 'EOL';
              if ($$rt{tag} eq 'SYM') {       # name found
                add_err(\%l, 'O') if delete_macro($$rt{val});
              } else {
                add_err(\%l, 'A');            # signal A error
              }
            }
            $state = 'end';

          } elsif ($op eq '.narg') {          # .narg ----------------
            $rt = get_token(\%l, $tmask);
            my $val = 0;
            if (scalar(@mexecstk) > 0) {      # inside macro?
              if ($$rt{tag} eq 'SYM') {       # name found ?
                $val = $mexecstk[-1]{narg};
                setsym(\%l, 'ass', $$rt{val}, $val);
                $l{typ}    = 'nxx';
                $l{asym}   = $$rt{val};
              } else {
                add_err(\%l, 'A');            # no symbol -> A error
              }
            } else {
              add_err(\%l, 'O');              # outside macro -> O error
            }
            $l{lstval} = $val;
            $state = 'end';

          } elsif ($op eq '.nchr') {          # .nchr ----------------
            $rt = get_token(\%l, $tmask);
            my $val = 0;
            if ($$rt{tag} eq 'SYM') {       # name found ?
              my $sym = $$rt{val};
              $rt = get_token(\%l, TMASK_MACROARG);
              $rt = get_token(\%l, TMASK_MACROARG) if $$rt{tag} eq 'DEL';
              if ($$rt{tag} eq 'SYM' || $$rt{tag} eq 'MVAL') {
                $val = length($$rt{val});
                setsym(\%l, 'ass', $sym, $val);
                $l{typ}    = 'nxx';
                $l{asym}   = $sym;
              } else {
                add_err(\%l, 'A');          # no value -> A error
              }
            } else {
              add_err(\%l, 'A');            # no symbol-> A error
            }
            $l{lstval} = $val;
            $state = 'end';

          } elsif ($op eq '.ntype') {         # .ntype ---------------
            $rt = get_token(\%l, $tmask);
            my $val = 0;
            if (scalar(@mexecstk) > 0) {      # inside macro ?
              if ($$rt{tag} eq 'SYM') {       # name found ?
                my $sym = $$rt{val};
                $rt = get_token(\%l, TMASK_MACROARG);
                $rt = get_token(\%l, TMASK_MACROARG) if $$rt{tag} eq 'DEL';
                if ($$rt{tag} eq 'SYM' || $$rt{tag} eq 'MVAL') {
                  my $aexp = $$rt{val};       # address expression
                  my $reg = 'pc';             # register name
                  my $mod = 0;                # address mode
                  # determine ntype with a bit of heuristics, avoid full parsing
                  if ($aexp =~ m/^@#.*$/) {                          # @#xxx
                    $mod = 3;
                  } elsif ($aexp =~ m/^#.*$/) {                       # #xxx
                    $mod = 2;
                  } elsif ($aexp =~ m/^(r[0-5]|sp|pc)$/) {            # rx
                    $mod = 0;
                    $reg = $1;
                  } elsif ($aexp =~ m/^\((r[0-5]|sp|pc)\)$/) {        # (rx)
                    $mod = 1;
                    $reg = $1;
                  } elsif ($aexp =~ m/^(@?)\((r[0-5]|sp|pc)\)\+$/) {   # @?(rx)+
                    $mod = ($1 eq '@') ? 3 : 2;
                    $reg = $2;
                  } elsif ($aexp =~ m/^(@?)-\((r[0-5]|sp|pc)\)$/) {   # @?-(rx)
                    $mod = ($1 eq '@') ? 5 : 4;
                    $reg = $2;
                  } elsif ($aexp =~ m/^(@?).+\((r[0-5]|sp|pc)\)$/) {  # @?nn(rx)
                    $mod = ($1 eq '@') ? 7 : 6;
                    $reg = $2;
                  } elsif ($aexp =~ m/^(@?).+$/) {                    # @?nn
                    $mod = ($1 eq '@') ? 7 : 6;
                  }
                  #
                  $val = 8*$mod + $pst{$reg}{val};
                  setsym(\%l, 'ass', $sym, $val);
                  $l{typ}    = 'nxx';
                  $l{asym}   = $sym;
                } else {
                  add_err(\%l, 'A');          # no value -> A error
                }
              } else {
                add_err(\%l, 'A');            # no symbol-> A error
              }
            } else {
              add_err(\%l, 'O');              # outside macro -> O error
            }
            $l{lstval} = $val;
            $state = 'end';

          } elsif ($op eq '.rept') {          # .rept ----------------
            $l{flag} = 'R';
            $state = 'dl_beg';

          } elsif ($op eq '.endr') {          # .endr ----------------
            if (scalar(@reptstk) == 0) {      # .rept block not active ?
              add_err(\%l, 'O');                  # quit with O error
            } else {
              $l{flag} = "R";
            }
            $state = 'end';

          } elsif ($op eq '.error') {         # .error ---------------
            add_err(\%l, 'P');                  # signal P error
            $state = 'dl_beg';

          } elsif ($op eq '.print') {         # .print ---------------
            $state = 'dl_beg';

          } elsif ($op eq '.list' ||          # .list ----------------
                   $op eq '.nlist') {         # .nlist ---------------
            while (1) {                       # loop over options
              $rt = get_token(\%l, $tmask);
              last if $$rt{tag} eq 'EOL';
              next if $$rt{tag} eq 'DEL';     # FIXME_code: check delimiter
              # FIXME_code: handle .list/.nlist
            }
            $state = 'end';
          } elsif ($op eq '.end') {           # .end -----------------
            $state = 'dl_beg';

          } else {
            die "BUGCHECK: op = '$op' in pst but no handler";
          }

        } elsif ($$rs{typ} eq 'op') {       # or opcodes ------------------
          walign(\%l);
          $l{typ}  = 'code';
          $op_code = $$rs{val};
          $op_fmt  = $$rs{fmt};
          $op_fpp  = $$rs{fpp};
          die "BUGCHECK: op_fmt = '$op_fmt' unknown in opfmt"
            unless defined $opfmt{$op_fmt};

          $l{opcode} = $op_code;
          $l{opfmt}  = $op_fmt;

          @op_ops  = @{$opfmt{$op_fmt}};

          if (scalar(@op_ops) == 0) {
            incdot(2);
            $state = 'end';
          } else {
            $op_rop = shift @op_ops;
            $state = 'op_beg';
          }

        }

      } elsif (exists $mst{$op}) {          # op in mst -> expand macro ---
        my %mexec = (name => $op,
                     keys => [],
                     vals => {}
                    );
        foreach my $marg (@{$mst{$op}{args}}) {
          push @{$mexec{keys}}, $marg->{key};
          $mexec{vals}{$marg->{key}} =
           defined $marg->{val} ? $marg->{val} : ''; # set defaults
        }
        my $iarg = 0;
        my $narg = 0;
        while (1) {
          $rt = get_token(\%l, TMASK_MACROARG);
          my $key;
          my $val;
          last if $$rt{tag} eq 'EOL';
          next if $$rt{tag} eq 'DEL';   # FIXME_code: is that OK ?
          if ($$rt{tag} eq 'MMOD') {    # modifier seen ?
            if ($$rt{val} eq '\\') {    # modifier '\' ?
              $rt = get_token(\%l, TMASK_MACROARG);
              if ($$rt{tag} eq 'SYM') {     # ensure it's symbol
                my $num = getsym(\%l, $$rt{val});
                if (defined $num) {
                  $val = sprintf "%o",$num;
                } else {
                  add_err(\%l, 'U');        # symbol undefined -> U error
                  $val = '0';
                }
              } else {
                add_err(\%l, 'Q');          # no symbol after \ -> Q error
              }
            } else {
              add_err(\%l, 'Q');            # other then \ modifier -> Q error
            }
          } elsif ($$rt{tag} eq 'SYM' || $$rt{tag} eq 'MVAL') {  # symbol,value
            $val = $$rt{val};
          } elsif ($$rt{tag} eq 'MKEY') {   # key=val
            $key = $$rt{val};
            $rt = get_token(\%l, TMASK_MACROARG);
            if ($$rt{tag} eq 'SYM' || $$rt{tag} eq 'MVAL') {
              $val = $$rt{val};
            } elsif ($$rt{tag} eq 'EOL' || $$rt{tag} eq 'DEL') { # empty key=
              pushback_token(\%l);
            } else {
              add_err(\%l, 'Q');            # bad value after key= -> Q error
            }
          } else {
            add_err(\%l, 'Q');              # neither mod,key,val -> Q error
          }
          if (defined $key && not exists $mexec{vals}{$key}) {
            add_err(\%l, 'AU');             # unknown key -> AU error
            $key = undef;
          }
          if (not defined $key) {
            if ($iarg < scalar(@{$mexec{keys}})) {
              $key = $mexec{keys}[$iarg];
              $iarg += 1;
              $narg += 1;
            } else {
              add_err(\%l, 'Q');            # too many arguments -> Q error
              $key = undef;
            }
          }
          if (defined $key) {
            $mexec{vals}{$key} = $val;
          }
        }
        # setup narg
        $mexec{narg} = $narg;
        # finally setup auto-generated labels
        foreach my $marg (@{$mst{$op}{args}}) {
          next unless defined $marg->{mod} && $marg->{mod} eq '?';
          my $key = $marg->{key};
          next if defined $mexec{vals}{$key} && $mexec{vals}{$key} ne '';
          $mexec{vals}{$key} = sprintf '%5d$', $mautolbl++;
        }
        $l{mexec} = \%mexec;
        $state = 'end';

      } else {                              # oper not in pst and mst -----
        pushback_token(\%l);                # --> implicit .word
        $state = 'iword';
      }

    } elsif ($state eq 'op_beg') {          # state: op_beg ------------------
      $op_ibeg = scalar(@{$l{tl}});
      $op_creg = undef;
      $op_cmod = undef;
      $op_cmod_def = undef;
      $op_crel = undef;
      $e_ibeg = undef;
      $e_iend = undef;
      if      ($$op_rop{typ} eq 'r') {      # operand: register
        $rt = get_token(\%l, $tmask);
        $op_creg = check_reg($rt);
        if (defined $op_creg) {
          if ($op_fpp && $op_creg > 3) {      # fpp ac must be r0:r3
            $op_creg &= 03;
            add_err(\%l, 'T');
          }
          $op_cmod = 0;
          $state = 'op_end';
        } else {
          $state = 'q';
        }
      } elsif ($$op_rop{typ} eq 'e') {      # operand: expression
        push @stack, 'op_end';
        $state = 'e_beg';
      } elsif ($$op_rop{typ} eq 'g') {      # operand: general
        push @stack, 'op_end';
        $state = 'g_beg';
      } else {
        die "BUGCHECK: unexpected op typ '$$op_rop{typ}'";
      }

    } elsif ($state eq 'op_end') {          # state: op_end ------------------
      my $op_iend = scalar(@{$l{tl}})-1;
      $l{tl}[$op_ibeg]->{om} = '<';
      $l{tl}[$op_iend]->{om} = ($l{tl}[$op_iend]->{om}) ? '<>' : '>';

      my $pref = $$op_rop{pref};
      if      ($$op_rop{typ} =~  m/^[gr]$/) {
        $l{$pref.'reg'} = $op_creg;
        $l{$pref.'mod'} = $op_cmod;
        $l{$pref.'rel'} = $op_crel;
        if (defined $e_ibeg) {
          $l{$pref.'ebeg'} = $e_ibeg;
          $l{$pref.'eend'} = $e_iend;
        }
      } elsif ($$op_rop{typ} eq  'e') {
        if (defined $e_ibeg) {
          $l{ebeg} = $e_ibeg;
          $l{eend} = $e_iend;
        }
      }

      if (scalar(@op_ops)) {                # second operand
        $rt = get_token(\%l, $tmask);
        if (check_token($rt, 'DEL', ',')) {
          $op_rop = shift @op_ops;
          $state = 'op_beg';
        } else {
          $state = 'q';
        }

      } else {                              # all operands seen
        # size is opcode and number index words, handle @(R) case without ebeg
        my $nword = 1;
        $nword += 1 if defined $l{o1ebeg} || (defined $l{o1mod} && $l{o1mod}==7);
        $nword += 1 if defined $l{o2ebeg} || (defined $l{o2mod} && $l{o2mod}==7);
        incdot(2*$nword);
        $state = 'end';
      }

    } elsif ($state eq 'g_beg') {           # state: g_beg -------------------
      $rt = get_token(\%l, $tmask);
      if      (defined check_reg($rt)) {           # R !
        $op_creg = check_reg($rt);
        $op_cmod = 0;
        $state = 'g_end';
      } elsif (check_token($rt, 'DEL', '(')) {     # (  R),R)+
        $state = 'g_inc1';
      } elsif (check_token($rt, 'OP',  '@')) {     # @  R,(R)+,-(R),E(R),#E,E
        $op_cmod_def = 1;
        $state = 'g_def1';
      } elsif (check_token($rt, 'OP',  '-')) {     # -  (R)
        $rt = get_token(\%l, $tmask);
        if (check_token($rt, 'DEL', '(')) {          # next (
          pushback_token(\%l);
          $state = 'g_dec1';                         # go for -(R)
        } else {
          pushback_token(\%l);
          pushback_token(\%l);
          push @stack, 'g_ind1';                     # otherwise -E..
          $state = 'e_beg';
        }
      } elsif (check_token($rt, 'OP',  '#')) {     # #  E
        push @stack, 'g_imm1';
        $state = 'e_beg';
      } else {
        pushback_token(\%l);
        push @stack, 'g_ind1';                     # E ! (R)
        $state = 'e_beg';
      }

    } elsif ($state eq 'g_inc1') {          # state: g_inc1 ------------------
      $rt = get_token(\%l, $tmask);
      $op_creg = check_reg($rt);
      if (defined $op_creg) {
        $rt = get_token(\%l, $tmask);
        if (check_token($rt, 'DEL', ')')) {
          $rt = get_token(\%l, $tmask);
          if (check_token($rt, 'OP', '+')) {
            $op_cmod = $op_cmod_def ? 3 : 2;       # (R)+ or @(R)+ seen
            $state = 'g_end';
          } else {
            if ($op_cmod_def) {
              pushback_token(\%l);                #  @(R) seen
              $op_cmod = 7;
              $state = 'g_end';
            } else {
              pushback_token(\%l);                #  (R) seen
              $op_cmod = 1;
              $state = 'g_end';
            }
          }
        } else {
          $state = 'q';
        }
      } else {
        $state = 'q';
      }

    } elsif ($state eq 'g_def1') {          # state: g_def1 ------------------
      $rt = get_token(\%l, $tmask);
      if (defined check_reg($rt)) {               # R
        $op_creg = check_reg($rt);
        $op_cmod = 1;
        $state = 'g_end';
      } elsif (check_token($rt, 'DEL', '(')) {    # ( -> R+
        $state = 'g_inc1';
      } elsif (check_token($rt, 'OP',  '-')) {    # - -> (R)
        $rt = get_token(\%l, $tmask);
        if (check_token($rt, 'DEL', '(')) {          # next (
          pushback_token(\%l);
          $state = 'g_dec1';                         # go for -(R)
        } else {
          pushback_token(\%l);
          pushback_token(\%l);
          push @stack, 'g_ind1';                     # otherwise -E..
          $state = 'e_beg';
        }
      } elsif (check_token($rt, 'OP',  '#')) {    # # -> #
        push @stack, 'g_imm1';
        $state = 'e_beg';
      } else {                                    # E -> !, (R)
        pushback_token(\%l);
        push @stack, 'g_ind1';
        $state = 'e_beg';
      }

    } elsif ($state eq 'g_ind1') {          # state: g_ind1 ------------------
      $rt = get_token(\%l, $tmask);
      if (check_token($rt, 'DEL', '(')) {
        $rt = get_token(\%l, $tmask);
        $op_creg = check_reg($rt);
        if (defined $op_creg) {
          $rt = get_token(\%l, $tmask);
          $op_cmod = $op_cmod_def ? 7 : 6;
          $state = check_token($rt, 'DEL', ')') ? 'g_end' : 'q';
        } else {
          $state = 'q';
        }
      } else {                              # here if PC relative
        pushback_token(\%l);
        $op_creg = 7;
        $op_cmod = $op_cmod_def ? 7 : 6;
        $op_crel = 1;
        $state = 'g_end';
      }

    } elsif ($state eq 'g_dec1') {          # state: g_dec1 ------------------
      $rt = get_token(\%l, $tmask);
      if (check_token($rt, 'DEL', '(')) {
        $rt = get_token(\%l, $tmask);
        $op_creg = check_reg($rt);
        if (defined $op_creg) {
          $rt = get_token(\%l, $tmask);
          $op_cmod = $op_cmod_def ? 5 : 4;
          $state = check_token($rt, 'DEL', ')') ? 'g_end' : 'q';
        } else {
          $state = 'q';
        }
      } else {
        $state = 'q';
      }

    } elsif ($state eq 'g_imm1') {          # state: g_imm1 ------------------
      $op_creg = 7;
      $op_cmod = $op_cmod_def ? 3 : 2;
      $state = 'g_end';

    } elsif ($state eq 'g_end') {           # state: g_end -------------------
        $state = pop @stack;

    } elsif ($state eq 'e_beg') {           # state: e_beg -------------------
      $e_ibeg = scalar(@{$l{tl}});
      @e_pbeg = ();
      $state = 'e_uop';

    } elsif ($state eq 'e_uop') {           # state: e_uop -------------------
      $rt = get_token(\%l, $tmask);
      if      ($$rt{tag} eq 'OP' && $$rt{typ}=~'u') { # OP(u)
        $$rt{typ}='u';
        $state = 'e_uop';
      } elsif ($$rt{tag} eq 'NUM' || $$rt{tag} eq 'SYM') {
        $state = 'e_bop';
      } elsif (check_token($rt, 'DEL', '<')) {
        push @e_pbeg, scalar(@{$l{tl}})-1;
        $state = 'e_uop';
      } else {
        $state = 'q';
      }

    } elsif ($state eq 'e_bop') {           # state: e_bop -------------------
      $rt = get_token(\%l, $tmask);
      if      ($$rt{tag} eq 'OP' && $$rt{typ}=~'b') { # OP(b)
        $$rt{typ}='b';
        $state = 'e_bop1';
      } elsif (check_token($rt, 'DEL', '>')) {
        if (scalar(@e_pbeg) == 0) {
          $state = 'q';
        } else {
          my $pbeg = pop @e_pbeg;
          $l{tl}[$pbeg]->{pend} = scalar(@{$l{tl}})-1;
          if ($tmask & TMASK_STRINGEXP) {
            $state = 'e_end';
          } else {
            $state = 'e_bop';
          }
        }
      } else {
        pushback_token(\%l);
        $state = 'e_end';
      }

    } elsif ($state eq 'e_bop1') {          # state: e_bop1 ------------------
      $rt = get_token(\%l, $tmask);
      if      ($$rt{tag} eq 'NUM' || $$rt{tag} eq 'SYM') {
        $state = 'e_bop';
      } elsif (check_token($rt, 'DEL', '<')) {
        push @e_pbeg, scalar(@{$l{tl}})-1;
        $state = 'e_uop';
      } else {
        $state = 'q';
      }

    } elsif ($state eq 'e_end') {           # state: e_end -------------------
      $e_iend = scalar(@{$l{tl}})-1;
      $l{tl}[$e_ibeg]->{em} = '<>';
      if ($e_iend != $e_ibeg) {
        $l{tl}[$e_ibeg]->{em} = '<';
        $l{tl}[$e_iend]->{em} = '>';
      }
      $state = (scalar(@e_pbeg)==0) ? pop @stack : 'q';

    } elsif ($state eq 'a_end') {           # state: a_end -------------------
      my $val = eval_exp(\%l, $e_ibeg, $e_iend);
      my $typ = ($a_typ =~ m/:/) ? 'pass' : 'ass';
      setsym(\%l, $typ, $a_sym, $val);
      $l{typ}   = 'ass';
      $l{atyp}  = $typ;
      $l{asym}  = $a_sym;
      $l{ebeg} = $e_ibeg;
      $l{eend} = $e_iend;
      $state = 'end';

    } elsif ($state eq 'dl_beg') {          # state: dl_beg ------------------
      $rt = get_token(\%l, $tmask);
      if      ($$rt{tag} eq 'EOL') {
        $state = 'dl_end';
      } elsif (check_token($rt, 'DEL', ',')) {
        pushback_token(\%l);
        $e_ibeg = undef;
        $e_iend = undef;
        $state = 'dl_next';
      } else {
        pushback_token(\%l);
        $e_ibeg = undef;
        $e_iend = undef;
        push @stack, 'dl_next';
        $state = 'e_beg';
      }

    } elsif ($state eq 'dl_next') {         # state: dl_next -----------------
      push @d_elist, {ibeg=>$e_ibeg, iend=>$e_iend};
      $rt = get_token(\%l, $tmask);
      if      ($$rt{tag} eq 'EOL') {
        $state = 'dl_end';
      } elsif (check_token($rt, 'DEL', ',')) {
        $rt = get_token(\%l, $tmask);
        if ($$rt{tag} eq 'EOL' || check_token($rt, 'DEL', ',')) {
          pushback_token(\%l);
          $e_ibeg = undef;
          $e_iend = undef;
          $state = 'dl_next';
        } else {
          pushback_token(\%l);
          $e_ibeg = undef;
          $e_iend = undef;
          push @stack, 'dl_next';
          $state = 'e_beg';
        }
      } else {
        $state = 'q';
      }

    } elsif ($state eq 'dl_end') {          # state: dl_end ------------------
      $state = 'end';
      if      ($d_dire eq '.word') {        # .word ------------------
        walign(\%l);
        if (scalar(@d_elist)) {
          $l{typ} = 'data';
          $l{delist} = \@d_elist;
          incdot(2*scalar(@d_elist));
        } else {
          $state = 'q';
        }

      } elsif ($d_dire eq '.byte') {        # .byte ------------------
        if (scalar(@d_elist)) {
          $l{typ} = 'data';
          $l{delist} = \@d_elist;
          incdot(1*scalar(@d_elist));
        } else {
          $state = 'q';
        }

      } elsif ($d_dire eq '.blkw' || $d_dire eq '.blkb') { # .blk[wb]
        $l{lstdot} = 1;
        walign(\%l) if $d_dire eq '.blkw';
        my $val;
        if (scalar(@d_elist) == 0) {
          $val = 1;
        } elsif (scalar(@d_elist) == 1) {
          $val = eval_exp(\%l, $d_elist[0]{ibeg}, $d_elist[0]{iend});
        } else {
          $state = 'q';
        }

        if (defined $val) {
          my $size = ($d_dire eq '.blkw') ? 2 : 1;
          incdot($size * $val);
          $l{typ}    = 'data';
          $l{incdot} = $size * $val;
        } else {
          add_err(\%l, 'A');
        }

      } elsif ($d_dire eq '.if') {          # .if --------------------
        my $tst = 0;
        if (scalar(@d_elist) == 1) {
          my $val = eval_exp(\%l, $d_elist[0]{ibeg}, $d_elist[0]{iend});
          if (defined $val) {
            $tst = 1 if $ifcond eq 'eq' && $val == 0;
            $tst = 1 if $ifcond eq 'ne' && $val != 0;
            $tst = 1 if $ifcond eq 'gt' && $val >  0;
            $tst = 1 if $ifcond eq 'le' && $val <= 0;
            $tst = 1 if $ifcond eq 'lt' && $val <  0;
            $tst = 1 if $ifcond eq 'ge' && $val >= 0;
          } else {
            add_err(\%l, 'U');
          }
        } else {
          add_err(\%l, 'A');
        }
        push @ifstk, {tst => $tst, cur => $tst};

      } elsif ($d_dire eq '.rept') {        # .rept ------------------
        my $cnt;
        if (scalar(@d_elist) == 1) {
          $cnt = eval_exp(\%l, $d_elist[0]{ibeg}, $d_elist[0]{iend});
        }
        unless (defined $cnt) {
          add_err(\%l, 'A');
          $cnt = 0;
        }
        $l{lstval} = $cnt;
        $reptlvl = 1;
        push @reptstk, {cnt  => $cnt,
                        body => []
                       };

      } elsif ($d_dire eq '.error' ||       # .error or --------------
               $d_dire eq '.print' ) {      # .print -----------------
        my $val;
        if (scalar(@d_elist) >= 1) {
          $val = eval_exp(\%l, $d_elist[0]{ibeg}, $d_elist[0]{iend});
          if (not defined $val) {
            $val = 0;
            add_err(\%l, 'U');
          }
        }
        add_err(\%l, 'Q') if scalar(@d_elist) > 1; # MACRO-11 gives Q !
        $l{lstdot} = 1;
        $l{lstval} = $val;

      } elsif ($d_dire eq '.end') {         # .end -------------------
        my $val;
        if (scalar(@d_elist) == 0) {
          $val = 1;
        } elsif (scalar(@d_elist) == 1) {
          $val = eval_exp(\%l, $d_elist[0]{ibeg}, $d_elist[0]{iend});
        } else {
          $state = 'q';
        }
        if (defined $val) {
          $l{lstval} = $val;                # set aval to get it in listing
        } else {
          $l{lstval} = 0;
          add_err(\%l, 'U');
        }
        if (scalar(@mexecstk) +             # if outside macro expansion
            scalar(@reptstk) +              #   or .rept expansion
            scalar(@ifstk) == 0) {          #   or conditional code
          $lst{'...end'} = {name => '...end', # generate marker label
                            val  => $val,
                            typ  => 'lbl',
                            psect=> '.abs'};
          $end = 1;                           # and end input processing
        } else {                            # if inside ...
          add_err(\%l, 'O');                #   quit with O error
        }

      } else {
        die "BUGCHECK: unexpected d_dire = '$d_dire'";
      }

    } elsif ($state eq 'al_next') {         # state: al_next -----------------
      $rt = get_token(\%l, $tmask);
      if      ($$rt{tag} eq 'STR') {
        push @d_elist, {str=>$$rt{val}};
      } elsif ($$rt{tag} eq 'EOL') {
        $state = 'al_end';
      } elsif (check_token($rt, 'DEL', '<')) {
        pushback_token(\%l);
        $tmask = TMASK_STRINGEXP;
        push @stack, 'al_exp';
        $e_ibeg = undef;
        $e_iend = undef;
        $state = 'e_beg';
      } else {
        $state = 'q';
      }

    } elsif ($state eq 'al_exp') {          # state: al_exp ------------------
      push @d_elist, {ibeg=>$e_ibeg, iend=>$e_iend};
      $tmask = TMASK_STRING;
      $state = 'al_next';

    } elsif ($state eq 'al_end') {          # state: al_end ------------------
      my $size = 0;
      foreach (@d_elist) {
        if (defined $$_{str}) {
          $size += length($$_{str}) - 2;
        } else {
          $size += 1;
        }
      }
      $size += 1 if $d_dire eq '.asciz';
      incdot($size);
      $l{typ} = 'data';
      $l{delist} = \@d_elist;
      $state = 'end';

    } elsif ($state eq 'iword') {           # state: iword -------------------
      $l{oper} = $d_dire = '.word';           # setup implicit .word directive
      $state = 'dl_beg';

    } elsif ($state eq 'end') {             # state: end ---------------------
      # unless EOL already seen fetch next token
      if (scalar(@{$l{tl}}) && $l{tl}[-1]{tag} eq 'EOL') {
        $rt = $l{tl}[-1];
      } else {
        $rt = get_token(\%l, $tmask);
      }
      # if at EOL fine, otherwise mark syntax error
      if ($$rt{tag} eq 'EOL') {
        last;
      } else {
        $state = 'q';
      }

    } elsif ($state eq 'q') {               # state: q -----------------------
      add_err(\%l, 'Q');                    # set Q error flag
      last;                                 # and quit this line

    } else {
      die "BUGCHECK: unexpected state '$state'\n";
    }
  }

  return \%l;
}

#-------------------------------------------------------------------------------

sub walign {
  my ($rl) = @_;
  my $dot = getdot();
  if ($dot & 0x1) {                         # odd address ?
    incdot(1);
    add_err($rl, 'B');
    $$rl{dot} = getdot() if ($pass == 2);   # fixup . in rl context in pass 2
  }
  return;
}

#-------------------------------------------------------------------------------

sub add_err {
  my ($rl,$errlist) = @_;
  foreach my $err (split '',$errlist) {
    next if index($$rl{err}, $err) >= 0;      # prevent multiple error tags
    $$rl{err} .= $err;                        # set error tag
    $errcnt{$err} += 1;                       # and count them
    $errcnt_tot += 1;
  }
  return;
}

#-------------------------------------------------------------------------------

sub prt_err {
  my ($rl) = @_;
  return join '', sort split '', $$rl{err};
}

#-------------------------------------------------------------------------------

sub setdot {
  my ($val) = @_;
  return unless defined $val;
  $lst{'.'}->{val} = $val;
  $psect{$cur_psect}{dot} = $val;
  $psect{$cur_psect}{dotmax} = $val if $psect{$cur_psect}{dotmax} < $val;
  ## printf "-- setdot %6.6o\n", $val if $opts{tparse};
  return;
}

#-------------------------------------------------------------------------------

sub incdot {
  my ($inc) = @_;
  return unless defined $inc;
  setdot(getdot() + $inc);
  return;
}

#-------------------------------------------------------------------------------

sub getdot {
  ## printf "-- getdot %6.6o\n", $lst{'.'}{val} if $opts{tparse};
  return $lst{'.'}{val};
}

#-------------------------------------------------------------------------------

sub setsym {
  my ($rl,$typ,$name,$val) = @_;
  ##print "+++set: pass=$pass; $llbl_scope : $name; typ=$typ\n";
  if ($name eq '.') {
    if ($typ eq 'ass') {
      setdot($val);
    } else {
      add_err($rl, 'A');
    }
    return;
  }

  if (check_llbl($name)) {
    if ($typ eq 'lbl') {
      $name = $llbl_scope . ':' . $name;
      $typ  = 'llbl';
    } else {
      die "BUGCHECK: name looks like local label, but typ=$typ";
    }
  }

  my $namelc = lc($name);

  if ($typ ne 'ass' && exists $lst{$namelc} &&
      $lst{$namelc}{typ} ne 'udef' && $pass==1) {
    # Note: 'M' etaging done in pass 2!
    $lst{$namelc}{mdef} = 1;
    return;
  }

  $lst{$namelc} = {name => $name,
                   val  => $val,
                   typ  => $typ,
                   psect=> $cur_psect};
  return;
}

#-------------------------------------------------------------------------------

sub getsym {
  my ($rl, $name, $noxref) = @_;
  ##print "+++get: pass=$pass; $llbl_scope : $name\n";
  $name = $llbl_scope . ':' . $name if check_llbl($name);
  my $namelc = lc($name);

  # if not yet defined, add it in lst with typ='udef'
  if (not exists $lst{$namelc}) {           # not yet in lst
    if (exists $pst{$namelc} &&               # but known as opcode
        $pst{$namelc}{typ} eq 'op') {
      return $pst{$namelc}{val};              # return that value
    } else {
      $lst{$namelc} = { name  => $name,
                        val   => undef,
                        typ   => 'udef',
                        psect => '<udef>'
                      };
      return undef;
    }
  }

  unless ($noxref) {
    if ($lst{$namelc}{mdef}) {
      add_err($rl, 'D');
    }
  }

  return $lst{$namelc}{val};
}

#-------------------------------------------------------------------------------

sub lst_checkmdef {
  my ($name) = @_;
  $name = $llbl_scope . ':' . $name if check_llbl($name);
  my $namelc = lc($name);
  return $lst{$namelc}{mdef};
}

#-------------------------------------------------------------------------------

sub eval_exp {
  my ($rl,$ibeg,$iend,$nest) = @_;
  my $rtl = $$rl{tl};
  my @uop;
  my $bop;
  my @val;

  return undef unless defined $ibeg && defined $iend;
  return undef unless defined $$rtl[$ibeg] || $nest; # FIXME_code: test em !!

  for (my $i=$ibeg; $i<=$iend; $i++) {
    my $rt = $$rtl[$i];
    my $do_uop = 0;
    if      ($$rt{tag} eq 'NUM') {
      push @val, $$rt{nval};

    } elsif ($$rt{tag} eq 'SYM') {
      push @val, getsym($rl, $$rt{val});

    } elsif ($$rt{tag} eq 'OP' && $$rt{typ} eq 'u') {
      push @uop, $$rt{val};

    } elsif ($$rt{tag} eq 'OP' && $$rt{typ} eq 'b') {
      $bop = $$rt{val};

    } elsif ($$rt{val} eq '<') {
      my $pend = $$rt{pend};
      die "BUGCHECK: pend not found for rtl[$i]" unless defined $pend;
      push @val, eval_exp($rl,$i+1,$pend-1,1);
      $i = $pend;

    } else {
      die "BUGCHECK: tag='$$rt{tag}', val='$$rt{val}'\n";
    }

    # if stack non-empty: return undef on undef, apply unary operators
    if (scalar(@val) > 0) {
      return undef unless defined $val[-1];
      my $o;
      while($o = pop @uop) {
        my $v = pop @val;
        if      ($o eq '+') {
        } elsif ($o eq '-') {
          $v = -$v;
        } elsif ($o eq '^c') {
          $v = ~$v;
        } else {
          die "BUGCHECK: tag='OP(u)', val='$o'\n";
        }
        push @val, (0177777 & $v);
      }
    }

    # if stack has 2 operands: apply binary operator
    if (scalar(@val) == 2) {
      die "BUGCHECK: bop not defined" unless defined $bop;
      my $v2 = pop @val;
      my $v1 = pop @val;
      return undef unless defined $v1 && defined $v2;
      if      ($bop eq '+') {               # '+': addition
        push @val, int($v1) + int($v2);
      } elsif ($bop eq '-') {               # '-': subtraction
        push @val, int($v1) - int($v2);
      } elsif ($bop eq '*') {               # '*': multiplication
        push @val, int($v1) * int($v2);
      } elsif ($bop eq '/') {               # '/': division
        push @val, int(int($v1) / int($v2));
      } elsif ($bop eq '&') {               # '&': bit-wise and
        push @val, int($v1) & int($v2);
      } elsif ($bop eq '!') {               # '!': bit-wise or
        push @val, int($v1) | int($v2);
      } else {
        die "BUGCHECK: tag='OP(b)', val='$bop'\n";
      }
      $bop = undef;
    }

  }
  return pop @val;
}

#-------------------------------------------------------------------------------
# returns true if symbol looks like a local label (1234$)

sub check_llbl {
  my ($name) = @_;
  return ($name =~ m/^\d+\$/) ? 1 : 0;
}

#-------------------------------------------------------------------------------
# returns register number if register symbol, or undef

sub check_reg {
  my ($rt) = @_;
  return undef unless $$rt{tag} eq 'SYM';
  my $pse = $pst{$$rt{val}};
  return undef unless defined $pse;
  return undef unless $$pse{typ} eq 'reg';
  return $$pse{val};
}

#-------------------------------------------------------------------------------
# returns true if token has specific tag/val

sub check_token {
  my ($rt, $tag, $val) = @_;
  return undef unless $$rt{tag} eq $tag;
  return $$rt{val} eq $val;
}

#-------------------------------------------------------------------------------

sub pushback_token {
  my ($rl) = @_;

  my $rt = pop @{$$rl{tl}};
  push @t_pushback, $rt;

  if ($opts{ttoken}) {
    printf "-- token-back:  tag=%-3s val='%s'\n",
      $$rt{tag}, savestr($$rt{val});
  }

  return;
}

#-------------------------------------------------------------------------------

sub get_token {
  my ($rl, $tmask) = @_;
  my $rt;

  if (scalar(@t_pushback)) {
    $rt = pop @t_pushback;
    if ($opts{ttoken}) {
      printf "-- token-reget: tag=%-3s val='%s'\n",
        $$rt{tag}, savestr($$rt{val});
    }

  } else {
    $rt = get_token1($rl, $tmask);
    if ($opts{ttoken}) {
      printf "-- token-get:   tag=%-3s val='%s'\n",
        $$rt{tag}, savestr($$rt{val});
    }
  }

  push @{$$rl{tl}}, $rt;

  return $rt;
}

#-------------------------------------------------------------------------------

sub finish_token {
  my $rt = shift @_;
  while (scalar(@_)) {
    my $tag = shift @_;
    my $val = shift @_;
    $$rt{$tag} = $val;
  }
  return $rt;
}

#-------------------------------------------------------------------------------

sub get_token1 {
  my ($rl, $tmask) = @_;
  my $rcl = $$rl{cl};

  my $val;
  my $ws = '';

  # drop any leading whitespace
  while (scalar(@$rcl)) {
    last if ($$rcl[0] !~ m/\s/);
    $ws .= shift @$rcl;
  }

  my %t = (mask => $tmask,
           ws   => $ws
          );

  # end of line ?
  unless (scalar(@$rcl)) {
    return finish_token(\%t, tag=>'EOL', val=>$val);
  }

  # get leading char
  my $c = $$rcl[0];

  # comment ? treated similar to end of line, comment saved in val
  if($c eq ';') {
    $val = join('',@$rcl);
    @$rcl = ();
    return finish_token(\%t, tag=>'EOL', val=>$val);
  }

  # here context dependent tokens
  if ($tmask & TMASK_STRING) {
    my $del = shift @$rcl;
    if ($del eq '<') {
      return finish_token(\%t, tag=> 'DEL', val=> $del);
    } else {
      my $str = $del;
      while (scalar(@$rcl)) {
        my $c = shift @$rcl;
        $str .= $c;
        return finish_token(\%t, tag=> 'STR', val=> $str) if $c eq $del;
      }
      add_err($rl, 'A');                    # indeed 'A' error, not 'Q' !!
      return finish_token(\%t, tag=> 'STR', val=> $str);
    }
  }

  if ($tmask & TMASK_MACROARG) {
    if ($c eq '?' || $c eq '\\') {          # ? or \ modifiers -------
      return finish_token(\%t, tag=> 'MMOD', val=> shift @$rcl);

    } elsif ($c eq '<') {                   # <...> ------------------
      shift @$rcl;
      my $val;
      my $c = '';
      while (scalar(@$rcl)) {
        $c = shift @$rcl;
        $val .= $c if $c ne '>';
        last if $c eq '>';
      }
      add_err($rl, 'A') unless $c eq '>';
      return finish_token(\%t, tag=> 'MVAL', val=> $val);

    } elsif ($c eq '^') {                   # ^/.../ -----------------
      shift @$rcl;
      my $val;
      my $del = shift @$rcl;
      unless (defined $del) {
        add_err($rl, 'A');
        return finish_token(\%t, tag=> 'MVAL', val=> '');
      }
      my $c = '';
      while (scalar(@$rcl)) {
        $c = shift @$rcl;
        $val .= $c if $c ne $del;
        last if $c eq $del;
      }
      add_err($rl, 'A') unless $c eq $del;
      return finish_token(\%t, tag=> 'MVAL', val=> $val);

    } elsif ($c eq ',') {                   # ',' --------------------
      return finish_token(\%t, tag=> 'DEL', val=> shift @$rcl);

    } else {
      my $val = shift @$rcl;
      while (scalar(@$rcl)) {
        my $c = $$rcl[0];
        last if ($c =~ m/(\s|,|;)/);        # delimiter seen ?
        if ($c eq '=') {                    # key=value seen ?
          if ($val =~ m/^[a-zA-Z\$\.][a-zA-Z0-9\$\.]*$/) { # key name ?
            shift @$rcl;                    # drop '='
            return finish_token(\%t, tag=> 'MKEY', val=> $val);
          }
        }
        $val .= shift @$rcl;
      }
      my $tag = ($val =~ m/^[a-zA-Z\$\.][a-zA-Z0-9\$\.]*$/) ? 'SYM' : 'MVAL';
      return finish_token(\%t, tag=> $tag, val=> $val);
    }
  }

  # looks like symbol ?
  if ($c =~ m/[a-zA-Z\$\.]/) {
    while (scalar(@$rcl)) {
      last if ($$rcl[0] !~ m/[a-zA-Z0-9\$\.]/);
      $val .= shift @$rcl;
    }
    return finish_token(\%t, tag=> 'SYM', val=> $val);
  }

  # looks like number or local label ?
  if ($c =~ m/[0-9]/) {
    while (scalar(@$rcl)) {
      last if ($$rcl[0] !~ m/[0-9]/);
      $val .= shift @$rcl;
    }
    # check for local label
    if (scalar(@$rcl) && $$rcl[0] eq '$') {
      # FIXME_code: reject labels with numbers >64k-1
      $val .= shift @$rcl;
      return finish_token(\%t, tag=> 'SYM', val=> $val);
    }
    # looks like numerical constant
    my $nval = undef;
    # if trailing '.' seen, add and handle as decimal, otherwise as octal
    if (scalar(@$rcl) && $$rcl[0] eq '.') {
      $nval =int($val);
      $val .= shift @$rcl;
      if ($nval > 65535) {
        add_err($rl, 'T');
        $nval &= 0177777;
      }
    } else {
      $nval = 0;
      foreach my $cc (split '',$val) {
        $nval = ($nval<<3) + int($cc);
        add_err($rl, 'N') unless $cc =~ m/[0-7]/;
        add_err($rl, 'T') unless $nval <= 0177777;
        $nval &= 0177777;
      }
    }
    return finish_token(\%t, tag=> 'NUM', val=> $val, nval=>$nval);
  }

  # looks like label delimiter (':' or '::') ?
  if ($c eq ':') {
    $val .= shift @$rcl;
    $val .= shift @$rcl if (scalar(@$rcl) && $$rcl[0] eq ':');
    return finish_token(\%t, tag=> 'LBL', val=> $val);
  }

  # looks assignment delimiter ('=','=:','==','==:') ?
  if ($c eq '=') {
    $val .= shift @$rcl;
    $val .= shift @$rcl if (scalar(@$rcl) && $$rcl[0] eq '=');
    $val .= shift @$rcl if (scalar(@$rcl) && $$rcl[0] eq ':');
    return finish_token(\%t, tag=> 'ASS', val=> $val);
  }

  # operators
  if ($c =~ m/^(\+|\-)$/ ) {                # unary/binary operators
    return finish_token(\%t, tag=> 'OP', typ=> 'ub', val=> shift @$rcl);
  }
  if ($c =~ m/^(\*|\/|\&|\!)$/ ) {          # binary operators
    return finish_token(\%t, tag=> 'OP', typ=> 'b',  val=> shift @$rcl);
  }
  if ($c =~ m/^(\#|\@)$/ ) {                # prefix operators
    return finish_token(\%t, tag=> 'OP', typ=> 'p',  val=> shift @$rcl);
  }

  # ' and " operator
  if ($c eq "'") {
    $val .= shift @$rcl;
    $c = shift @$rcl;
    if (not defined $c) {
      return finish_token(\%t, tag=> 'BAD', val=> $val);
    }
    $val .= $c;
    return finish_token(\%t, tag => 'NUM', val=> $val, nval=>ord($c));
  }

  if ($c eq '"') {
    $val .= shift @$rcl;
    my $c1 = shift @$rcl;
    my $c2 = shift @$rcl;
    if (! defined $c1 || ! defined $c2) {
      return finish_token(\%t, tag=> 'BAD', val=> $val);
    }
    $val .= $c1;
    $val .= $c2;
    return finish_token(\%t, tag => 'NUM', val=> $val,
                                           nval=>ord($c2)<<8|ord($c1));
  }

  # universal ^ operator
  if ($c eq '^') {
    $val .= shift @$rcl;
    $c = shift @$rcl;
    if (not defined $c) {
      return finish_token(\%t, tag=> 'BAD', val=> $val);
    }
    $val .= $c;
    $c = lc($c);
    if      ($c eq 'c') {
      return finish_token(\%t, tag=> 'OP', typ=> 'u',  val=> $val);

    } elsif ($c eq 'b') {
      my $nval = 0;
      while (scalar(@$rcl)) {
        last if ($$rcl[0] !~ m/[0-9]/);
        my $cc = shift @$rcl;
        $nval = ($nval<<1) + int($cc);
        add_err($rl, 'N') unless $cc =~ m/[0-1]/;
        add_err($rl, 'T') unless $nval <= 0177777;
        $nval &= 0177777;
        $val .= $cc;
      }
      return finish_token(\%t, tag=> 'NUM', val=> $val, nval=> $nval);

    } elsif ($c eq 'o') {
      my $nval = 0;
      while (scalar(@$rcl)) {
        last if ($$rcl[0] !~ m/[0-9]/);
        my $cc = shift @$rcl;
        $nval = ($nval<<3) + int($cc);
        add_err($rl, 'N') unless $cc =~ m/[0-7]/;
        add_err($rl, 'T') unless $nval <= 0177777;
        $nval &= 0177777;
        $val .= $cc;
      }
      return finish_token(\%t, tag=> 'NUM', val=> $val, nval=> $nval);

    } elsif ($c eq 'd') {
      my $nval = 0;
      while (scalar(@$rcl)) {
        last if ($$rcl[0] !~ m/[0-9]/);
        my $cc = shift @$rcl;
        $nval = 10*$nval + int($cc);
        add_err($rl, 'T') unless $nval <= 0177777;
        $nval &= 0177777;
        $val .= $cc;
      }
      return finish_token(\%t, tag=> 'NUM', val=> $val, nval=> $nval);

    } elsif ($c eq 'x') {
      my $nval = 0;
      while (scalar(@$rcl)) {
        last if ($$rcl[0] !~ m/[0-9a-fA-F]/);
        my $cc = shift @$rcl;
        $nval = ($nval<<4) + hex($cc);
        add_err($rl, 'T') unless $nval <= 0177777;
        $nval &= 0177777;
        $val .= $cc;
      }
      return finish_token(\%t, tag=> 'NUM', val=> $val, nval=> $nval);

    } elsif ($c eq 'r') {
      my $nval = 0;
      for (my $i=0; $i<3; $i++) {
        last unless defined $$rcl[0];
        last unless $$rcl[0] =~ m/^[0-9a-zA-Z\.\$\ ]$/;
        $nval = 050 * $nval + to_rad50($$rcl[0]);
        $val .= shift @$rcl;
      }
      return finish_token(\%t, tag=> 'NUM', val=> $val, nval=>$nval);

    } else {
      return finish_token(\%t, tag=> 'BAD', val=> $val);
    }
  }

  # delimiters
  if ($c =~ m|^[\(\)\,\<\>]$|) {
    return finish_token(\%t, tag=> 'DEL', val=> shift @$rcl);
  }

  # can't handle stuff
  $val = join('',@$rcl);
  @$rcl = ();
  return finish_token(\%t, tag=> 'BAD', val=> $val);
}

#-------------------------------------------------------------------------------

sub to_rad50 {
  my ($c) = @_;
  return undef unless defined $c;
  $c = lc($c);
  return 0 if $c eq ' ';
  return 001 + ord($c)-ord('a') if $c =~ m/^[a-z]$/;
  return 033 if $c eq '$';
  return 034 if $c eq '.';
  return 036 + ord($c)-ord('0') if $c =~ m/^[0-9]$/;
  return undef;
}

#-------------------------------------------------------------------------------

sub pass2 {

  my $fh = *STDERR;                         # for error line only print
  if ($lst_do) {
    if ($lst_fname eq "-") {
      $fh = *STDOUT;
    } else {
      $fh = new FileHandle;
      open($fh, ">", $lst_fname) or bailout("'$lst_fname' not writable: $!");
    }
  }

  pass2_lst_beg($fh) if $lst_do;

  foreach my $rl (@src) {

    $$rl{dot} = getdot();
    $llbl_scope = $$rl{lscope} if defined $$rl{lscope};

    # handle label definitions
    if (defined $$rl{label}) {
      if (lst_checkmdef($$rl{label})) {
        add_err($rl, 'M');
      } else {
        my $val = getsym($rl, $$rl{label}, 1);
        if (! defined $val || $val != getdot()) {
          add_err($rl, 'P');
        }
      }
    }

    # generate output data
    pass2_out($rl);
    # listing if requested or error detected in this line
    if ($lst_do) {
      pass2_lst_line($rl, $fh);
    } else {
      pass2_lst_line($rl, $fh) if $$rl{err} ne '';
    }
    # pass 2 dump requested
    dump_rl($rl) if $opts{tpass2};

  }

  pass2_lst_end($fh) if $lst_do;

  return;
}

#-------------------------------------------------------------------------------

sub pass2_out {
  my ($rl) = @_;

  # quit without code generation for 'questionable syntax' lines
  return if $$rl{err} =~ m/[IQ]/;

  # return if no pass2 action (typ not defined)
  return unless defined $$rl{typ};

  # generate code
  if      ($$rl{typ} eq 'code') {
    walign($rl);
    my $opcode = $$rl{opcode};
    my $opfmt  = $$rl{opfmt};

    # printf "+++1 $$rl{typ},$$rl{oper},%s,%s\n",
    #   savestr($opcode), savestr($opfmt);

    if      ($opfmt eq '-') {
      out_opcode($rl, $opcode);

    } elsif ($opfmt eq 'g') {
      out_opcode($rl, $opcode | $$rl{o1mod}<<3 | $$rl{o1reg});
      out_opdata($rl, $$rl{o1mod}, $$rl{o1reg}, $$rl{o1rel},
                      $$rl{o1ebeg}, $$rl{o1eend});

    } elsif ($opfmt eq 'gg') {
      out_opcode($rl, $opcode | $$rl{o1mod}<<9 | $$rl{o1reg}<<6 |
                                $$rl{o2mod}<<3 | $$rl{o2reg});
      out_opdata($rl, $$rl{o1mod}, $$rl{o1reg}, $$rl{o1rel},
                      $$rl{o1ebeg}, $$rl{o1eend});
      out_opdata($rl, $$rl{o2mod}, $$rl{o2reg}, $$rl{o2rel},
                      $$rl{o2ebeg}, $$rl{o2eend});
    } elsif ($opfmt eq 'r') {
      out_opcode($rl, $opcode | $$rl{o1reg});
    } elsif ($opfmt eq 'rg' || $opfmt eq 'gr') {
      out_opcode($rl, $opcode | $$rl{o1reg}<<6 |
                                $$rl{o2mod}<<3 | $$rl{o2reg});
      out_opdata($rl, $$rl{o2mod}, $$rl{o2reg}, $$rl{o2rel},
                      $$rl{o2ebeg}, $$rl{o2eend});
    } elsif ($opfmt eq 'n3') {
      out_opcode_n($rl, $opcode, 07, $$rl{ebeg}, $$rl{eend});
    } elsif ($opfmt eq 'n6') {
      out_opcode_n($rl, $opcode, 077, $$rl{ebeg}, $$rl{eend});
    } elsif ($opfmt eq 'n8') {
      out_opcode_n($rl, $opcode, 0377, $$rl{ebeg}, $$rl{eend});
    } elsif ($opfmt eq 's8') {
      out_opcode_o($rl, $opcode, 's8', $$rl{ebeg}, $$rl{eend});
    } elsif ($opfmt eq 'ru6') {
      out_opcode_o($rl, $opcode|($$rl{o1reg}<<6), 'u6',
                                 $$rl{ebeg}, $$rl{eend});
    } else {
      die "BUGCHECK: unknown opfmt '$opfmt'";
    }

    incdot($defincdot);                     # inc '.' after instruction done !
    $defincdot = 0;

  # generate data
  } elsif ($$rl{typ} eq 'data') {
    if ($$rl{oper} eq '.word' || $$rl{oper} eq '.byte' ) {
      walign($rl) if $$rl{oper} eq '.word';
      my $size = ($$rl{oper} eq '.word') ? 2 : 1;
      my $mask = ($size == 2) ? 0177777 : 0377;
      foreach (@{$$rl{delist}}) {
        my $ibeg = $$_{ibeg};
        my $iend = $$_{iend};
        my $val = 0;
        if (defined $ibeg) {
          $val = eval_exp($rl, $ibeg, $iend);
          if (not defined $val) {
            $val = 0;
            add_err($rl, 'U');
          }
        }
        # FIXME_code: handle T error here !!
        $val &= $mask;
        if ($$rl{oper} eq '.word') {
          out_w($rl, $val);
        } else {
          out_b($rl, $val);
        }
      }

    } elsif ($$rl{oper} eq '.blkw' || $$rl{oper} eq '.blkb' ) {
      walign($rl) if $$rl{oper} eq '.blkw';
      incdot($$rl{incdot});

    } elsif ($$rl{oper} eq '.ascii' || $$rl{oper} eq '.asciz' ) {
      foreach my $rd (@{$$rl{delist}}) {
        if (defined $$rd{str}) {
          my @chr = split '',$$rd{str};
          shift @chr;
          pop @chr;
          foreach (@chr) {
            push @{$$rl{outb}}, ord($_);
          }
        } else {
          my $val = eval_exp($rl, $$rd{ibeg}, $$rd{iend});
          if (not defined $val) {
            $val = 0;
            add_err($rl, 'U');
          }
          if ($val < 0 || $val > 0377) {
            $val &= 0377;
            add_err($rl, 'T');
          }
          push @{$$rl{outb}}, $val;
        }
      }
      push @{$$rl{outb}}, 0 if $$rl{oper} eq '.asciz';
      incdot(scalar(@{$$rl{outb}}));

    } elsif ($$rl{oper} eq '.even' || $$rl{oper} eq '.odd' ) {
      if ($$rl{incdot}) {
        push @{$$rl{outb}}, 0;
        incdot(1);
      }

    } else {
      die "BUGCHECK: unknown data oper '$$rl{oper}'";
    }

  # handle assignments
  } elsif ($$rl{typ} eq 'ass') {
    my $val = eval_exp($rl, $$rl{ebeg}, $$rl{eend});
    if (defined $val) {
      $$rl{lstval} = $val;
      setsym($rl, $$rl{atyp}, $$rl{asym}, $val);
    } else {
      $$rl{lstval} = 0;
      add_err($rl, 'U');
    }

  # handle .nxxx as pseudo-assignment
  } elsif ($$rl{typ} eq 'nxx') {
    setsym($rl, 'ass', $$rl{asym}, $$rl{lstval});

  } else {
    die "BUGCHECK: unknown line typ '$$rl{typ}'";
  }

  if      (scalar(@{$$rl{outw}})) {
    emitw($$rl{dot}, $$rl{outw});
  } elsif (scalar(@{$$rl{outb}})) {
    emitb($$rl{dot}, $$rl{outb});
  }

  return;
}

#-------------------------------------------------------------------------------

sub pass2_lst_beg {
  my ($fh) = @_;
  printf $fh "; Input file list:\n";
  my $fileno = 1;
  foreach my $fname (@flist) {
    $fname =~ s/^$ENV{RETROBASE}/\$RETROBASE/;
    printf $fh ";  %2d: %s\n", $fileno, $fname;
    $fileno += 1;
  }
  print $fh ";\n";
  return;
}

#-------------------------------------------------------------------------------

sub pass2_lst_end {
  my ($fh) = @_;
  if ($errcnt_tot) {
    print $fh ";\n";
    print $fh "; Error summary:\n";
    foreach my $err (sort keys %errcnt) {
      printf $fh ";  %s: %3d\n", $err, $errcnt{$err};
    }
  }
  return;
}

#-------------------------------------------------------------------------------
# line format is
# er fnF lnum    dot <upto 3w or 5b>      source
# .. ddF dddd oooooo oooooo oooooo oooooo <source>
# ..                 ooo ooo ooo ooo ooo  <source>
# the flag denotes: MR: macro/rept def, mr: macro/repr exec, d: .if drop

sub pass2_lst_line {
  my ($rl,$fh) = @_;

  my @ow = @{$$rl{outw}};
  my @ob = @{$$rl{outb}};
  my $str = '';
  $str .= sprintf("%-2s", prt_err($rl));
  $str .= sprintf(" %2d", $$rl{fileno});
  $str .= $$rl{flag};
  $str .= sprintf(" %4d", $$rl{lineno});

  # print dot if data is generated for this line, or label
  my $prtdot = defined $$rl{lstdot} ||
               scalar(@{$$rl{outw}}) ||
               scalar(@{$$rl{outb}}) ||
               $$rl{label};
  if ($prtdot) {
    $str .= prt76o($$rl{dot});
  } else {
    $str .= '       ';
  }

  if (defined $$rl{lstval}) {
    $str .= prt76o($$rl{lstval});
    $str .= ' ' x 14;
  } elsif (scalar(@ow)) {
    for (my $i=0; $i<3; $i++) { $str .= prt76o(shift @ow); }
  } elsif (scalar(@ob)) {
    for (my $i=0; $i<5; $i++) { $str .= prt43o(shift @ob); }
    $str .= ' ';
  } else {
    $str .= ' ' x 21;
  }

  my $line = $$rl{line};
  # if only error reporting is done strip the comments. Use that the last
  #   token is always type EOL and holds the comment in {val}. Therefore
  #   @{$$rl{tl}}[-1]->{val} is either undefined, or the comment string
  if (not $lst_do) {                        # only error reporting ?
    my $comm = @{$$rl{tl}}[-1]->{val};      # get comment (see above)
    if (defined $comm) {                    # if comment seem
      $line = substr($line,0,length($line)-length($comm));  # drop comment
      $line =~ s/\s*$//;                                    # drop traing blanks
    }
  }
  $str .= '  ' . $line;
  $str .= "\n";
  print $fh $str;
  if (1) {
    while (scalar(@ow)) {
      $str = '                 ';
      for (my $i=0; $i<3; $i++) { $str .= prt76o(shift @ow); }
      print $fh $str . "\n";
    }
    while (scalar(@ob)) {
      $str = '                 ';
      for (my $i=0; $i<5; $i++) { $str .= prt43o(shift @ob); }
      print $fh $str . "\n";
    }
  }
  return;
}

#-------------------------------------------------------------------------------

sub out_w {
  my ($rl,$word) = @_;
  push @{$$rl{outw}}, $word;
  incdot(2);
  return;
}

#-------------------------------------------------------------------------------

sub out_wop {
  my ($rl,$word) = @_;
  push @{$$rl{outw}}, $word;
  $defincdot += 2;
  return;
}

#-------------------------------------------------------------------------------

sub out_b {
  my ($rl,$byte) = @_;
  push @{$$rl{outb}}, $byte;
  incdot(1);
  return;
}

#-------------------------------------------------------------------------------

sub out_opcode {
  my ($rl,$code) = @_;
  out_wop($rl, $code);
  return;
}

#-------------------------------------------------------------------------------

sub out_opcode_n {
  my ($rl,$code,$mask,$ebeg,$eend) = @_;
  # FIXME_code: shouldn't we die here ?
  return unless defined $ebeg;

  my $val = eval_exp($rl,$ebeg,$eend);
  unless (defined $val) {
    $val = 0;
    add_err($rl, 'A');
  }
  if ($val & ~$mask) {
    $val &= $mask;
    add_err($rl, 'T');
  }
  out_wop($rl, $code|$val);
  return;
}

#-------------------------------------------------------------------------------

sub out_opcode_o {
  my ($rl,$code,$typ,$ebeg,$eend) = @_;
  # FIXME_code: shouldn't we die here ?
  return unless defined $ebeg;

  my $val = eval_exp($rl,$ebeg,$eend);
  my $off;
  if (defined $val) {
    $off = ($val - (getdot()+2)) / 2;
  } else {
    $off = -1;
    add_err($rl, 'U');
  }

  if ($typ eq 's8') {
    if ($off > 127 || $off < -128) {
      add_err($rl, 'A');
    }
    $off &= 0377;
  } else {
    $off = -$off;
    if ($off > 63 || $off < 0) {
      add_err($rl, 'A');
    }
    $off &= 0077;
  }
  out_wop($rl, $code|$off);
  return;
}

#-------------------------------------------------------------------------------

sub out_opdata {
  my ($rl,$mod,$reg,$rel,$ebeg,$eend) = @_;
  if (not defined $ebeg) {
    out_wop($rl, 0) if $mod == 7;         # emit 0 index for @(R) case
    return;
  }

  my $val = eval_exp($rl,$ebeg,$eend);
  unless (defined $val) {
    out_wop($rl, 0);
    add_err($rl, 'U');
    return;
  }
  if ($rel) {                             # handle pc relative offsets
    $val = ($val - (getdot()+$defincdot+2)) & 0177777;
  }
  out_wop($rl, $val);
  return;
}

#-------------------------------------------------------------------------------

sub emitw {
  my ($baddr,$rwl) = @_;
  if ($opts{temit}) {
    printf "-- emit: w %6.6o:", $baddr;
    foreach my $w (@$rwl) { printf " %6.6o", $w; }
    print "\n";
  }
  return unless scalar(@$rwl);

  if ((! defined $out_dot) || $out_dot!=$baddr || $out_data[-1]->{typ} ne 'w') {
    push @out_data, {typ=> 'w', addr=>$baddr, data=>[@$rwl]};
  } else {
    my $rdata = $out_data[-1]->{data};
    push @$rdata, @$rwl;
  }
  $out_dot = $baddr+2;
  return;
}

#-------------------------------------------------------------------------------

sub emitb {
  my ($baddr,$rbl) = @_;
  if ($opts{temit}) {
    printf "-- emit: b %6.6o:", $baddr;
    foreach my $b (@$rbl) { printf " %3.3o", $b; }
    print "\n";
  }
  return unless scalar(@$rbl);

  if ((! defined $out_dot) || $out_dot!=$baddr || $out_data[-1]->{typ} ne 'b') {
    push @out_data, {typ=> 'b', addr=>$baddr, data=>[@$rbl]};
  } else {
    my $rdata = $out_data[-1]->{data};
    push @$rdata, @$rbl;
  }
  $out_dot = $baddr+1;
  return;
}

#-------------------------------------------------------------------------------

sub write_lda_frame {
  my ($fh,$addr,$rblist) = @_;
  my $len = 6 + scalar(@$rblist);
  my @f;
  push @f, 0x01;
  push @f, 0x00;
  push @f, $len & 0xff;
  push @f, ($len>>8) & 0xff;
  push @f, $addr & 0xff;
  push @f, ($addr>>8) & 0xff;
  push @f, @$rblist if $len;
  my $csum = 0;
  foreach (@f) { $csum = ($csum + $_) & 0xff; }
  push @f, (-$csum) & 0xff;

  if ($opts{tout}) {
    my $nval = 0;
    printf "-- out: %6.6o:", $addr;
    foreach (@f) {
      if ($nval == 16) {
        printf "\n               ";
        $nval = 0;
      }
      printf " %3.3o", $_;
      $nval += 1;
    }
    printf "\n";
  }

  my $buf = pack("C*", @f);
  my $rc = syswrite($fh, $buf, length($buf));
  return;
}

#-------------------------------------------------------------------------------

sub write_lda {
  my ($fname) = @_;
  my $fh;
  if ($fname eq "-") {
    $fh = *STDOUT;
  } else {
    $fh = new FileHandle;
    open($fh, ">:raw", $fname) or bailout("'$fname' not writable: $!");
  }

  my @blist;
  my $base;
  my $dot;
  foreach my $rl (@src) {
    die "BUGCHECK: both outb and outw contain data"
      if scalar(@{$$rl{outb}}) && scalar(@{$$rl{outw}});

    my @byt = @{$$rl{outb}};
    foreach (@{$$rl{outw}}) {
      push @byt,  $_     & 0xff;
      push @byt, ($_>>8) & 0xff;
    }

    next unless scalar(@byt);

    # flush frame if new data not adjacent to old
    if (scalar(@blist) && $dot!=$$rl{dot}) {
      write_lda_frame($fh, $base, \@blist);
      @blist = ();
      $base = undef;
      $dot  = undef;
    }

    $dot = $base = $$rl{dot} unless defined $base;

    foreach (@byt) {
      if (scalar(@blist) >= 2*168) {
        write_lda_frame($fh, $base, \@blist);
        @blist = ();
        $base = $dot;
      }
      push @blist, $_ & 0xff;
      $dot += 1;
    }

  }

  # flush buffer
  write_lda_frame($fh, $base, \@blist) if scalar(@blist);
  @blist = ();

  # write terminating frame
  my $out_start = (exists $lst{'...end'}) ? $lst{'...end'}{val} : 1;
  write_lda_frame($fh, $out_start, \@blist);

  return;
}

#-------------------------------------------------------------------------------

sub write_cof_frame {
  my ($fh,$typ,$addr,$rlist) = @_;
  my $fmt = ($typ eq 'w') ? '%6.6o' : '%3.3o';
  my $max = ($typ eq 'w') ? 10 : 20 ;

  printf $fh "$typ %6.6o {\n", $addr;
  my $i = 0;
  foreach (@$rlist) {
    $i += 1;
    printf $fh "$fmt ", $_;
    print $fh "\n" if $i%$max == 0;
  }
  print $fh "\n" unless $i%$max == 0;
  print  $fh "}\n";
  return;
}

#-------------------------------------------------------------------------------

sub write_cof {
  my ($fname) = @_;
  my $fh;
  if ($fname eq "-") {
    $fh = *STDOUT;
  } else {
    $fh = new FileHandle;
    open($fh, ">:raw", $fname) or bailout("'$fname' not writable: $!");
  }

  print $fh "sym {\n";
  foreach my $key (sort keys %lst) {
    next unless $lst{$key}{typ} =~ m/^(lbl|llbl)$/;
    printf $fh "%s => %s\n", $lst{$key}{name}, save66o($lst{$key}{val});
  }
  print $fh "}\n";
  print $fh "dat {\n";

  my @list;
  my $typ;
  my $base;
  my $dot;

  foreach my $rl (@src) {

    if (scalar(@{$$rl{outb}})) {
      if (scalar(@list) && ($typ ne 'b' || $dot != $$rl{dot})) {
        write_cof_frame($fh, $typ, $base, \@list);
        @list = ();
      }
      unless (scalar(@list)) {
        $typ = 'b';
        $base = $dot = $$rl{dot};
      }
      push @list, @{$$rl{outb}};
      $dot += scalar(@{$$rl{outb}});
    }

    if (scalar(@{$$rl{outw}})) {
      if (scalar(@list) && ($typ ne 'w' || $dot != $$rl{dot})) {
        write_cof_frame($fh, $typ, $base, \@list);
        @list = ();
      }
      unless (scalar(@list)) {
        $typ = 'w';
        $base = $dot = $$rl{dot};
      }
      push @list, @{$$rl{outw}};
      $dot += 2 * scalar(@{$$rl{outw}});
    }
  }

  write_cof_frame($fh, $typ, $base, \@list)
    if scalar(@list);

  print $fh "}\n";

  return;
}

#-------------------------------------------------------------------------------

sub write_lsm {
  my ($fname) = @_;
  my $fh;
  if ($fname eq "-") {
    $fh = *STDOUT;
  } else {
    $fh = new FileHandle;
    open($fh, ">:raw", $fname) or bailout("'$fname' not writable: $!")
  }

  my %mem;

  foreach my $rl (@src) {

    my $dot = $$rl{dot};
    if (scalar(@{$$rl{outb}})) {
      foreach my $byte (@{$$rl{outb}}) {
        my $addr = sprintf "%6.6o", $dot & 0xfffe;
        $mem{$addr} = 0 unless exists $mem{$addr};
        if ($dot & 0x1) {                   # odd byte
          $mem{$addr} = (($byte&0xff)<<8) | ($mem{$addr} & 0xff);
        } else {                            # even byte
          $mem{$addr} = ($mem{$addr} & 0xff00) | ($byte&0xff);
        }
        $dot += 1;
      }
    }

    if (scalar(@{$$rl{outw}})) {
      foreach my $word (@{$$rl{outw}}) {
        my $addr = sprintf "%6.6o", $dot;
        $mem{$addr} = $word;
        $dot += 2;
      }
    }
  }

  foreach my $addr (sort keys %mem) {
    printf $fh "%s : %6.6o\n", $addr, $mem{$addr};
  }

  return;
}

#-------------------------------------------------------------------------------

sub dump_rl {
  my ($rl) = @_;

  printf "-- line:   '%s'\n", $$rl{line};
  printf "   err=%-3s, typ=%-4s, oper=%-6s, lineno=%3d, psect=%-6s, .=%6.6o\n",
    prt_err($rl), savestr($$rl{typ}), savestr($$rl{oper}), $$rl{lineno},
      $$rl{psect}, $$rl{dot};
  my $i = 0;
  foreach my $rt (@{$$rl{tl}}) {
    printf "   tl[%2d]: tag=%-4s, typ=%-2s, om=%-2s, em=%-2s, val='%s'",
      $i, $$rt{tag}, savestr1($$rt{typ}), savestr1($$rt{om}), savestr1($$rt{em}),
        savestr($$rt{val});
    printf ", nval=%6.6o",$$rt{nval} if defined $$rt{nval};
    printf ", pend=%d",$$rt{pend} if defined $$rt{pend};
    printf "\n";
    $i += 1;
  }
  if (defined $$rl{delist}) {
    $i = 0;
    my $rdl = $$rl{delist};
    foreach my $rd (@$rdl) {
      printf "   dl[%2d]:", $i;
      printf " str='%s'",$$rd{str} if defined $$rd{str};
      printf " ibeg=%s, iend=%s", savestr($$rd{ibeg}), savestr($$rd{iend})
        if exists $$rd{ibeg};
      printf "\n";
      $i += 1;
    }
  }
  if (defined $$rl{opcode}) {
    printf "   code  : %6.6o,fmt=%-2s", $$rl{opcode}, $$rl{opfmt};
    if (defined $$rl{o1mod}) {
      printf ", o1=%s%s", $$rl{o1mod},$$rl{o1reg};
      printf "r" if $$rl{o1rel};
      printf ",ei=%d:%d,val=%s", $$rl{o1ebeg}, $$rl{o1eend},
        save66o(eval_exp($rl, $$rl{o1ebeg}, $$rl{o1eend}))
          if defined $$rl{o1ebeg};
    }
    if (defined $$rl{o2mod}) {
      printf ", o2=%s%s", $$rl{o2mod},$$rl{o2reg};
      printf "r" if $$rl{o2rel};
      printf ",ei=%d:%d,val=%s", $$rl{o2ebeg}, $$rl{o2eend},
        save66o(eval_exp($rl, $$rl{o2ebeg}, $$rl{o2eend}))
          if defined $$rl{o2ebeg};
    }
    printf " ex=%d:%d,val=%s", $$rl{ebeg}, $$rl{eend},
      save66o(eval_exp($rl, $$rl{ebeg}, $$rl{eend}))
        if defined $$rl{ebeg};
    print "\n";
  }
  if (scalar(@{$$rl{outw}})) {
    print "   outw  :";
    foreach (@{$$rl{outw}}) { printf " %6.6o", $_; }
    print "\n";
  }
  if (scalar(@{$$rl{outb}})) {
    print "   outb  :";
    foreach (@{$$rl{outb}}) { printf " %3.3o", $_; }
    print "\n";
  }
  if (defined $$rl{cl}) {
    my $str = join '',@{$$rl{cl}};
    print "   cl    : $str\n" if length($str);
  }
  if (defined $$rl{mexec}) {
    printf "   mexec : %-6s : ", $$rl{mexec}{name};
    my $del = '';
    foreach my $key (@{$$rl{mexec}{keys}}) {
      printf '%s%s', $del,$key;
      printf '=%s', $$rl{mexec}{vals}{$key} if defined $$rl{mexec}{vals}{$key};
      $del = ',';
    }
    printf "\n";
  }
  foreach my $key (sort keys %{$rl}) {
    next if $key =~ m/^(line|err|typ|oper|lineno|psect|dot|opcode|opfmt|o[12](mod|reg|ebeg|eend)|ebeg|eend|tl|delist|outw|outb|cl|mexec)$/;
    printf "   %-6s: %s\n", $key, savestr($$rl{$key});
  }
  return;
}

#-------------------------------------------------------------------------------

sub dump_sym {
  print "\n";
  print " psect    dot dotmax\n";
  print "------ ------ ------\n";
  foreach my $ps (sort keys %psect) {
    printf "%-6s %6.6o %6.6o\n", $ps, $psect{$ps}{dot}, $psect{$ps}{dotmax};
  }

  print "\n";
  print "scope  symbol  typ  psect     val\n";
  print "------ ------ ---- ------  ------\n";
  foreach my $key (sort keys %lst) {
    my $sym = $lst{$key}{name};
    my $scope = '';
    my $name = $sym;
    if ($sym =~ m/^(.+):(.+)$/) {
      $scope = $1;
      $name  = $2;
    }
    printf "%-6s %-6s %-4s %-6s  %s\n", $scope, $name, $lst{$key}{typ},
      $lst{$key}{psect}, save66o($lst{$key}{val});
  }

  my @mlist = sort keys %mst;
  if (scalar @mlist) {
    print "\n";
    print "macro  body argument-list\n";
    print "------ ---- -------------\n";
    foreach my $mnam (@mlist) {
      printf '%-6s %4d ', $mnam, scalar(@{$mst{$mnam}{body}});
      my $del = '';
      foreach my $arg (@{$mst{$mnam}{args}}) {
        printf '%s', $del;
        printf '%s',$arg->{mod} if defined $arg->{mod};
        printf '%s',$arg->{key};
        printf '=%s',$arg->{val} if defined $arg->{val};
        $del = ',';
      }
      print "\n";
    }
  }

  return;
}

#-------------------------------------------------------------------------------

sub prt76o {
  my ($val) = @_;
  return '       ' unless defined $val;
  return sprintf " %6.6o", $val;
}

#-------------------------------------------------------------------------------

sub prt43o {
  my ($val) = @_;
  return '    ' unless defined $val;
  return sprintf " %3.3o", $val;
}

#-------------------------------------------------------------------------------

sub save66o {
  my ($val) = @_;
  return '<udef>' unless defined $val;
  return sprintf "%6.6o", $val;
}

#-------------------------------------------------------------------------------

sub savestr {
  my ($str) = @_;
  return '<udef>' unless defined $str;
  return $str;
}

#-------------------------------------------------------------------------------

sub savestr1 {
  my ($str) = @_;
  return '-' unless defined $str;
  return $str;
}

#-------------------------------------------------------------------------------

sub bailout {
  my ($msg) = @_;
  print STDERR "asm-11-F: $msg\n";
  exit 1;
}

#-------------------------------------------------------------------------------

sub print_help {
  print "usage: asm-11 [OPTIONS]... [FILE]...\n";
  print "  --I=path      adds path to the .include search path\n";
  print "  --L=path      adds path to the .library search path\n";
  print "  --E           write .include processed input to stdout\n";
  print "  --lst         create listing (default file name)\n";
  print "  --olst=fnam   create listing (concrete file name)\n";
  print "  --lda         create absolute loader output (default file name)\n";
  print "  --olda=fnam   create absolute loader output (concrete file name)\n";
  print "  --cof         create compound output (default file name)\n";
  print "  --ocof=fnam   create compound output (concrete file name)\n";
  print "  --lsm         create lsmem style memory dump (default file name)\n";
  print "  --olsm=fnam   create lsmem style memory dump (concrete file name)\n";
  print "  --tpass1      trace line context in pass 1\n";
  print "  --tpass2      trace line context in pass 2\n";
  print "  --dsym1       dump psect and ust tables after pass 1\n";
  print "  --dsym2       dump psect and ust tables after pass 2\n";
  print "  --ttoken      trace tokenizer\n";
  print "  --tparse      trace parser\n";
  print "  --temit       trace code emit\n";
  print "  --tout        trace output file write\n";
  print "  --help        print this text and exit\n";
  return;
}
