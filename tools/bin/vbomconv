#!/usr/bin/perl -w
# $Id: vbomconv 1202 2019-08-13 17:23:16Z mueller $
# SPDX-License-Identifier: GPL-3.0-or-later
# Copyright 2007-2019 by Walter F.J. Mueller <W.F.J.Mueller@gsi.de>
#
#  Revision History:
# Date         Rev Version  Comment
# 2019-08-13  1202   1.18.2  ghdl_m: use -Wl,--no-pie (for UB 18.04 gcc)
# 2019-07-13  1189   1.18.1  drop superfluous exists for $opts
# 2018-11-09  1066   1.18   add and use bailout; add @tcl
# 2016-08-28   804   1.17.3 xsim work dir now xsim.<mode>.<stem>
# 2016-07-02   782   1.17.2 add VBOMCONV_GHDL_OPTS and VBOMCONV_GHDL_GCOV
# 2016-06-24   778   1.17.1 -vsyn_prj: add [rep]sim models & VBOMCONV_XSIM_LANG
#                           -ghdl_(i|m|a): use --workdir
# 2016-06-19   777   1.17   -vsyn_prj: sim and syn source sets based on -UUT
#                           -vsim_prj: finally functioning tsim builds
# 2016-04-30   766   1.16.2 use -UUT property instead of @uut
# 2016-04-23   764   1.16.1 --vsim_prj: use 'nosort'
# 2016-04-22   763   1.16   --vsim_prj: use bash+pipefail, check exit status
# 2016-03-27   752   1.15   1st support for file properties (xdc -SCOPE_REF)
# 2016-02-20   734   1.14   add [ise,viv]; add preliminary --(vsyn|vsim)_export;
# 2016-02-14   731   1.13   add @uut tag handling;
# 2016-02-07   728   1.12   add vivado xsim support; protect for empty xdc set
# 2015-02-15   646   1.11   add vivado support: add -xlpath, use instead
#                           of XTWI_PATH; drop --ise_path; add @lib:unimacro;
#                           drop --viv_vhdl; add --vsyn_prj, --dep_vsyn;
#                           drop cygwin support;
# 2014-07-26   575   1.10.1 use XTWI_PATH now (ise/vivado switch done later)
# 2013-10-20   543   1.10   add --viv_vhdl
# 2012-02-05   456   1.9.4  redo filename substitution (= and :); add --get_top
# 2012-01-02   448   1.9.3  use in ghdl_m -fexplicit also when simprim used
# 2011-11-27   433   1.9.2  use in ghdl_m -fexplicit when unisim used
# 2011-08-13   405   1.9.1  always write 'vhdl' into xst prj files again; for
#                           -xst_export: remove opt file export, add ucf_cpp
#                           handling
# 2011-06-26   385   1.9    add --ise_path, pass it to vbomconv --xst_prj
# 2011-06-09   383   1.8.6  fix xst_vhdl.opt logic (use rtl/vlib now)
# 2010-07-03   312   1.8.5  add --flist action
# 2010-06-03   299   1.8.4  generate ucf->ncd dependencies in dep_xst
# 2010-04-26   284   1.8.3  add _[sft]sim support for ISim
# 2009-11-28   253   1.8.2  fixup print_help...;
# 2009-11-22   252   1.8.1  add (export|dep)_isim, full ISim support;
#                           add [isim] [sim], allow tag lists like [ghdl,isim];
#                           --trace and messages to STDERR;
# 2009-11-20   251   1.8    add isim_prj, first ISim support
# 2008-03-09   124   1.7.3  add in .dep_(ghdl|xst) all dep on vbom dependencies
#                           target now also dependant on .dep_ file
# 2008-03-02   122   1.7.2  add @lib:<name> directive to include UNISIM
# 2007-12-17   102   1.7.1  fix @ucf_cpp logic.
# 2007-12-16   101   1.7    add @ucf_cpp pseudo tag (handle cpp'ed ucf files)
# 2007-11-25    98   1.6.1  drop trailing blanks on input lines
# 2007-11-02    94   1.6    added (xst|ghdl)_export
# 2007-10-26    92   1.5.1  emit '--no-vital-checks' for --ghdl_m for _[sft]sim
# 2007-10-14    98   1.5    handle .exe files under cygwin properly
# 2007-09-15    82   1.4    handle C source objects properly
# 2007-08-10    72   1.3    add [xst], [ghdl] prefix support
# 2007-07-22    68   1.2    add "tag = val"; list files in 'ready to analyse'
#                           order; add --ghdl_a option
# 2007-07-08    65   1.1    add "tag : names"; inferral of _[ft]sim vboms
# 2007-07-06    64   1.0    Initial version

use 5.14.0;                                 # require Perl 5.14 or higher
use strict;                                 # require strict checking
use FileHandle;
use Cwd 'getcwd';

use Getopt::Long;

my %opts = ();

GetOptions(\%opts, "help", "trace", "xlpath=s",
	           "dep_ghdl",
                   "dep_xst",  "dep_isim",
                   "dep_vsyn", "dep_vsim",
                   "xst_prj",  "isim_prj",
                   "vsyn_prj", "vsim_prj",
	           "ghdl_a", "ghdl_a_cmd",
	           "ghdl_i", "ghdl_i_cmd",
	           "ghdl_m", "ghdl_m_cmd",
	           "ghdl_export=s",
	           "xst_export=s",
                   "isim_export=s",
                   "vsyn_export=s",
                   "vsim_export=s",
                   "get_top",
                   "flist")
  or bailout("bad command options");

my @vbom_queue;                             # list of pending vbom's
my @srcfile_list;                           # list of sources in compile order
my @xdcfile_list;                           # list of xdc files
my @tclfile_list;                           # list of xdc files
my @srcfile_list_vhd;                       # all vhdl sources
my @srcfile_list_v;                         # all (system) verilog sources
my @srcfile_list_c;                         # all C sources
my %vbom_files;                             # key=vbom; val=full file list
my %vbom_xdc;                               # key=vbom; val=xdc spec list
my %vbom_tcl;                               # key=vbom; val=tcl spec list
my %vbom_done;                              # key=vbom; val=done flags
my %vbom_rank;                              # key=vbom; val=vbom ranks
my %srcfile_rank;                           # key=source file; val=file rank
my %srcfile_synsim;                         # key=source file; val=syn or sim
my %srcfile_prop;                           # key=source file; hash of props
my %para_tbl;                               # substitution table
my @ucf_cpp_list;
my $is_ghdl = 0;                            # ghdl simulation target
my $is_xst  = 0;                            # XST synthesis target
my $is_isim = 0;                            # ISim simulation target
my $is_vsyn = 0;                            # vivado synthesis target
my $is_vsim = 0;                            # vivado simulation target
my $is_sim  = 0;                            # simulation target (generic)
my $is_ise  = 0;                            # ISE    target
my $is_viv  = 0;                            # vivado target
my $is_any  = 0;                            # ignore tags (for --flist)
my $is_bsim = 0;                            # is behavioural simulation
my $is_fsim = 0;                            # is functional simulation
my $is_tsim = 0;                            # is timing simulation
my $is_veri = 0;                            # is verilog model based
my $nactions = 0;                           # number of action commands
my $top_vbom;                               # top level vbom (from argv)
my $eff_vbom;                               # effective vbom ([fot]sim->ssim map)
my $stem;                                   # stem of $top_vbom
my $top;                                    # top level entity name
my $top_done = 0;                           # @top seen
my $uut;                                    # uut level name
my $has_unisim;                             # @lib:unisim seen or implied
my $has_unimacro;                           # @lib:unimacro seen
my $has_simprim;                            # @lib:simprim seen or implied
my $sim_mode = 'bsim';
my $do_trace = $opts{trace};
my $level = 0;                              # vbom nesting level
my $xst_writevhdl = 1;
my $xlpath=$opts{xlpath};
my $no_xlpath = ! defined $xlpath || $xlpath eq "";
my $ghdl_opts = $ENV{VBOMCONV_GHDL_OPTS};   # ghdl extra options
my $ghdl_gcov = $ENV{VBOMCONV_GHDL_GCOV};   # ghdl gcov enable
my $xsim_lang = $ENV{VBOMCONV_XSIM_LANG};   # xsim model language

if ($ghdl_gcov) {
  $ghdl_opts  = ''  unless defined $ghdl_opts;
  $ghdl_opts .= ' ' unless $ghdl_opts eq '';
  $ghdl_opts .= '-Wc,-ftest-coverage -Wc,-fprofile-arcs -Wl,-lgcov';
} else {
  $ghdl_opts  = '-O2 -g' unless defined $ghdl_opts;
}

$xsim_lang = 'verilog' unless defined $xsim_lang;
if ($xsim_lang ne 'verilog' && $xsim_lang ne 'vhdl') {
  print STDERR "vbomconv-E: VBOMCONV_XSIM_LANG is '$xsim_lang'\n";
  print STDERR "vbomconv-E: VBOMCONV_XSIM_LANG must be 'verilog' or 'vhdl'\n";
  exit 1;
}
$is_veri = $xsim_lang eq 'verilog';

autoflush STDOUT 1;		# autoflush, so nothing lost on exec later

if ($opts{help}) {
  print_help();
  exit 0;
}

# ensure that one and only one vbom is specified

if (scalar(@ARGV) != 1) {
  print STDERR "vbomconv-E: only one vbom file name allowed\n\n";
  print_help();
  exit 1;
}

# get number of CPUs (used later....)
my $nproc = `nproc`;
chomp $nproc;

# check that only one action is defined, mark xst, gdhl, or isim class

foreach (keys %opts) {
  $nactions += 1 unless ($_ eq "trace" || $_ eq "xlpath");
  $is_ghdl = 1   if $_ eq "dep_ghdl";
  $is_ghdl = 1   if $_ =~ /^ghdl_/;

  $is_xst  = 1   if $_ eq "dep_xst";
  $is_xst  = 1   if $_ =~ /^xst_/;

  $is_isim = 1   if $_ eq "dep_isim";
  $is_isim = 1   if $_ =~ /^isim_/;

  $is_vsyn = 1   if $_ eq "dep_vsyn";
  $is_vsyn = 1   if $_ =~ /^vsyn_/;

  $is_vsim = 1   if $_ eq "dep_vsim";
  $is_vsim = 1   if $_ =~ /^vsim_/;

  $is_any  = 1   if $_ eq "flist";
}

$is_sim = $is_ghdl | $is_isim | $is_vsim;
$is_ise = $is_xst  | $is_isim;
$is_viv = $is_vsyn | $is_vsim;

print STDERR "-- [ghdl] active\n" if $do_trace && $is_ghdl;
print STDERR "-- [xst] active\n"  if $do_trace && $is_xst;
print STDERR "-- [isim] active\n" if $do_trace && $is_isim;
print STDERR "-- [vsyn] active\n" if $do_trace && $is_vsyn;
print STDERR "-- [vsim] active\n" if $do_trace && $is_vsim;
print STDERR "-- [sim] active\n"  if $do_trace && $is_sim;
print STDERR "-- [ise] active\n"  if $do_trace && $is_ise;
print STDERR "-- [viv] active\n"  if $do_trace && $is_viv;

if ($nactions > 1) {
  print STDERR "vbomconv-E: only one action qualifier allowed\n\n";
  print_help();
  exit 1;
}

$top_vbom = $ARGV[0];

$top_vbom .= ".vbom" unless $top_vbom =~ m{\.vbom$};

$stem = $top_vbom;
$stem =~ s{\..*$}{};

$top = $stem;
$top =~ s{^.*/}{};

# now prepare virtual _[forept]sim vbom's
# they are inferred from the _ssim vbom's

if ($top_vbom =~ m{_([sforept]sim)\.vbom$}) {
  $sim_mode = $1;
}

$is_bsim = 1 if $sim_mode eq 'bsim';
$is_fsim = 1 if $sim_mode =~ m/^[fsor]sim$/;
$is_tsim = 1 if $sim_mode =~ m/^[ept]sim$/;

$eff_vbom = $top_vbom;
$eff_vbom =~ s{_[forept]sim\.vbom$}{_ssim.vbom}; # map [forept]sim -> ssim

# traverse all vbom's start with command line argument

push @vbom_queue, $eff_vbom;

while (@vbom_queue) {
  my $cur_vbom = shift @vbom_queue;
  read_vbom($cur_vbom);
}

# traverse internal vbom representation to build file table

$vbom_rank{$eff_vbom} = {min=>1, max=>1};
scan_vbom($eff_vbom);

# separate sym (uut) and sim (tb) parts
do_synsim($uut);

# sort file table, build file list (decreasing rank)
#   sort first by decreasing rank and second by filename
#   second sort only to get stable sequence, independent of hash keys

my @srcpair_list;
foreach (keys %srcfile_rank) {
  push @srcpair_list, [$srcfile_rank{$_}, $_];
}

@srcfile_list = map {$_->[1]}
                sort {$b->[0] <=> $a->[0] || $a->[1] cmp $b->[1]}
                @srcpair_list;

# setup vbom list by rank
my @vbom_rank_list;
foreach (sort keys %vbom_rank) {
  push @vbom_rank_list, [$vbom_rank{$_}{min}, $vbom_rank{$_}{max}, $_];
}
my @vbomfile_list_min = map {$_->[2]}
                        sort {$a->[0] <=> $b->[0] || $a->[1] cmp $b->[1]}
                        @vbom_rank_list;

# setup xdc files list (if one @xdc: seen)
foreach (@vbomfile_list_min) {
  push @xdcfile_list, @{$vbom_xdc{$_}} if exists $vbom_xdc{$_};
}

# setup tcl files list (if one @tcl: seen)
foreach (reverse @vbomfile_list_min) {
  push @tclfile_list, @{$vbom_tcl{$_}} if exists $vbom_tcl{$_};
}

# now split source list according to languages
foreach (@srcfile_list) {
  if (m/\.vhd$/) {
    push @srcfile_list_vhd, $_;
  } elsif (m/\.(v|sv)$/) {
    push @srcfile_list_v, $_;
  } elsif (m/\.c$/) {
    push @srcfile_list_c, $_;
#  } else {
#    print STDERR "unknown file type $_\n";
  }
}

# now generate output and actions, depending on options given

# --trace ------------------------------------------------------------

if ($do_trace) {
  print STDERR "\n";
  print STDERR "filename substitution table:\n";
  foreach (sort keys %para_tbl) {
    print STDERR "  $_ = $para_tbl{$_}\n";
  }

  print STDERR "\n";
  print STDERR "final vbom_rank table (sort by min rank):\n";
  print STDERR "  min  max  var  vbom-name:\n";
  foreach (sort {$a->[0] <=> $b->[0] || $a->[2] cmp $b->[2]} @vbom_rank_list) {
    printf STDERR "  %3d  %3d  %3d  %s\n",
      $_->[0], $_->[1], $_->[1]-$_->[0], $_->[2];
  }

  print STDERR "\n";
  print STDERR "final srcfile_rank table (sort by rank):\n";
  foreach (sort {$b->[0] <=> $a->[0] || $a->[1] cmp $b->[1]} @srcpair_list) {
    printf STDERR "  %5d %s %s\n", $_->[0], $srcfile_synsim{$_->[1]}, $_->[1];
  }

  print STDERR "\n";
  print STDERR "properties:\n";
  print STDERR "  \@top: $top\n";
  print STDERR "  \-UUT: $uut\n" if defined $uut;
}

# --ghdl_a -- ghdl analysis command ----------------------------------

if ($opts{ghdl_a} || $opts{ghdl_a_cmd}) {
  if ($no_xlpath && ($has_unisim || $has_unimacro || $has_simprim) ) {
    print STDERR "vbomconv-E: --xlpath required with ghdl_a or ghdl_a_cmd";
    exit 1;
  }
  my $workdir = "ghdl.${sim_mode}";

  foreach (@srcfile_list) {
    my $file = $_;
    my $cmd = "ghdl -a --workdir=${workdir}";
    $cmd .= " -P$xlpath/unisim"    if $has_unisim;
    $cmd .= " -P$xlpath/unimacro"  if $has_unimacro;
    $cmd .= " -P$xlpath/simprim"   if $has_simprim;
    $cmd .= " --ieee=synopsys";
    $cmd .= " ${ghdl_opts}";
    $cmd .= " $file";
    print "$cmd\n";
    if ($opts{ghdl_a}) {
      my $wrc = system "/bin/sh", "-c", $cmd;
      if ($wrc != 0) {
	my $rc = int($wrc/256);
	if ($rc == 0) {
	  my $sig = $wrc % 256;
	  print STDERR "vbomconv-I: compilation aborted by signal $sig\n";
	  exit(1);
	} else {
	  print STDERR "vbomconv-I: compilation failed (rc=$rc) $?\n";
	  exit($rc);
	}
      }
    }
  }
}

# --ghdl_i -- ghdl inspection command --------------------------------

if ($opts{ghdl_i} || $opts{ghdl_i_cmd}) {
  my $workdir = "ghdl.${sim_mode}";
  my %ghdl_work;

  system "mkdir ${workdir}" unless -d ${workdir};

  # read ghdl "work-obj93.cf" file. It has the format
  #   file . "<filename>" "<file_date>" "ghdl -i or -a date>":
  #     entity <entity> at nn( nn) + nn on nn;
  #     architecture <arch> of <entity> at nn( nn) + nn on nn;

  if (-r "${workdir}/work-obj93.cf") {
    open (WFILE, "${workdir}/work-obj93.cf") or
      bailout("can't open for ${workdir}/read work-obj93.cf: $!");
    while (<WFILE>) {
      if (m{^file \. \"(.*?)\"}) {
	$ghdl_work{$1} = 1;
      }
    }
    close (WFILE);
  }

  my $cmd = "ghdl -i --workdir=${workdir}";
  my $nfile = 0;

  foreach (@srcfile_list) {
    next if /\.c$/;			    # skip C sources, only vhd handled
    if (not exists $ghdl_work{$_}) {
      $cmd .= " \\\n  $_";
      $nfile += 1;
    }
  }

  if ($nfile) {
    print "$cmd\n";
    if ($opts{ghdl_i}) {
      exec "/bin/sh", "-c", $cmd or
        bailout("failed to exec /bin/sh -c $cmd: $!");
    }
  } else {
    print "# $cmd  ## all files already inspected\n";
  }
}

# --ghdl_m -- ghdl make command --------------------------------------
# Note: the 'buildin' make used by the -m option of ghdl does not
#       check for object files linked with -Wl, e.g. vhpi objects.
#       To force a re-elaboration the old executable is deleted first.
#       If used from make with proper dependencies, this will just do
#       the right thing.

if ($opts{ghdl_m} || $opts{ghdl_m_cmd} ) {
  my $workdir = "ghdl.${sim_mode}";
  my $cmd = "";

  if ($no_xlpath && ($has_unisim || $has_unimacro || $has_simprim) ) {
    print STDERR "vbomconv-E: --xlpath required with ghdl_m or ghdl_m_cmd";
    exit 1;
  }

  if  (-r $stem) {		# check for old executable
    $cmd .= "rm $stem\n" ; 	# rm to force elaboration
  }

  $cmd .= "ghdl -m --workdir=${workdir}";
  $cmd .= " -o $stem";
  $cmd .= '  -Wl,-no-pie';   # needed when gcc built with --enable-default-pie
                             # -fexplicit needed for ISE 13.1,13.3
  $cmd .= ' -fexplicit'          if $has_unisim or $has_unimacro or $has_simprim;
  $cmd .= " -P$xlpath/unisim"    if $has_unisim;
  $cmd .= " -P$xlpath/unimacro"  if $has_unimacro;
  $cmd .= " -P$xlpath/simprim"   if $has_simprim;
  $cmd .= " --ieee=synopsys";
  $cmd .= " ${ghdl_opts}";
  $cmd .= " --no-vital-checks"   if $sim_mode ne 'bsim';

  foreach (@srcfile_list) {
    next unless /\.c$/;		# C source ?
    my $ofile = $_;		# copy to break alias for following s///
    $ofile =~ s{^.*/}{};	# remove directory path
    $ofile =~ s/\.c$/.o/;	# add clause to link C source object file
    $cmd .= " -Wl,$ofile";
  }
  $cmd .= " $top";
  print "$cmd\n";
  if ($opts{ghdl_m}) {
    exec "/bin/sh", "-c", $cmd or
      bailout("failed to exec /bin/sh -c $cmd: $!");
  }
}

# --xst_prj ----------------------------------------------------------

if ($opts{xst_prj}) {
  ## $xst_writevhdl = 0; # needed in case "-use_new_parser yes" used
  foreach (@srcfile_list) {
    if ($xst_writevhdl) {
      print "vhdl work $_\n";
    } else {
      print "work $_\n";       # for ISE S-6/V-6 compilations with '-ifmt VHDL'
    }
  }
}

# --isim_prj ---------------------------------------------------------

if ($opts{isim_prj}) {
  foreach (@srcfile_list) {
    print "vhdl work $_\n";
  }
}

# --vsyn_prj ---------------------------------------------------------

if ($opts{vsyn_prj}) {
  # determine source and simulation file sets
  my @fl_syn;
  my @fl_sim;
  foreach my $fi (@srcfile_list) {
    if ($srcfile_synsim{$fi} eq 'syn') {
      push @fl_syn, $fi;
    } else {
      push @fl_sim, $fi;
    }
  }
  print "#\n";
  print "# setup sources for synthesis\n";
  print "#\n";
  print "set syn_files {\n";
  foreach (@fl_syn) {
    print "    $_\n";
  }
  print "}\n";
  print "\n";

  print "set obj [get_filesets sources_1]\n";
  print "add_files -norecurse -fileset \$obj \$syn_files\n";
  # defined top only when not doing test bench
  print "set_property \"top\" \"$top\" \$obj\n" unless defined $uut;

  if (defined $uut) {
    print "#\n";
    print "# setup sources for simulation\n";
    print "#\n";
    print "set sim_files {\n";
    foreach (@fl_sim) {
      print "    $_\n";
    }
    print "}\n";
    print "\n";

    print "set obj [get_filesets sim_1]\n";
    print "add_files -norecurse -fileset \$obj \$sim_files\n";
    print "set_property SOURCE_SET sources_1 \$obj\n";
  }

  # setup constraints
  print "#\n";
  print "# setup constraints\n";
  print "#\n";

  print "set xdc_files {\n";
  foreach (@xdcfile_list) {
    print "    $_\n";
  }
  print "}\n";
  print "\n";

  # add_files does not allow adding an empty set, so protect
  if (scalar @xdcfile_list) {
    print "set obj [get_filesets constrs_1]\n";
    print "add_files -norecurse -fileset \$obj \$xdc_files\n";
    print "\n";
    foreach my $fnam (@xdcfile_list) {
      if (exists $srcfile_prop{$fnam}->{-SCOPE_REF}) {
        my $target = $srcfile_prop{$fnam}->{-SCOPE_REF};
        $target = $srcfile_prop{$fnam}->{VBstem} if $target eq '';
        print "set_property SCOPED_TO_REF $target \\\n";
        print "   [get_files $fnam]\n";
      }
    }
  }
  print "\n";

  # setup additional tcl scripts
  if (scalar @tclfile_list) {
    print "#\n";
    print "# setup additional tcl scripts\n";
    print "#\n";

    print 'proc rvtb_source_extra_tcl {path name} {'      ."\n";
    print '  set basecd [pwd]'                            ."\n";
    print '  puts "# source @tcl:$path/$name"'            ."\n";
    print '  if [catch {cd $path'                         ."\n";
    print '             source -notrace $name} err] {'    ."\n";
    print '    puts "rvtb_source_extra_tcl-E: $err"'      ."\n";
    print '    puts "rvtb_source_extra_tcl-F: aborting"'  ."\n";
    print '    exit 1'                                    ."\n";
    print '  }'                                           ."\n";
    print '  cd $basecd'                                  ."\n";
    print '}'                                             ."\n";
    print "#\n";
    foreach (@tclfile_list) {
      my $path = '.';
      my $name = $_;
      if ($_ =~ m{^(.*)/(.*)$}) {
        $path = $1;
        $name = $2;
      }
      print "rvtb_source_extra_tcl $path $name\n";
    }
    print "#\n";
    print "\n";
  }

}

# --vsim_prj ---------------------------------------------------------

if ($opts{vsim_prj}) {
  # Note: use a separate workdir for each sim_mode and each model (given
  # by stem). This allows to have all co-existant, and to delete the workdir
  # each time one of them is re-build.
  my $workdir = "xsim.${sim_mode}.${stem}";
  my $fname_forwarder = "${stem}_XSim";
  $fname_forwarder =~ s/_([sorept]sim)_XSim/_XSim_$1/;

  print "#!/bin/bash\n";
  # pipefail ensures that in pipes like xvlog | tee ect the exits status is
  # from the last failed command, and not simply from last command (tee).
  # that ensures that the xvlog exit codes can be tested
  print "set -o pipefail\n";
  print "#\n";
  print "# generated by vbomconv -vsim_prj $top_vbom\n";
  print "#\n";

  print "# ---------- delete old forwarder\n";
  print "rm -f $fname_forwarder\n";
  print "#\n";

  print "# ---------- setup fresh working directory\n";
  print "rm -rf ${workdir}\n";
  print "mkdir ${workdir}\n";
  print "pushd ${workdir}\n";
  print "#\n";

  # compile verilog before vhdl !
  # currently verilog only used for DPI interface code or simulation models
  # xvhdl relies in strict compilation order, also across languages, and fails
  # when a not yet compiled module is instantiated via entiry work.xxx

  if (scalar @srcfile_list_v) {
    print "# ---------- xvlog step\n";
    my $tfile_xvlog_prj = "tmp_${stem}_xvlog.prj";
    print "cat > $tfile_xvlog_prj <<tmp_xvlog_end_token\n";
    print "#compile verilog source files\n";
    foreach (@srcfile_list_v) {
      my $type = (m/\.v$/) ? "verilog" : "sv     ";
      print "$type xil_defaultlib ../$_\n";
    }
    print "#do not sort compile order\n";
    print "nosort\n";
    print "tmp_xvlog_end_token\n";
    print "#\n";

    my $opts_xvlog = "-m64 --relax";
    print "xtwv xvlog $opts_xvlog -prj $tfile_xvlog_prj 2>&1 |\\\n";
    print "  tee xvlog_${stem}.log\n";
    print 'exitstatus=$?' . "\n";
    print "rm -f $tfile_xvlog_prj\n";
    print 'if (($exitstatus > 0)); then exit $exitstatus; fi' . "\n";
    print "#\n";
  }

  if (scalar @srcfile_list_vhd) {
    print "# ---------- xvhdl step\n";
    my $tfile_xvhdl_prj = "tmp_${stem}_xvhdl.prj";
    print "cat > $tfile_xvhdl_prj <<tmp_xvhdl_end_token\n";
    print "#compile vhdl source files\n";
    foreach (@srcfile_list_vhd) {
      print "vhdl xil_defaultlib ../$_\n";
    }
    print "#do not sort compile order\n";
    print "nosort\n";
    print "tmp_xvhdl_end_token\n";
    print "#\n";

    my $opts_xvhdl = "-m64 --relax";
    print "xtwv xvhdl $opts_xvhdl -prj $tfile_xvhdl_prj 2>&1 |\\\n";
    print "  tee xvhdl_${stem}.log\n";
    print 'exitstatus=$?' . "\n";
    print "rm -f $tfile_xvhdl_prj\n";
    print 'if (($exitstatus > 0)); then exit $exitstatus; fi' . "\n";
    print "#\n";
  }

  if (scalar @srcfile_list_c) {
    print "# ---------- xsc step\n";
    print "xtwv xsc";
    foreach (@srcfile_list_c) {
      print "  \\\n   ../$_";
    }
    print "\n";
    print 'exitstatus=$?' . "\n";
    print 'if (($exitstatus > 0)); then exit $exitstatus; fi' . "\n";
    print "#\n";
  }

  # Note: xelab -mt auto doesn't seem to work, use --mt `nproc`
  print "# ---------- xelab step\n";
  print "xtwv xelab --relax --debug typical --mt $nproc -m64 \\\n";
  print "  -L xil_defaultlib";
  print "  -L simprims_ver" if $is_tsim;
  print "  -L unisims_ver"  if $is_veri && ! ($is_bsim || $is_tsim);
  print " \\\n";
  if (scalar @srcfile_list_c) {
    print "  --sv_lib dpi \\\n";
  }
  if ($is_tsim) {
    print "  -transport_int_delays -pulse_r 0 -pulse_int_r 0 \\\n";
  }
  print "  --snapshot $stem \\\n";
  print "  -log xelab_${stem}.log \\\n";
  print "  xil_defaultlib.$top";
  print "  xil_defaultlib.glbl" if $is_tsim || ($is_veri && ! $is_bsim);
  print " \n";
  print 'exitstatus=$?' . "\n";
  print 'if (($exitstatus > 0)); then exit $exitstatus; fi' . "\n";
  print "#\n";

  my $cwd = getcwd();
  # use in forwarder full absolute path to relevant xsim.dir
  # this allows to call the tb from every directory

  print "# ---------- create forwarder\n";
  print "popd\n";
  print "if [ -x \"${workdir}/xsim.dir/${stem}/xsimk\" ]\n";
  print "then\n";
  print "#\n";
  print "cat > $fname_forwarder <<forwarder_end_token\n";
  print "#!/bin/sh\n";
  print "rm -rf xsim.dir\n";
  print "ln -s ${cwd}/${workdir}/xsim.dir  xsim.dir\n";
  # Note: double escape \"\\\$\@\" needed to ensure file contains "$@"
  print "exec xtwv xsim ${stem} \"\\\$\@\"\n";
  print "forwarder_end_token\n";
  print "#\n";
  print "chmod +x $fname_forwarder\n";
  print "fi\n";
}

# --dep_ghdl ---------------------------------------------------------

if ($opts{dep_ghdl}) {

  print "#\n";
  print "$stem : $stem.dep_ghdl\n";

  if ($sim_mode eq 'ssim') {
    foreach my $type (qw(f o r t)) {
      my $stem_ghdl = $stem;
      $stem_ghdl =~ s/_ssim$/_${type}sim/;
      print "$stem_ghdl : $stem.dep_ghdl\n";
    }
    print "#\n";
  }

  foreach (@srcfile_list) {
    if (/\.c$/) {
      my $ofile = $_;		# copy to break alias for following s///
      $ofile =~ s{^.*/}{};	# remove directory path
      $ofile =~ s/\.c$/.o/;	# object file name
      print "$stem : $ofile\n"; # depend on C source object file
				# C source object compilation dependence
      open (ODEPFILE, ">$ofile.dep_ghdl") or
	bailout("can't write $ofile.dep_ghdl: $!");
      print ODEPFILE "$ofile : $_\n";
      print ODEPFILE "\t\$(COMPILE.c) \$(OUTPUT_OPTION) \$<\n";
      close ODEPFILE;
    } else {
      print "$stem : $_\n";
    }
  }

  # Notes:  _fsim only for ISE useful
  #         _tsim only for VIV useful
  if ($sim_mode eq 'ssim') {
    foreach my $type (qw(f o r t)) {
      my $stem_ghdl = $stem;
      $stem_ghdl =~ s/_ssim$/_${type}sim/;

      print "#\n";
      foreach (@srcfile_list) {
        my $file = $_;		# copy to break alias for following s///
        if (/\.c$/) {
          $file =~ s{^.*/}{};	# remove directory path
          $file =~ s/\.c$/.o/;    # depend on object file for C sources
        } else {
          $file =~ s/_ssim\.vhd$/_${type}sim.vhd/;
        }
        print "$stem_ghdl : $file\n";
      }
    }

  }

  write_vbomdep("$stem.dep_ghdl");

}

# --dep_xst ----------------------------------------------------------

if ($opts{dep_xst}) {
  print "#\n";
  print "$stem.ngc : $stem.dep_xst\n";
  print "#\n";
  foreach (@srcfile_list) {
    print "$stem.ngc : $_\n";
  }
  # handle cpp preprocessed ucf's
  foreach (@ucf_cpp_list) {
    my $file = $_;
    $file =~ s/\.ucf$//;
    print "#\n";
    print "$file.ncd : $file.ucf\n";
    print "include $file.dep_ucf_cpp\n";
  }
  # handle plain ucf's
  if (scalar(@ucf_cpp_list)==0 && -r "$stem.ucf") {
    print "#\n";
    print "$stem.ncd : $stem.ucf\n";
  }
  write_vbomdep("$stem.dep_xst");
}

# --dep_isim ---------------------------------------------------------

if ($opts{dep_isim}) {
  my $stem_isim = $stem . "_ISim";

  $stem_isim =~ s/_ssim_ISim$/_ISim_ssim/ if ($sim_mode eq 'ssim');

  my $stem_fsim_isim = $stem_isim;
  my $stem_tsim_isim = $stem_isim;
  $stem_fsim_isim =~ s/_ssim$/_fsim/;
  $stem_tsim_isim =~ s/_ssim$/_tsim/;

  print "#\n";
  print "$stem_isim : $stem.dep_isim\n";
  if ($sim_mode eq 'ssim') {
    print "$stem_fsim_isim : $stem.dep_isim\n";
    print "$stem_tsim_isim : $stem.dep_isim\n";
  }
  print "#\n";

  foreach (@srcfile_list) {
    print "$stem_isim : $_\n";
  }

  if ($sim_mode eq 'ssim') {

    print "#\n";
    foreach (@srcfile_list) {
      my $file = $_;		# copy to break alias for following s///
      $file =~ s/_ssim\.vhd$/_fsim.vhd/;
      print "$stem_fsim_isim : $file\n";
    }

    print "#\n";
    foreach (@srcfile_list) {
      my $file = $_;		# copy to break alias for following s///
      $file =~ s/_ssim\.vhd$/_tsim.vhd/;
      print "$stem_tsim_isim : $file\n";
    }

  }

  write_vbomdep("$stem.dep_isim");
}

# --dep_vsyn ---------------------------------------------------------

if ($opts{dep_vsyn}) {
  print "#\n";
  print "$stem.bit : $stem.dep_vsyn\n";
  print "#\n";
  my @files;
  push @files, @srcfile_list;
  push @files, @xdcfile_list;
  push @files, @tclfile_list;
  foreach (@files) {
    print "$stem.bit : $_\n";
  }
  print "#\n";
  foreach (@files) {
    print "${stem}_syn.dcp : $_\n";
  }
  print "#\n";
  foreach (@files) {
    print "${stem}_rou.dcp : $_\n";
  }
  write_vbomdep("$stem.dep_vsyn");
}

# --dep_vsim ---------------------------------------------------------

if ($opts{dep_vsim}) {
  my $stem_vsim = $stem . "_XSim";

  $stem_vsim =~ s/_ssim_XSim$/_XSim_ssim/ if ($sim_mode eq 'ssim');

  print "#\n";
  print "$stem_vsim : $stem.dep_vsim\n";

  if ($sim_mode eq 'ssim') {
    foreach my $type (qw(o r e p t)) {
      my $stem_xsim = $stem_vsim;
      $stem_xsim =~ s/_ssim$/_${type}sim/;
      print "$stem_xsim : $stem.dep_vsim\n";
    }
  }
  print "#\n";

  foreach (@srcfile_list) {
    print "$stem_vsim : $_\n";
  }

  if ($sim_mode eq 'ssim') {

    # Note: when --dep_vsim is used for a _ssim.vbom read_vbom will remap
    #   _ssim.vhd to _ssim.v depending on $xsim_lang. [ept]sim always uses
    #   verilog, that's why there is a explict mapping below.

    foreach my $type (qw(o r e p t)) {
      my $stem_xsim = $stem_vsim;
      $stem_xsim =~ s/_ssim$/_${type}sim/;

      print "#\n";
      foreach (@srcfile_list) {
        my $file = $_;		# copy to break alias for following s///
        $file =~ s/_ssim\.(v|vhd)$/_${type}sim.$1/;
        $file =~ s/_([ept])sim\.vhd$/_${1}sim.v/; # see Note above
        print "$stem_xsim : $file\n";
      }
    }
  }

  write_vbomdep("$stem.dep_vsim");
}

# --ghdl_export or xst_export or isim_export -------------------------

if (exists $opts{ghdl_export}  or
    exists $opts{xst_export} or
    exists $opts{isim_export}) {
  my $edir;
  $edir = $opts{ghdl_export} if exists $opts{ghdl_export};
  $edir = $opts{xst_export}  if exists $opts{xst_export};
  $edir = $opts{isim_export} if exists $opts{isim_export};

  if (not -d $edir) {
    print STDERR "vbomconv-I: create target directory $edir\n";
    system("mkdir -p $edir") == 0 or bailout("mkdir failed: $!");
  } else {
    print STDERR "vbomconv-I: target directory $edir already exists\n";
  }

  open(PFILE, ">$edir/$stem.prj") or
    bailout("can't write open $edir/$stem.prj: $!");

  foreach (@srcfile_list) {
    my $fname  = $_;
    my $fdpath = ".";
    if (m{(.*)/(.*)}) {
      $fname  = $2;
      $fdpath = $1;
    }
    copy_edir($_, $edir);
    print PFILE "vhdl work $fname\n";
  }

  close(PFILE);

  # Note: currently no xflow opt files exported !!
  if (exists $opts{xst_export}) {
    open(XFILE, ">$edir/$stem.xcf") or
      bailout("can't write open $edir/$stem.xcf: $!");
    close(XFILE);

    foreach (glob("*.xcf")) { copy_edir($_, $edir); }

    if (-r "$stem.ucf_cpp") {
      system "/bin/sh", "-c", "make $stem.ucf";
    }

    foreach (glob("*.ucf")) { copy_edir($_, $edir); }
  }

}

# --vsyn_export or vsim_export ---------------------------------------

if (exists $opts{vsyn_export}  or
    exists $opts{vsim_export}) {
  my $edir;
  $edir = $opts{vsyn_export} if exists $opts{vsyn_export};
  $edir = $opts{vsim_export} if exists $opts{vsim_export};

  if (not -d $edir) {
    print STDERR "vbomconv-I: create target directory $edir\n";
    system("mkdir -p $edir") == 0 or bailout("mkdir failed: $!");
  } else {
    print STDERR "vbomconv-I: target directory $edir already exists\n";
  }

  my @filist;
  push @filist, @srcfile_list;
  push @filist, @xdcfile_list;
  push @filist, @tclfile_list;
  my @fl_syn;
  my @fl_sim;
  my @fl_xdc;

  foreach my $fi (@filist) {
    my $fname  = $fi;
    my $fdpath = ".";
    if ($fi =~ m{(.*)/(.*)}) {
      $fname  = $2;
      $fdpath = $1;
    }

    copy_edir($fi, $edir);

    if ($fname =~ m{\.(vhd|v|sv)$}) {        # .vhd or .v or .sv
      if ($srcfile_synsim{$fi} eq 'syn') {
        push @fl_syn, $fname;
      } else {
        push @fl_sim, $fname;
      }
    } elsif ($fname =~ m{\.c}) {             # .c
      push @fl_sim, $fname;
    } elsif ($fname =~ m{\.xdc}) {           # .xdc
      push @fl_xdc, $fname;
    } else {
    print STDERR "vbomconv-W: file $fname not processed (unknown type)\n";
    }
  }

  open(TFILE, ">$edir/$stem.tcl") or
    bailout("can't write open $edir/$stem.tcl: $!");

  print TFILE "#\n";
  print TFILE "# setup file lists\n";
  print TFILE "#\n";

  print TFILE "set syn_files {\n";
  foreach (@fl_syn) {
    print TFILE "  $_\n";
  }
  print TFILE "}\n";
  print TFILE "\n";

  print TFILE "set sim_files {\n";
  foreach (@fl_sim) {
    print TFILE "  $_\n";
  }
  print TFILE "}\n";
  print TFILE "\n";

  print TFILE "set xdc_files {\n";
  foreach (@fl_xdc) {
    print TFILE "  $_\n";
  }
  print TFILE "}\n";
  print TFILE "\n";

  print  TFILE 'set obj [get_filesets sources_1]' . "\n";
  print  TFILE 'add_files -norecurse -fileset $obj $syn_files' . "\n";
  printf TFILE 'set_property "top" "%s" $obj' . "\n", $top;
  print  TFILE "\n";

  if (scalar @fl_sim) {
    print  TFILE 'set obj [get_filesets sim_1]' . "\n";
    print  TFILE 'add_files -norecurse -fileset $obj $sim_files' . "\n";
    print  TFILE "\n";
  }

  if (scalar @fl_xdc) {
    print  TFILE 'set obj [get_filesets constrs_1]' . "\n";
    print  TFILE 'add_files -norecurse -fileset $obj $xdc_files' . "\n";
    print  TFILE "\n";
  }

  close(TFILE);

}

# --get_top ----------------------------------------------------------

if ($opts{get_top}) {
  print "$top\n";
}

# --flist ------------------------------------------------------------

if ($opts{flist}) {

  my @flist;

  push @flist, @srcfile_list;
  push @flist, sort keys %vbom_done;

  if (scalar(@ucf_cpp_list)) {
    foreach (@ucf_cpp_list) {
      push @flist, $_."_cpp";
    }
  } else {
    if (-r "$stem.ucf") {
      push @flist, "$stem.ucf";
    }
  }

  push @flist, @xdcfile_list;
  push @flist, @tclfile_list;

  foreach (sort @flist) {
    my $fname  = $_;
    my $fdpath = ".";
    if (m{(.*)/(.*)}) {
      $fname  = $2;
      $fdpath = $1;
    }
    print "$fdpath/$fname\n";
  }

}

#-------------------------------------------------------------------------------

sub read_vbom {
  my ($vbom) = @_;

  print STDERR "-- open $vbom\n" if $do_trace;

  open (IFILE, $vbom) or bailout("can't open for read $vbom: $!");

  my $vbom_path = "";
  my $vbom_file = $vbom;
  if ($vbom =~ m{^(.*)/([a-zA-Z0-9_.]*)$}) {
    $vbom_path = $1;
    $vbom_file = $2;
  }

  $vbom_done{$vbom} += 1;		    # mark this vbom already read

  while (<IFILE>) {
    chomp;
    next if /^\s*#/;			    # drop comments
    next if /^\s*$/;			    # drop empty lines

    s/\s*$//;			            # drop trailing blanks

    # process parameter definitions
    if (m{([\w]+)\s*=\s*(.*)}) {
      my $para = $1;
      my $val  = $2;
      if ($val eq "") {
        print STDERR "vbomconv-E: invalid \'$_\' in $vbom_file\n";
        exit 1;
      }
      if (not exists $para_tbl{$para}) {
        $para_tbl{$para} = canon_fname($vbom_path, $val);
        print STDERR "--- define \${$para} = $val\n" if $do_trace;
      } else {
        print STDERR "--- ignore \${$para} = $val\n" if $do_trace;
      }
      next;
    }

    # process parameter substitutions
    while (m{\$\{([\w]+)\s*(:=)?\s*(.*?)\}}) {
      my $para = $1;
      my $del  = $2;
      my $val  = $3;
      my $pre  = $`;
      my $post = $';
      if (defined $del && $del eq ":=") {
        if (not exists $para_tbl{$para}) {
          $para_tbl{$para} = canon_fname($vbom_path, $val);
          print STDERR "--- define \${$para := $val}\n" if $do_trace;
        } else {
          print STDERR "--- ignore \${$para := $val}\n" if $do_trace;
        }
      }
      if (defined $para_tbl{$para}) {
        if ($do_trace) {
          print STDERR "--- use    \${$para} -> $para_tbl{$para}\n";
        } else {
          ## print STDERR "vbomconv-I: \${$para} -> $para_tbl{$para}\n";
        }
        $_ = $pre . "!" . $para_tbl{$para} . $post;
      } else {
        print STDERR "vbomconv-E: undefined \${$para} in $vbom_file\n";
        exit 1;
      }
    }

    if (/^\[([a-z,]+)\]\s*(.+)$/) {         # [xxx,yyy] tag seen
      my $qual = $1;
      my $name = $2;
      my $keep = $is_any;
      ## print STDERR "+++1 |$qual|$name|$vbom|\n";
      foreach my $pref (split /,/,$qual) {
        if ($pref =~ /^(ghdl|xst|isim|vsyn|vsim|sim|ise|viv)$/) {
          $keep = 1 if ($pref eq "ghdl" && $is_ghdl);
          $keep = 1 if ($pref eq "xst"  && $is_xst);
          $keep = 1 if ($pref eq "isim" && $is_isim);
          $keep = 1 if ($pref eq "vsyn" && $is_vsyn);
          $keep = 1 if ($pref eq "vsim" && $is_vsim);
          $keep = 1 if ($pref eq "sim"  && $is_sim);
          $keep = 1 if ($pref eq "ise"  && $is_ise);
          $keep = 1 if ($pref eq "viv"  && $is_viv);
        } else {
          print STDERR "vbomconv-W: unknown tag [$pref] in $vbom_file\n";
        }
      }
      if (not $keep) {
        print STDERR "--- drop \"$_\"\n" if $do_trace;
        next;
      }
      $_ = $name;                           # remove [xxx] tag
    }

    my $tag;
    my $val = $_;

    # detect tag:val lines
    if (m{^\s*(.*?)\s*:\s*(.*?)\s*$}) {
      $tag = $1;
      $val = $2;

      # process @top:<entity> lines
      if ($tag eq '@top') {
        $top = $val unless $top_done;
        next;

      # process @ucf_cpp:<file> lines
      } elsif ($tag eq '@ucf_cpp') {
        push @ucf_cpp_list, $val;
        next;

      # process @xdc:<file> lines
      } elsif ($tag eq '@xdc') {
        my ($fname,$rphash) = parse_props($val);
        $fname = canon_fname($vbom_path, $fname);
        setup_props($fname, $rphash);
        push @{$vbom_xdc{$vbom}}, $fname;
        next;

      # process @tcl:<file> lines
      } elsif ($tag eq '@tcl') {
        my $fname = canon_fname($vbom_path, $val);
        push @{$vbom_tcl{$vbom}}, $fname;
        next;

      # process @lib:<name> lines
      } elsif ($tag eq '@lib') {
        if ($val eq 'unisim') {
          $has_unisim = 1;
        } elsif ($val eq 'unimacro') {
          $has_unimacro = 1;
        } elsif ($val eq 'simprim') {
          $has_simprim = 1;
        } else {
          print STDERR "vbomconv-E: invalid lib type \'$tag\' in $vbom_file\n";
          exit 1;
        }
        next;

      # catch invalid @ tags
      } else {
        print STDERR "vbomconv-E: invalid \'$tag:\' line in $vbom_file\n";
        exit 1;
      }

    }

    # split in filename and property list
    my ($fname,$rphash) = parse_props($val);

    # now do model source file mapping
    my $fname_old = $fname;
    if ($is_ise || $is_ghdl) {
      $fname =~ s{_ssim\.vhd$}{_fsim.vhd} if $sim_mode eq 'fsim';
      $fname =~ s{_ssim\.vhd$}{_osim.vhd} if $sim_mode eq 'osim';
      $fname =~ s{_ssim\.vhd$}{_rsim.vhd} if $sim_mode eq 'rsim';
      $fname =~ s{_ssim\.vhd$}{_tsim.vhd} if $sim_mode eq 'tsim';
    }
    if ($is_viv) {
      $fname =~ s{_ssim\.vhd$}{_esim.v}   if $sim_mode eq 'esim';
      $fname =~ s{_ssim\.vhd$}{_psim.v}   if $sim_mode eq 'psim';
      $fname =~ s{_ssim\.vhd$}{_tsim.v}   if $sim_mode eq 'tsim';
      if ($is_veri) {
        $fname =~ s{_ssim\.vhd$}{_ssim.v}   if $sim_mode eq 'ssim';
        $fname =~ s{_ssim\.vhd$}{_osim.v}   if $sim_mode eq 'osim';
        $fname =~ s{_ssim\.vhd$}{_rsim.v}   if $sim_mode eq 'rsim';
      } else {
        $fname =~ s{_ssim\.vhd$}{_osim.vhd} if $sim_mode eq 'osim';
        $fname =~ s{_ssim\.vhd$}{_rsim.vhd} if $sim_mode eq 'rsim';
      }
    }
    print STDERR "--- map    $fname_old -> $fname\n"
      if $do_trace && $fname_old ne $fname;

    # process normal .vhd, .v, or .vbom file lines
    # canonize file name unless not already done by filename substitution
    my $fullname;
    if ($fname =~ m{^!(.*)$}) {
      $fullname = $1;
    } else {
      $fullname = canon_fname($vbom_path, $fname);
    }

    # handle properties
    setup_props($fullname, $rphash);

    # process -UUT property here, with canonized file names
    if (exists $rphash->{-UUT}) {
      if (defined $uut) {
        print STDERR "vbomconv-E: duplicate -UUT:, 1st '$uut' 2nd '$val'\n";
        exit 1;
      }
      $uut = $fullname;
    }

    # determine whether additional libs needed
    if ($fullname =~ m{_[sor]sim\.vhd$}) {  # is ssim, osim or rsim
      $has_unisim = 1;
    }
    if ($fullname =~ m{_[ft]sim\.vhd$}) {   # is fsim or tsim
      $has_simprim = 1;
    }

    # build vbom table
    push @{$vbom_files{$vbom}}, $fullname;
    print STDERR "--- add    $fullname\n" if $do_trace;

    # if a vbom, queue if not not already read
    if ($fullname =~ m{\.vbom$} && not exists $vbom_done{$fullname} ) {
       push @vbom_queue, $fullname;
       print STDERR "--- queue  $fullname\n" if $do_trace;
    }

  }

  $top_done = 1;

  close (IFILE);
}

#-------------------------------------------------------------------------------

sub scan_vbom {
  my ($vbom) = @_;

  $level += 1;
  my $rank = 1000*$level + scalar(@{$vbom_files{$vbom}});
  print STDERR "--> $level: $vbom\n" if $do_trace;

  bailout("excessive vbom stack depth") if $level>=1000;

  if (exists $vbom_rank{$vbom}) {
    $vbom_rank{$vbom}{min} = $level if $level < $vbom_rank{$vbom}{min};
    $vbom_rank{$vbom}{max} = $level if $level > $vbom_rank{$vbom}{max};
  } else {
    $vbom_rank{$vbom} = {min=>$level, max=>$level};
  }

  foreach my $file (@{$vbom_files{$vbom}}) {
    $rank -= 1;
    if ($file =~ m{\.vbom$}) {
      scan_vbom($file);
    } else {
      if (exists $srcfile_rank{$file}) {
	if ($rank > $srcfile_rank{$file}) {
	  print STDERR "   $file   $srcfile_rank{$file} -> $rank\n" if $do_trace;
	  $srcfile_rank{$file} = $rank;
	} else {
	  print STDERR "   $file   $srcfile_rank{$file} (keep)\n" if $do_trace;
	}
      } else {
	 $srcfile_rank{$file} = $rank;
	 print STDERR "   $file   $srcfile_rank{$file} (new)\n" if $do_trace;
      }
    }
  }

  print STDERR "<-- $level: $vbom\n" if $do_trace;
  $level -= 1;

}

#-------------------------------------------------------------------------------

sub do_synsim {
  my ($uut) = @_;

  # all is syn if no @uut defined; preset with sim when @uut defined
  my $def = (defined $uut) ? 'sim' : 'syn';
  foreach my $file (keys %srcfile_rank) {
    $srcfile_synsim{$file} = $def;
  }
  return unless defined $uut;

  # if @uut seen separate them
  if (defined $uut) {
    if ($uut =~ m{\.vbom}) {            # uut is vbom (behavioral sim)
      scan_synsim($uut);
    } else {                            # uut is file (post syn sim)
      $srcfile_synsim{$uut} = 'syn';
    }
  }
}

#-------------------------------------------------------------------------------

sub scan_synsim {
  my ($vbom) = @_;

  foreach my $file (@{$vbom_files{$vbom}}) {
    if ($file =~ m{\.vbom$}) {
      scan_synsim($file);
    } else {
      $srcfile_synsim{$file} = 'syn';
    }
  }
}

#-------------------------------------------------------------------------------

sub copy_edir {
  my ($file, $edir) = @_;
  print "cp -p $file $edir\n";
  system("cp -p $file $edir")==0 or bailout("cp -p failed: $?");
}

#-------------------------------------------------------------------------------

sub write_vbomdep {
  my ($target) = @_;
  print "#\n";
  print "# .dep_* on .vbom dependencies\n";
  print "#\n";
  foreach (sort keys %vbom_done) {
    print "$target : $_\n";
  }
}

#-------------------------------------------------------------------------------
sub canon_fname {
  my ($vpath,$fname) = @_;
    # get full relative file name (relative to cwd)
    $fname = "$vpath/$fname" if $vpath ne "";

    # remove 'inner' .., e.g.  ../x/../y -->  ../y
    # this will also canonize the file names, thus same file same name

    my @flist;
    foreach (split "/",$fname) {
      if (scalar(@flist) && $flist[$#flist] ne ".." && $_ eq "..") {
	pop @flist;
      } else {
	push @flist, $_;
      }
    }

    return join "/", @flist;
}

#-------------------------------------------------------------------------------
sub parse_props {
  my ($val) = @_;
  my $fname = $val;
  my %phash = ();
  if ($val =~ /^\s*(\S+)\s+(-.+)$/) {       # "fname -xxx..." seen
    $fname    = $1;
    my $plist = $2;
    foreach my $pitem (split /\s+/,$plist) {
      if ($pitem =~ m/^(.*)\:(.*)$/) {                 # -key:val (not k=v !!)
        $phash{$1} = $2;
      } else {
        $phash{$pitem} = '';
      }
    }
  }

  return ($fname, \%phash);

}

#-------------------------------------------------------------------------------
sub setup_props {
  my ($fname, $rphash) = @_;
  $srcfile_prop{$fname} = $rphash;
  my $path = '.';
  my $name = $fname;
  if ($fname =~ m|^(.+)/(.+)$|) {
    $path = $1;
    $name = $2;
  }
  my $stem = $name;
  my $type = '';
  if ($name =~ m/^(.+)(\..*)/) {
    $stem = $1;
    $type = $2;
  }
  $srcfile_prop{$fname}->{VBpath} = $path;
  $srcfile_prop{$fname}->{VBstem} = $stem;
  $srcfile_prop{$fname}->{VBtype} = $type;
  return;
}

#-------------------------------------------------------------------------------

sub bailout {
  my ($msg) = @_;
  print STDERR "vbomconv-F: $msg\n";
  exit 1;
}

#-------------------------------------------------------------------------------

sub print_help {
  print "usage: vbomconf <command> file.vbom\n";
  print "  --help           this message\n";
  print "  --trace          trace recursive processing of vbom's\n";
  print "  --dep_ghdl       generate ghdl dependencies for make\n";
  print "  --dep_xst        generate xst  dependencies for make\n";
  print "  --dep_isim       generate isim dependencies for make\n";
  print "  --dep_vsyn       generate vsyn dependencies for make\n";
  print "  --ghdl_a         generate and execute ghdl -a  (analyse)\n";
  print "  --ghdl_a_cmd     like ghdl_a, but only print command, no exec\n";
  print "  --ghdl_i         generate and execute ghdl -i  (inspect)\n";
  print "  --ghdl_i_cmd     like ghdl_i, but only print command, no exec\n";
  print "  --ghdl_m         generate and execute ghdl -m  (make)\n";
  print "  --ghdl_m_cmd     like ghdl_m, but only print command, no exec\n";
  print "  --xst_prj        generate xst project file\n";
  print "  --isim_prj       generate isim project file\n";
  print "  --vsyn_prj       generate vivado synthesis project definition\n";
  print "  --ghdl_export=s  export all ghdl source files into directory s\n";
  print "  --xst_export=s   export all xst source files into directory s\n";
  print "  --isim_export=s  export all isim source files into directory s\n";
  print "  --vsyn_export=s  export all vsyn source files into directory s\n";
  print "  --vsim_export=s  export all vsim source files into directory s\n";
  print "  --get_top        return top level entity name\n";
  print "  --flist          list all files touched by vbom for all tags\n";
}
