; $Id: cpu_details.mac 1323 2022-12-01 08:00:41Z mueller $
; SPDX-License-Identifier: GPL-3.0-or-later
; Copyright 2022- by Walter F.J. Mueller <W.F.J.Mueller@gsi.de>
;
; Revision History:
; Date         Rev Version  Comment
; 2022-11-29  1323   1.0    Initial version
; 2022-07-18  1259   0.1    First draft
;
; Test CPU details
;   Section A: CPU registers
;   Section B: stress tests
;   Section C: 11/70 specifics
;
        .include        |lib/tcode_std_base.mac|
        .include        |lib/defs_mmu.mac|
;
; Preface: set up MMU for kernel mode (for some tests) =======================
;
        mov     #kipdr,r0
        mov     #<127.*md.plf>!md.arw,r1  ; plf=127; ed=0(up); acf=6(w/r)
        mov     r1,(r0)+        ; kipdr0
        mov     r1,(r0)+        ; kipdr1
        mov     r1,(r0)+        ; kipdr2
        mov     r1,(r0)+        ; kipdr3
        mov     r1,(r0)+        ; kipdr4
        mov     r1,(r0)+        ; kipdr5
        mov     r1,(r0)+        ; kipdr6
        mov     r1,(r0)+        ; kipdr7
        mov     #kipar,r0
        mov     #000000,(r0)+   ; kipar0 000000 base
        mov     #000200,(r0)+   ; kipar1 020000 base
        mov     #000400,(r0)+   ; kipar2 040000 base
        mov     #000600,(r0)+   ; kipar3 060000 base
        mov     #001000,(r0)+   ; kipar4 100000 base
        mov     #001200,(r0)+   ; kipar5 120000 base
        mov     #001400,(r0)+   ; kipar6 140000 base
        mov     #177600,(r0)+   ; kipar7 (map I/O page)
;
; some useful definitions
       kipdr5 = kipdr+12
       kipdr6 = kipdr+14
       kipar6 = kipar+14
       p6base = <6*20000>               ; page 6
;
; Section A: CPU registers ===================================================
;
; Test A1:  PIRQ +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies operation of PIRQ register
;
; Test A1.1 -- PIRQ + spl ++++++++++++++++++++++++++++++++++++++++++++
;   This test will exercise all 7 pirq interrupt levels:
;     set 1+3 -> handle 3, set 7
;             -> handle 7, set 6+4
;             -> handle 6
;             -> handle 4, set 5+2
;             -> handle 5
;             -> handle 2
;             -> handle 1
;
; some useful definitions
        pi.r00=bit08            ; pir 0 bit
        pi.r01=bit09            ; pir 1 bit
        pi.r02=bit10            ; pir 2 bit
        pi.r03=bit11            ; pir 3 bit
        pi.r04=bit12            ; pir 4 bit
        pi.r05=bit13            ; pir 5 bit
        pi.r06=bit14            ; pir 6 bit
        pi.r07=bit15            ; pir 7 bit
        pi.n00=0.               ; lsb for no pir pending
        pi.n01=1*042            ; lsb for pir 1 next
        pi.n02=2*042            ; lsb for pir 2 next
        pi.n03=3*042            ; lsb for pir 3 next
        pi.n04=4*042            ; lsb for pir 4 next
        pi.n05=5*042            ; lsb for pir 5 next
        pi.n06=6*042            ; lsb for pir 6 next
        pi.n07=7*042            ; lsb for pir 7 next
;
ta0101: mov     #1000$,v..pir     ; set up handler
        mov     #cp.pr7,v..pir+2  ; which runs at pr7
        mov     #cp.pir,r3      ; ptr to PIRQ
        mov     #cp.psw,r4      ; ptr to PSW
        mov     #1200$,r5       ; ptr to check data
        clr     1300$           ; clear nesting counter
;
        spl     7               ; lockout interrupts
        bisb    #bit01,1(r3)    ; set PIRQ 1
        hcmpeq  (r3),#<pi.r01!pi.n01>                   ; check set 1
        bisb    #bit03,1(r3)    ; set PIRQ 3
        hcmpeq  (r3),#<pi.r01!pi.r03!pi.n03>            ; check set 1+3
        spl     2
        nop                     ; allow interrupts to happen
        spl     0
        nop                     ; allow interrupts to happen
        htsteq  (r3)            ; PIRQ should clear now
        mov     #v..pir+2,v..pir; restore pirq vector catcher
        clr     v..pir+2
        jmp     9999$
;
; PIRQ interrupt handler
;   - it starts at pr7 from the vector
;   - quickly lowers the priority to what is currently processed
;   - new pirq bits are set at lowered priority
;   - that leads to nested interrupts (tracked by a level counter)
;
1000$:  inc     1300$           ; up level counter
        mov     (r3),r0         ; get PIRQ value
        hcmpeq  1300$,(r5)+     ; check nesting level
        hcmpeq  r0,(r5)+        ; check pirq value
        movb    r0,(r4)         ; PSW=PIRQ (sets priority)
        bic     #177761,r0      ; mask out index bits
        mov     r0,r1           ; r0 is word index (pri*2)
        asr     r1              ; r1 is byte index (pri*1)
        mov     #pi.r00,r2
        ash     r1,r2           ; r2 = pi.r00 <<(pri)
        bic     r2,(r3)         ; clear current level in pirq
        bis     1100$(r0),(r3)  ; trigger new pirqs
        nop                     ; allow nested interrupts to happen
        nop                     ;
        dec     1300$           ; down level counter
        rti
;
; table with new pirqs triggered at a level
1100$:  .word   0               ; new pirq @ level 0
        .word   0               ; new pirq @ level 1
        .word   0               ; new pirq @ level 2
        .word   pi.r07          ; new pirq @ level 3  -> 7
        .word   pi.r05!pi.r02   ; new pirq @ level 4  -> 5+2
        .word   0               ; new pirq @ level 5
        .word   0               ; new pirq @ level 6
        .word   pi.r06!pi.r04   ; new pirq @ level 7  -> 6+4
;
; table with expected values of pirq register in interrupt sequence
1200$:  .word   1,pi.r01!pi.r03!pi.n03          ; set 1+3   -> handle 3, set 7
        .word   2,pi.r01!pi.r07!pi.n07          ; set 1+7   -> handle 7, set 6+4
        .word   2,pi.r01!pi.r04!pi.r06!pi.n06   ; set 1+4+6 -> handle 6
        .word   2,pi.r01!pi.r04!pi.n04          ; set 1+4   -> handle 4, set 5+2
        .word   3,pi.r01!pi.r02!pi.r05!pi.n05   ; set 1+2+5 -> handle 5
        .word   1,pi.r01!pi.r02!pi.n02          ; set 1+2   -> handle 2
        .word   1,pi.r01!pi.n01                 ; set 1     -> handle 1
; nesting level counter
1300$:  .word   0
;
9999$:  iot                     ; end of test A1.1
;
; Test A1.2 -- PIRQ and immediate interrupt ++++++++++++++++++++++++++
;   This test verifies that an interrupt is taken immediately after the
;   write of the PIRQ register
;
ta0102: spl     0               ; ensure execution at PR0
        mov     #1000$,v..pir     ; set up handler
        mov     #cp.pr7,v..pir+2  ; which runs at pr7
        mov     #pi.r03,cp.pir  ; request PIRQ 3
        halt                    ; halt if not taken immediatly
;
1000$:  clr     cp.pir          ; cancel all PIRQ levels
        mov     #1100$,(sp)     ; continue
        rti
;
1100$:  mov     #v..pir+2,v..pir; restore pirq vector catcher
        clr     v..pir+2
;
9999$:  iot                     ; end of test A1.2
;
; Test A2:  CPUERR +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies operation of CPUERR register
;
; setup for all A2.* tests
        mov     #cp.err,r0      ; ptr tp CPUERR
        mov     #vhugen,v..iit  ; set iit handler
        clr     v..iit+2        ; pr0 kernel
;
; Test A2.1 -- CPUERR cp.hlt +++++++++++++++++++++++++++++++++++++++++
;   Test cp.hlt: halt in non-kernel mode
;
ta0201: mov     #177777,(r0)    ; clear CPUERR (any write should)
        htsteq  (r0)            ; ensure that CPUERR is zero
;
        mov     #4000$,r2       ; mode list (user,supervisor)
        mov     #2,r3           ; number of modes
;
1000$:  clr     r1              ; clear tracer
        mov     #3000$,vhustp     ; continuation address
        push    (r2)+             ; frame: psw
        push    #2000$            ; frame: address
        rti                     ; start user mode code
        halt
;
2000$:  inc     r1              ; proof of execution
        halt                    ; that will abort
        inc     r1
        tst     @#001           ; that must abort
;
3000$:  hcmpeq  r1,#1           ; check tracer
        hcmpeq  (r0),#cp.hlt    ; check CPUERR
        mov     #cp.rsv,(r0)    ; clear CPUERR (any write should)
        htsteq  (r0)            ; check CPUERR
;
        sob     r3,1000$        ; go for next mode
;
        br      9999$
;
4000$:  .word   <cp.cmu!cp.pmu> ; user mode
        .word   <cp.cms!cp.pms> ; supervisor mode
;
9999$:  iot                     ; end of test A2.1
;
; Test A2.2 -- CPUERR cp.odd +++++++++++++++++++++++++++++++++++++++++
;   Test cp.odd: odd address error abort
;
ta0202: mov     #1000$,vhustp   ; continuation address
        tst     @#001           ; odd address access
        halt
1000$:  hcmpeq  (r0),#cp.odd    ; check CPUERR
        clr     (r0)            ; clear CPUERR (any write should)
        htsteq  (r0)            ; check CPUERR
;
9999$:  iot                     ; end of test A2.2
;
; Test A2.3 -- CPUERR cp.nxm +++++++++++++++++++++++++++++++++++++++++
;   Test cp.nxm: non-existent memory abort
;   Use unibus map address space (248kB) below the I/O page, the w11
;   will return a non-existent memory abort even in a maximum memory
;   configuration.
;
ta0203: cmpb    systyp,#sy.e11  ; e11 V7.3 return wrong CPUERR value
        beq     9999$
        push    kipar6          ; save kipar6
        mov     #177400,kipar6
        mov     #m3.e22,mmr3    ; 22-bit mode
        mov     #m0.ena,mmr0    ; enable mmu                    ;! MMU 22
;
        mov     #1000$,vhustp   ; continuation address
        tst     p6base          ; access non-existing memory
        halt
1000$:  hcmpeq  (r0),#cp.nxm    ; check CPUERR
        com     (r0)            ; clear CPUERR (any write should)
        htsteq  (r0)            ; check CPUERR
;
        reset                   ; disable mmu                   ;! MMU off
        pop     kipar6          ; restore kipar6
9999$:  iot                     ; end of test A2.3
;
; Test A2.4 -- CPUERR cp.ito +++++++++++++++++++++++++++++++++++++++++
;   Test cp.ito: unibus timeout abort
;   Use first address in I/O page (160000), always unused in w11
;
ta0204: mov     #1000$,vhustp   ; continuation address
        tst     @#160000        ; access non-existing unibus device
        halt
1000$:  hcmpeq  (r0),#cp.ito    ; check CPUERR
        clr     (r0)            ; clear CPUERR (any write should)
        htsteq  (r0)            ; check CPUERR
;
9999$:  iot                     ; end of test A2.4
;
; Test A2.5 -- CPUERR cp.ysv +++++++++++++++++++++++++++++++++++++++++
;   Test cp.ysv: yellow stack trap
;   Since stack is still usable after the trap, the vhugen handler can be used.
;
ta0205: cmpb    systyp,#sy.e11  ; e11 V7.3 doesnt trap, runs on hold
        beq     9999$
        mov     #1000$,vhustp   ; continuation address
        mov     #400,sp
        clr     -(sp)           ; should trap (not abort)
        halt                    ; not executed, handler continues at 1000$
1000$:  hcmpeq  (r0),#cp.ysv    ; check CPUERR
        clr     (r0)            ; clear CPUERR (any write should)
        htsteq  (r0)            ; check CPUERR
;
        mov     #stack,sp
9999$:  iot                     ; end of test A2.5
;
; Test A2.6 -- CPUERR cp.rsv +++++++++++++++++++++++++++++++++++++++++
;   Test cp.rsv: red stack trap - simple low stack case
;
ta0206: cmpb    systyp,#sy.e11  ; e11 V7.3 doesnt abort, runs on hold
        beq     9999$
        mov     #1000$,v..iit   ; setup direct iit handler
        mov     #340,sp
        clr     -(sp)           ; should abort (not trap)
        halt
1000$:  htsteq  sp              ; check SP=0
        hcmpeq  (r0),#cp.rsv    ; check CPUERR
        clr     (r0)            ; clear CPUERR (any write should)
        htsteq  (r0)            ; check CPUERR
        mov     #stack,sp       ; restore stack
;
9999$:  iot                     ; end of test A2.6
;
; Test A2.7 -- CPUERR cp.odd + stack error +++++++++++++++++++++++++++
;   Test cp.odd: fatal stack error after odd stack
;
ta0207: cmpb    systyp,#sy.e11  ; e11 V7.3 pushes to odd stack, abort after halt
        beq     9999$
        cmpb    systyp,#sy.sih  ; SimH uses J11 semantics
        bne     100$
        mov     #<cp.rsv+cp.odd>,1010$+2 ; and sets rsv for all stack errors
;
100$:   mov     #1000$,v..iit   ; setup direct iit handler
        mov     #stack-1,sp
        clr     -(sp)           ; odd-address abort, fatal stack error
        halt
1000$:  htsteq  sp              ; check SP=0
1010$:  hcmpeq  (r0),#<cp.rsv+cp.odd> ; check CPUERR
        clr     (r0)            ; clear CPUERR (any write should)
        htsteq  (r0)            ; check CPUERR
        mov     #stack,sp       ; restore stack
;
9999$:  iot                     ; end of test A2.7
;
; Test A2.8 -- CPUERR cp.nxm + stack error +++++++++++++++++++++++++++
;   Test cp.nxm: fatal stack error after non-existent memory abort
;   Setup like in A2.3, put stack at p6base+4
;
ta0208: cmpb    systyp,#sy.e11  ; e11 V7.3 pushes to bad stack, abort after halt
        beq     9999$
        cmpb    systyp,#sy.sih  ; SimH uses J11 semantics
        bne     100$
        mov     #<cp.rsv+cp.nxm>,1010$+2 ; and sets rsv for all stack errors
;
100$:   mov     #1000$,v..iit   ; setup direct iit handler
        mov     #177400,kipar6
        mov     #m3.e22,mmr3    ; 22-bit mode
        mov     #m0.ena,mmr0    ; enable mmu                    ;! MMU 22
;
        mov     #p6base+4,sp    ; stack in non-existing memory
        clr     -(sp)           ; non-existing memory, fatal stack error
        halt
1000$:  htsteq  sp              ; check SP=0
1010$:  hcmpeq  (r0),#<cp.rsv+cp.nxm> ; check CPUERR
        clr     (r0)            ; clear CPUERR (any write should)
        htsteq  (r0)            ; check CPUERR
        mov     #stack,sp       ; restore stack
;
        reset                                                   ;! MMU off
        mov     #001400,kipar6  ; restore kipar6
;
9999$:  iot                     ; end of test A2.8
;
; Test A2.9 -- CPUERR cp.ito + stack error +++++++++++++++++++++++++++
;   Test cp.ito: fatal stack error after unibus timeout
;   Setup like in A2.4, put stack at 160004
;
ta0209: cmpb    systyp,#sy.e11  ; e11 V7.3 pushes to bad stack, abort after halt
        beq     9999$
        cmpb    systyp,#sy.sih  ; SimH uses J11 semantics
        bne     100$
        mov     #<cp.rsv+cp.ito>,1010$+2 ; and sets rsv for all stack errors
;
100$:   mov     #1000$,v..iit   ; setup direct iit handler
        mov     #160004,sp      ; stack at non-existing unibus device
        clr     -(sp)           ; non-existing memory, fatal stack error
        halt
1000$:  htsteq  sp              ; check SP=0
1010$:  hcmpeq  (r0),#<cp.rsv+cp.ito> ; check CPUERR
        clr     (r0)            ; clear CPUERR (any write should)
        htsteq  (r0)            ; check CPUERR
        mov     #stack,sp       ; restore stack
;
9999$:  iot                     ; end of test A2.9
;
; Test A2.10 -- CPUERR mmu abort + stack error +++++++++++++++++++++++
;   Test cp.rsv: fatal stack error after mmu abort
;   Set kernel I page 6 to non-resident
;
ta0210: cmpb    systyp,#sy.sih  ; SimH uses J11 semantics
        bne     100$
        mov     #cp.rsv,1010$+2 ; and sets rsv for all stack errors
;
100$:   mov     #1000$,v..iit   ; setup direct iit handler
        clr     kipdr6          ; set non-resident
        mov     #m3.e22,mmr3    ; 22-bit mode
        mov     #m0.ena,mmr0    ; enable mmu                    ;! MMU 22
;
        mov     #p6base+4,sp    ; stack in non-resident memory
        clr     -(sp)           ; MMU abort, fatal stack error
        halt
1000$:  htsteq  sp              ; check SP=0
1010$:  hcmpeq  (r0),#cp.rsv    ; check CPUERR
        clr     (r0)            ; clear CPUERR (any write should)
        htsteq  (r0)            ; check CPUERR
        mov     #stack,sp       ; restore stack
;
        reset                                                   ;! MMU off
        mov     kipdr5,kipdr6   ; restore kipdr6 (default kipdr are identical)
;
9999$:  iot                     ; end of test A2.10
;
; -----------------------------------------------
; end of A2.* tests, restore iit handler
        mov     v..iit+2,v..iit ; restore iit handler
;
; Test A3:  STKLIM +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies operation of STKLIM register
;   and the yellow stack trap and red stack abort functionality.
;
; Test A3.1 -- STKLIM write/read test ++++++++++++++++++++++++++++++++
;   STKLIM is a 16 bit register, upper byte is retained, lower reads always 0
;
ta0301:
;
; part 1: word access ------------------------------------------------
;
        mov     #1000$,r0               ; ptr to value list
        mov     #<1010$-1000$>/2,r1     ; # of values
        mov     #377,r2                 ; LSB byte mask
        mov     #cp.slr,r3              ; ptr to STKLIM
;
100$:   mov     (r0)+,r4                ; get value
        mov     r4,(r3)                 ; load STKLIM
        bic     r2,r4                   ; clear LSB
        hcmpeq  r4,(r3)                 ; read and ckeck STKLIM
        sob     r1,100$                 ; go for next STKLIM value
        br      2000$
;
1000$:  .word   ^b0101010101010101
        .word   ^b1010101010101010
        .word   ^b0000000011001100      ; STKLIM = 0 at end of test
1010$:
;
; part 2: byte access ------------------------------------------------
;
2000$:  movb    #7,1(r3)                ; write MSB
        hcmpeq  #3400,(r3)              ; check MSB written
        movb    #70,(r3)                ; write LSB
        hcmpeq  #3400,(r3)              ; check MSB unchanged
        clr     (r3)                    ; STKLIM to default
;
9999$:  iot                                     ; end of test A3.1
;
; Test A3.2 -- yellow trap + red abort boundary ++++++++++++++++++++++
;
ta0302:
;
; part 1: sequence of yellow traps and a final red stack abort -------
;   Verifies that push to STKLIM+376 to STKLIM+344 causes a yellow stack
;   trap and a push to STKLIM+342 succeeds, but the yellow stack trap flow
;   fails and causes a red stack trap. Done for
;         0    yellow below 000400
;      1400    yellow below 002000
;    157400    yellow below 156000
;
;   Note: SimH has simplified stack limit testing in vector flows.
;         The stack is checked at end of flow. SimH will happily
;         do yellow trap after push to +342 and write into +336.
;         This part is therefore skipped for SimH
;
        cmpb    systyp,#sy.sih          ; on SimH ?
        bne     10$                     ; if not, execute
        jmp     2000$                   ; if yes, skip
;
10$:    mov     #1200$,r0               ; ptr to value list
        mov     #<1210$-1200$>/2,r1     ; # of values
        mov     #1000$,v..iit           ; set up iit handler
        mov     #cp.pr3,v..iit+2        ; use pr3 as handler signature
;
100$:   spl     6                       ; use pr6 as code signature
        mov     (r0)+,r5                ; get value
        mov     r5,cp.slr               ; load STKLIM
        clr     336(r5)                 ; clear word on red boundary
        mov     r5,sp                   ; load SP
        add     #400,sp                 ; to yellow boundary
        clr     r2                      ; clear yellow trap counter
        mov     #1.,-(sp)               ; push to STKLIM+376 -> trap
        mov     #2.,-(sp)               ; push to STKLIM+374 -> trap
        mov     #3.,-(sp)               ; push to STKLIM+372 -> trap
        mov     #4.,-(sp)               ; push to STKLIM+370 -> trap
        mov     #5.,-(sp)               ; push to STKLIM+366 -> trap
        mov     #6.,-(sp)               ; push to STKLIM+364 -> trap
        mov     #7.,-(sp)               ; push to STKLIM+362 -> trap
        mov     #8.,-(sp)               ; push to STKLIM+360 -> trap
        mov     #9.,-(sp)               ; push to STKLIM+356 -> trap
        mov     #10.,-(sp)              ; push to STKLIM+354 -> trap
        mov     #11.,-(sp)              ; push to STKLIM+352 -> trap
        mov     #12.,-(sp)              ; push to STKLIM+350 -> trap
        mov     #13.,-(sp)              ; push to STKLIM+346 -> trap
        mov     #14.,-(sp)              ; push to STKLIM+344 -> trap
        mov     #15.,-(sp)              ; push to STKLIM+342 -> try trap->abort
200$:   halt
        halt
;
1000$:  tst     sp                      ; red abort seen ?
        beq     1010$                   ; if yes, check status
        inc     r2                      ; if no, got for next push
        rti
;
1010$:  hcmpeq  #14.,r2                 ; all traps taken ?
        hcmpeq  #13.,346(r5)            ; check 13th push
        hcmpeq  #14.,344(r5)            ; check 14th push
        hcmpeq  #15.,342(r5)            ; check 15th push (was done)
        hcmpeq  #cp.pr6,340(r5)         ; saved PS of attempted yellow trap
        htsteq  336(r5)                 ; red zone border clean ?
;;      hcmpeq  #cp.pr6,@#2             ; saved PS of red abort (w11 not yet!)
;;      hcmpeq  #200$,@#0               ; saved PC of red abort (e11 not yet!)
        dec     r1                      ; too far for sob
        beq     1020$
        jmp     100$                    ; go for next STKLIM value
;
1020$:  clr     cp.slr                  ; STKLIM to default
        mov     #stack,sp               ; SP to default
        mov     #v..iit+2,v..iit        ; v..iit to catcher
        clr     v..iit+2
        spl     0                       ; prio to default
        br      2000$
;
1200$:  .word   000000
        .word   001400
        .word   157400
1210$:
;
; part 2: check that red zone does not have yellow islands -----------
;
2000$:  cmpb    systyp,#sy.e11          ; on e11 ?
        beq     3000$                   ; if yes skip, e11 still buggy here
;
        mov     #2300$,r0               ; ptr to values
        mov     #<2310$-2300$>/2,r1     ; # of values
        mov     #2200$,v..iit           ; set up iit handler
        mov     #1400,cp.slr            ; set yellow limit to 1776
;
2100$:  mov     (r0)+,sp                ; set SP to test value
        clr     -(sp)                   ; expect red abort, not yellow trap
        halt
;
2200$:  htsteq  sp                      ; check SP=0
        sob     r1,2100$
;
        clr     cp.slr                  ; STKLIM to default
        mov     #stack,sp               ; SP to default
        mov     #v..iit+2,v..iit        ; v..iit to catcher
        clr     v..iit+2
        br      3000$
;
2300$:  .word   001400                  ; probe 1376  (possible yellow mirror)
        .word   001340                  ; probe 1336
        .word   001000                  ; probe 0776  (possible yellow mirror)
        .word   000400                  ; probe 0376  (possible yellow mirror)
2310$:
;
; part 3: check red zone PSW protection ------------------------------
;   push to 177776 should also cause a red stack abort
;
3000$:  tstb    systyp                  ; only done in w11
        ble     9999$
;
        mov     #1400,cp.slr            ; set STKLIM
        mov     #1300,sp                ; SP deep in red zone
        mov     #3100$,v..iit           ; set up iit handler
        clr     -(sp)                   ; expect red abort
        halt
3100$:  htsteq  sp                      ; check SP=0, on emergency stack
        mov     #3200$,v..iit           ; set up iit handler
        clr     -(sp)                   ; expect red abort again
        halt
3200$:  htsteq  sp                      ; check SP=0 because of PSW protection
        clr     cp.slr                  ; STKLIM to default
        mov     #stack,sp               ; SP to default
        mov     #v..iit+2,v..iit        ; v..iit to catcher
;
9999$:  iot                                     ; end of test A3.2
;
; Test A3.3 -- stack trap conditions +++++++++++++++++++++++++++++++++
;   Verifies that mode 1,2,4,6 trap for dstw flows and dstr when rmw
;   Verifies that mode 3,5,7 writes do not trap
;   Verifies that mode 1-7 reads do not trap
;   Verifies that implict pushes (JSR,MFPI) trap
;   Verifies that vector push of trap instructions (EMT,TRAP tested) traps
;   Verifies that vector push of an interrupt (PIRQ tested) traps
;   Notes:
;   - dstw (mov,clr,..) and dstr (add,bis,...) flows write to stack -> test both
;   - inspired by eqkce0 test 041 that verifies do/dont trap instruction cases
;   - SimH and e11 currently do not support full 11/70 mode semantics
;
ta0303: tstb    systyp                  ; skip if not on w11
        bge     100$
        jmp     9999$
;
100$:   mov     #1400,cp.slr            ; set yellow limit to 1776
;
; part 1: test instructions that should trap -------------------------
;
        mov     #1000$,v..iit           ; set up iit handler
        clr     v..iit+2
        mov     #1100$,v..emt           ; set up emt handler
        clr     v..emt+2
        mov     #1200$,v..trp           ; set up trap handler
        clr     v..trp+2
        clr     r2                      ; clear trap counter
;
; dstw mode 1,2,4,6
        mov     #1000,-(sp)             ; dstw mode 4: SP now 1776 (1)
        clr     -(sp)                   ; dstw mode 4: SP now 1774 (2)
        mov     (sp),(sp)               ; dstw mode 1: SP now 1774 (3)
        clr     (sp)                    ; dstw mode 1: SP now 1774 (4)
        mov     (sp),(sp)+              ; dstw mode 2: SP now 1776 (5)
        clr     0(sp)                   ; dstw mode 6: SP now 1776 (6)
        mov     (sp),0(sp)              ; dstw mode 6: SP now 1776 (7)
; implied push
        jsr     pc,1300$                ; implied push: SP now 1176 (8)
        mfpi    r0                      ; implied push: SP now 1774 (9)
; trap instrunctions
        emt     100                     ; trap push: SP now 1174 (10)
        trap    200                     ; trap push: SP now 1174 (11)
; dstr mode 1,2,4,6 when rmw
        add     (sp),(sp)               ; dstr mode 1: SP now 1174 (12)
        bis     (sp),-(sp)              ; dstr mode 4: SP now 1172 (13)
        incb    (sp)+                   ; dstr mode 2: SP now 1174 (14)
        dec     0(sp)                   ; dstr mode 6: SP now 1174 (15)
;
        br      1500$
;
1000$:  htstne  sp                      ; no red stack aborts expected
        inc     r2
        rti
;
1100$:  rti                             ; dummy emt handler
1200$:  rti                             ; dummy trap handler
1300$:  rts     pc                      ; dummy routine
;
1500$:  hcmpeq  #15.,r2                 ; all traps taken ?
        mov     #v..iit+2,v..iit        ; v..iit to catcher
        mov     #v..emt+2,v..emt        ; v..emt to catcher
        mov     #v..trp+2,v..trp        ; v..trp to catcher
;
; part 2: test instructions that should not trap ---------------------
;
2000$:  mov     #stack-2,r2             ; in yellow zone
        mov     r2,(r2)                 ; load on stack (not using SP)
        mov     r2,sp                   ; SP in yellow zone
; dstw mode 3,5,7
        mov     (sp)+,@-(sp)            ; dstw mode 5: SP now 1176
        mov     @0(sp),@(sp)+           ; dstw mode 3: SP now 1200
        mov     -(sp),@0(sp)            ; dstw mode 7: SP now 1176
; dstr mode 3,5,7 when rmw
        bis     (sp)+,@-(sp)            ; dstw mode 5: SP now 1176
        bis     @0(sp),@(sp)+           ; dstw mode 3: SP now 1200
        bis     -(sp),@0(sp)            ; dstw mode 7: SP now 1176
; dstr mode 1,2,4,6 in read-only
        tst     (sp)                    ; dstr mode 1: SP now 1176
        cmp     (sp),-(sp)              ; dstr mode 4: SP now 1174
        cmp     (sp),(sp)+              ; dstr mode 2: SP now 1176
        cmp     (sp),0(sp)              ; dstr mode 6: SP now 1176
; dstr mode 3,5,7 in read-only
        cmp     (sp),@(sp)+             ; dstr mode 3: SP now 1200
        cmp     (sp),@-(sp)             ; dstr mode 5: SP now 1176
        cmp     (sp),@0(sp)             ; dstr mode 7: SP now 1176
; check that EA is compared against STKLIM
        clr     sp
        mov     @#2000,2000(sp)         ; SP=0, EA=2000 -> no trap
;
; part 3: test that interrupt (from PIRQ) vector push traps ----------
;   Triggers 3 PIRQ interrupts at PR1, PR3, and PR6.
;   The PIRQ interrupt vector push will issue a ysv trap.
;   That trap executes before the first instruction of the pir handler.
;   The iit handler must therefore execute at PR7 to lockout interrupts.
;   When the iit handler returns, the pir hander will execute.
;
3000$:  mov     #3100$,v..iit           ; set up iit handler
        mov     #cp.pr7,v..iit+2        ; lockout interrupts !
        mov     #3200$,v..pir           ; set up pir handler
        mov     #cp.pr7,v..pir+2        ; lockout interrupts
        mov     #stack,sp               ; SP to default (STKLIM still 1400)
        clr     r2                      ; clear trap counter
        mov     #cp.pir,r3              ; ptr to cp.pir
        mov     #3500$,r5               ; ptr to probe data
;
        spl     0
        movb    #bit06!bit03!bit01,1(r3)   ; request PIRQ 6+3+1
        nop
        br      3900$
;
; iit handler
3100$:  htstne  sp              ; no red stack aborts expected
        hcmpeq  #177777,(r5)+   ; check state
        inc     r2
        rti
;
; pir handler
3200$:  mov     (r3),r0         ; get PIRQ
        bic     #177761,r0      ; mask out index bits (is pri*2)
        asr     r0              ; now pri*1
        hcmpeq  r0,(r5)+        ; check state
        mov     #pi.r00,r1
        ash     r0,r1           ; pi.r00 <<(pri)
        bic     r1,(r3)         ; clear PIRQ request
        rti
;
; state check data
3500$:  .word   177777,6.       ; iit marker + pr6 pirq
        .word   177777,3.       ; iit marker + pr3 pirq
        .word   177777,1.       ; iit marker + pr1 pirq
;
3900$:  hcmpeq  #3.,r2                  ; all traps taken ?
        mov     #v..iit+2,v..iit        ; v..iit to catcher
        clr     v..iit+2
        mov     #v..pir+2,v..pir        ; v..pir to catcher
        clr     v..pir+2
;
; final cleanup
        clr     cp.slr                  ; STKLIM to default
        mov     #stack,sp               ; SP to default
;
9999$:  iot                                     ; end of test A3.3
;
; Test A3.4 -- red stack abort conditions ++++++++++++++++++++++++++++
;   Verifies that instruction writes abort
;   Verifies that implict pushes (JSR,MFPI) abort
;   Verifies that vector push after trap instructions and interrupts abort
;     Abort on 1st and 2nd push is tested.
;
ta0304:
        mov     #1000$,v..iit           ; set up iit handler
        mov     #cp.pr7,v..iit+2        ; lockout interrupts !
        mov     #1400,cp.slr            ; yellow <=1776 and red <= 1736
        clr     @#1736                  ; ensure top red word zero
        clr     cp.err                  ; clear CPUERR
;
; dstw flow
        mov     #1740,sp                ; SP at red border
        mov     #100$,r5
        mov     #123456,-(sp)
        halt
;
; dstr flow (rmw)
100$:   mov     #200$,r5
        add     (sp),-(sp)
        halt
;
; implicit push instructions
200$:   mov     #300$,r5
        jsr     pc,210$
        halt
210$:   halt
;
300$:   mov     #400$,r5
        mfpi    r0
        halt
;
; vector flow abort in 2nd push, 1st push in yellow (use EMT for test)
;   Note: SimH scribbles into red zone, therefore test skipped for SimH
400$:   cmpb    systyp,#sy.sih          ; skip section on SimH
        beq     500$
        mov     sp,r0
        mov     #123456,(r0)+           ; write marker to 1740, r0 to avoid ysv
        mov     r0,sp                   ; SP now 1402 -> abort on 2nd push
        mov     #cp.pr3,cp.psw          ; set pr3 as marker
        mov     #420$,r5                ; leaves NZVC = 0000
        emt     100
410$:   halt
420$:   hcmpeq  #cp.pr3,@#1740          ; check that PS written
;
; vector flow abort in 1st push (use PIRQ for test)
500$:   spl     0
        mov     #600$,r5
        mov     #pi.r04,cp.pir          ; request PIRQ 4
        halt
600$:   clr     cp.pir
        br      9000$
;
1000$:  htsteq  sp                      ; check SP=0
        htsteq  @#1736                  ; check stack clean
        hcmpeq  #cp.rsv,cp.err          ; check CPUERR.rsv (and no ysv)
        clr     cp.err                  ; clear CPUERR
        mov     #1740,sp                ; restore SP
        jmp     (r5)                    ; continue
;
9000$:  clr     cp.slr                  ; STKLIM to default
        mov     #v..iit+2,v..iit        ; v..iit to catcher
        clr     v..iit+2
        mov     #stack,sp               ; SP to default
        spl     0                       ; back to PR0
;
9999$:  iot                                     ; end of test A3.4
;
; Section B: Stress tests ====================================================
;
; Test B1:  address mode torture tests +++++++++++++++++++++++++++++++++++++++
;   This sub-section tests peculiar address node usage
;
; Test B1.1 -- src-dst update hazards with (r0)+,(r0) ++++++++++++++++
;
tb0101: mov     #2,r5
100$:   mov     #1000$,r0
        mov     #1110$,r1
        push    1000$+2         ; save data that will change
        push    1000$+6
        push    1100$+0
        push    1100$+4
;
        mov     (r0)+,(r0)+     ; mov 111 over 222
        add     (r0)+,(r0)+     ; add 333 to   444
        mov     -(r1),-(r1)     ; mov 444 over 333
        add     -(r1),-(r1)     ; add 222 to   111
;
        hcmpeq  1000$+2,#000111
        hcmpeq  1000$+6,#000777
        hcmpeq  1100$+4,#000444
        hcmpeq  1100$+0,#000333
;
        pop     1100$+4         ; restore data
        pop     1100$+0
        pop     1000$+6
        pop     1000$+2
        sob     r5,100$
        jmp     9999$
;
1000$:  .word   000111          ; data for (r0)+ part
        .word   000222
        .word   000333
        .word   000444
;
1100$:  .word   000111          ; data for -(r0) part
        .word   000222
        .word   000333
        .word   000444
1110$:
;
9999$:  iot                     ; end of test B1.1
;
; Test B1.2 -- (pc)+ as destination ++++++++++++++++++++++++++++++++++
;
tb0102: mov     #2,r5
100$:   push    1000$+4         ; save data that will change
        push    1100$+4
        push    1200$+2
;
        clr     r0
1000$:  mov     #1,#0           ; (pc)+,(pc)+: write #1 over #0
1100$:  add     #1,#2           ; (pc)+,(pc)+: add #1 to #2
        mov     1000$+4,1200$+2 ; -14(pc),2(pc): dst of mov -> src of add
1200$:  add     #0,r0           ; add #1(!) to r0
;
        hcmpeq  1000$+4,#1
        hcmpeq  1100$+4,#3
        hcmpeq  r0,#1
;
        pop     1200$+2         ; restore data
        pop     1100$+4
        pop     1000$+4
        sob     r5,100$
;
9999$:  iot                     ; end of test B1.2
;
; Test B1.3 -- pc as destination in clr, mov, and add ++++++++++++++++
;
tb0103: mov     #000137,@#0  ; setup jmp 1000$ at mem(0)
        mov     #1000$,@#2
        clr     pc
        halt
        halt
        halt
1000$:  mov     #1100$,pc
        halt
        halt
        halt
1100$:  clr     r0
        add     #4,pc           ; skip two instructions
        inc     r0
        inc     r0
        inc     r0              ; lands here
        inc     r0
        hcmpeq  r0,#2
;
        clr     @#0             ; remove jmp 1000$ at mem(0)
        clr     @#2
;
9999$:  iot                     ; end of test B1.3
;
; Test B2:  pipeline torture tests +++++++++++++++++++++++++++++++++++++++++++
;   This sub-section tests self-modifying code
;
; Test B2.1 -- self-modifying code, use (pc), -(pc) ++++++++++++++++++
;
tb0201: mov     #2,r5
100$:   mov     1000$,-(sp)
        mov     1100$,-(sp)
;
        clr     r0
        clr     r1
        clr     r2
        mov     #005201,r3      ; r3= inc r1
        mov     #005202,r4      ; r4= inc r2
;
        inc     r0
        mov     r3,(pc)         ; will overwrite next instruction
1000$:  halt                    ; will be overwritten with 'inc r1'
        inc     r0
1100$:  mov     r4,-(pc)        ; will overwrite itself and re-execute(!)
        inc     r0
;
        hcmpeq  r0,#3           ; 3 inc r0 in code
        hcmpeq  r1,#1           ; check that 'inc r1' was executed
        hcmpeq  r2,#1           ; check that 'inc r2' was executed
;
        mov     (sp)+,1100$
        mov     (sp)+,1000$
        sob     r5,100$
;
9999$:  iot                     ; end of test B2.1
;
; Test B2.2 -- self-modifying code, use (pc) case 2 ++++++++++++++++++
;   Was insprired by KDJ11A.MAC (J11 is indeed pipelined)
;
tb0202: mov     #2,r5
100$:   mov     1000$,-(sp)
        mov     1100$,-(sp)
        mov     1200$,-(sp)
;
        mov     #1999$,r1
        clr     r2
;
        mov     #005202,(pc)    ; will replace jmp (r1) with 'inc r2'
1000$:  jmp     (r1)
        mov     #005202,(pc)    ; will replace jmp (r1) with 'inc r2'
1100$:  jmp     (r1)
        mov     #005202,(pc)    ; will replace jmp (r1) with 'inc r2'
1200$:  jmp     (r1)
;
        hcmpeq  r2,#3           ; check that 'inc r2' was executed
;
        mov     (sp)+,1200$
        mov     (sp)+,1100$
        mov     (sp)+,1000$
        sob     r5,100$
        jmp     9999$
;
1999$:  halt                    ; halt as target for 'jmp (r1)'
;
9999$:  iot                     ; end of test B2.2
;
; Section C: 11/70 specifics =================================================
;
; Test C1:  Implementation differences +++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies that w11 shows 11/70 behavior in cases
;   were J11 and other CPU models show different behavior
;
; Test C1.1 -- Register used as source and changed in dst flow +++++++
;   OPR R,(R)+ : incremented before {J11} or after {70} use as source
;   OPR R,-(R) : decremented before {J11} or after {70} use as source
;
tc0101: mov     #1000$,r4
        mov     r4,(r4)+
        hcmpeq  1000$,#1000$    ; check r4 prior inc stored
        mov     r4,-(r4)
        hcmpeq  1000$,#1000$+2  ; check r4 prior dec stored
        br      9999$
;
1000$:  .word   0
;
9999$:  iot                     ; end of test C1.1
;
; Test C1.2 -- PC used as source +++++++++++++++++++++++++++++++++++++
;    OPR PC,A(R) : store PC+2 {70} or PC+4 {J11}
;
tc0102: mov     #1000$,r4
100$:   mov     pc,0(r4)
        hcmpeq  1000$,#100$+2   ; check pc after fetch stored
        br      9999$
;
1000$:  .word   0
;
9999$:  iot                     ; end of test C1.2
;
; Test C1.3 -- Registers accessible via 177700-1777717 +++++++++++++++
;   CPU access to 177700-177717 (regs) timesout {70,J11} or not {05,10}
;
tc0103: mov     #vhugen,v..iit  ; set iit handler
        clr     v..iit+2        ; pr0 kernel
;
        mov     #1000$,vhustp   ; continuation address
        tst     @#177700        ; should fail
        halt
;
1000$:  mov     #1100$,vhustp   ; continuation address
        tst     @#177716        ; should fail
        halt
;
1100$:  mov     v..iit+2,v..iit ; restore iit handler
;
9999$:  iot                     ; end of test C1.3
;
; END OF ALL TESTS - loop closure ============================================
;
        mov     tstno,r0        ; hack, for easy monitoring ...
        hcmpeq  tstno,#24.      ; all tests done ?
;
        jmp     loop
;
; kernel handlers ============================================================
;
; vhugen - generic handler for expected traps/abort ++++++++++++++++++++++++++
;   the continution address must be written to vhustp
;   execution will reset vhustp to a catcher value
;   --> vhustp must be set for each execution
;
vhugen: add     #4,sp           ; discard vector frame
        mov     vhustp,100$     ; set up return address
        mov     #vhuhlt,vhustp  ; reset stop address by catcher
        jmp     @100$           ; end return to continuation address
100$:   .word   0
vhustp: .word   vhuhlt
vhuhlt: halt
;
        .end    start
