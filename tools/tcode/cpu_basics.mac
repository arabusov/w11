; $Id: cpu_basics.mac 1253 2022-07-12 06:32:22Z mueller $
; SPDX-License-Identifier: GPL-3.0-or-later
; Copyright 2015-2022 by Walter F.J. Mueller <W.F.J.Mueller@gsi.de>
;
; Revision History:
; Date         Rev Version  Comment
; 2022-07-11  1253   1.0    Initial version
; 2015-08-30   710   0.1    First draft
;
; Test CPU basics
;
        .include        |lib/tcode_std_base.mac|
;
; Section A: ccops + flow control bxx, sob, jmp, jsr, rts, mark ==============
;
; Test A1:  ccop + bxx +++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     0 000 000 010 10n zvc NZVC CLx
;     0 000 000 010 11n zvc NZVC SEx
;
;     0 000 000 1bb bbb bbb ---- BR  always
;
;     0 000 001 0bb bbb bbb ---- BNE if Z = 0
;     0 000 001 1bb bbb bbb ---- BEQ if Z = 1
;     0 000 010 0bb bbb bbb ---- BGE if (N xor V) = 0
;     0 000 010 1bb bbb bbb ---- BLT if (N xor V) = 1
;     0 000 011 0bb bbb bbb ---- BGT if (Z or (N xor V)) = 0
;     0 000 011 1bb bbb bbb ---- BLE if (Z or (N xor V)) = 1
;
;     1 000 000 0bb bbb bbb ---- BPL  if N = 0
;     1 000 000 1bb bbb bbb ---- BMI  if N = 1
;     1 000 001 0bb bbb bbb ---- BHI  if (C or Z) = 0
;     1 000 001 1bb bbb bbb ---- BLOS if (C or Z) = 1
;     1 000 010 0bb bbb bbb ---- BVC  if V = 0
;     1 000 010 1bb bbb bbb ---- BVS  if V = 1
;     1 000 011 0bb bbb bbb ---- BCC  if C = 0
;     1 000 011 1bb bbb bbb ---- BCS  if C = 1
;
; Test A1.1 -- ccop + psw ++++++++++++++++++++++++++++++++++++++++++++
;   This test sets and clears all four condition codes and verifies that
;   the psw properly reflects this.
;
ta0101: mov     #cp.psw,r0
        clr     (r0)
;
        ccc                     ; nzvc = 0000
        cmp     (r0),#cp0000
        beq     .+4
        halt
; sec
        ccc
        sec                     ; nzvc = 0001
        cmp     (r0),#cp000c
        beq     .+4
        halt
; sev
        ccc
        sev                     ; nzvc = 0010
        cmp     (r0),#cp00v0
        beq     .+4
        halt
; sez
        ccc
        sez                     ; nzvc = 0100
        cmp     (r0),#cp0z00
        beq     .+4
        halt
; sen
        ccc
        sen                     ; nzvc = 1000
        cmp     (r0),#cpn000
        beq     .+4
        halt
; sen!sec
        ccc
        <sen!sec>               ; nzvc = 1001
        cmp     (r0),#cpn00c
        beq     .+4
        halt
; sez!sev
        ccc
        <sez!sev>               ; nzvc = 1001
        cmp     (r0),#cp0zv0
        beq     .+4
        halt
;
        scc                     ; nzvc = 1111
        cmp     (r0),#cpnzvc
        beq     .+4
        halt
; clc
        scc
        clc                     ; nzvc = 1110
        cmp     (r0),#cpnzv0
        beq     .+4
        halt
; clv
        scc
        clv                     ; nzvc = 1101
        cmp     (r0),#cpnz0c
        beq     .+4
        halt
; clz
        scc
        clz                     ; nzvc = 1011
        cmp     (r0),#cpn0vc
        beq     .+4
        halt
; cln
        scc
        cln                     ; nzvc = 0111
        cmp     (r0),#cp0zvc
        beq     .+4
        halt
; cln!clc
        scc
        <cln!clc>               ; nzvc = 0110
        cmp     (r0),#cp0zv0
        beq     .+4
        halt
; clz!clv
        scc
        <clz!clv>               ; nzvc = 1001
        cmp     (r0),#cpn00c
        beq     .+4
        halt
;
9999$:  iot                     ; end of test A1.1

; Test A1.2 -- ccop + bxx ++++++++++++++++++++++++++++++++++++++++++++
;   This test sets all possible combinations of condition code bits
;   (with cc ops) and verifies the branch instruction response
;   Note: after normal compares N will never be 1 if Z=1 (a number can not
;         zero and negative simultaneously). Thus not all combinations are
;         used in normal code execution. 
;
ta0102: clr     @#cp.psw
        ;
        ; case NZVC = 0000 -- N=0 Z=0 V=0 C=0 ------------------------
        ;
        ccc
        ;
        ;
        bne     1$              ; yes Z=0
        halt
1$:     beq     99$             ; no  Z=1
        ;
2$:     bge     3$              ; yes (N xor V) = 0
        halt
3$:     blt     99$             ; no  (N xor V) = 1
        ;
4$:     bgt     5$              ; yes (Z or (N xor V)) = 0
        halt
5$:     ble     99$             ; no  (Z or (N xor V)) = 1
        ;
6$:     bpl     7$              ; yes N = 0
        halt
7$:     bmi     99$             ; no  N = 1
        ;
8$:     bhi     9$              ; yes (C or Z) = 0
        halt
9$:     blos    99$             ; no  (C or Z) = 1
        ;
10$:    bvc     11$             ; yes V = 0
        halt
11$:    bvs     99$             ; no  V = 1
        ;
12$:    bcc     13$             ; yes C = 0
        halt
13$:    bcs     99$             ; no  C = 1
        ;
14$:    br      100$
99$:    halt
        ;
        ; case NZVC = 0001 -- N=0 Z=0 V=0 C=1 ------------------------
        ;
100$:   ccc
        sec
        ;
        bne     101$            ; yes Z=0
        halt
101$:   beq     199$            ; no  Z=1
        ;
102$:   bge     103$            ; yes (N xor V) = 0
        halt
103$:   blt     199$            ; no  (N xor V) = 1
        ;
104$:   bgt     105$            ; yes (Z or (N xor V)) = 0
        halt
105$:   ble     199$            ; no  (Z or (N xor V)) = 1
        ;
106$:   bpl     107$            ; yes N = 0
        halt
107$:   bmi     199$            ; no  N = 1
        ;
108$:   bhi     199$            ; no  (C or Z) = 0
        ;
109$:   blos    110$            ; yes (C or Z) = 1
        halt
110$:   bvc     111$            ; yes V = 0
        halt
111$:   bvs     199$            ; no  V = 1
        ;
112$:   bcc     199$            ; no  C = 0
        ;
113$:   bcs     114$            ; yes C = 1
        halt
114$:   br      200$
199$:   halt
        ;
        ; case NZVC = 0010 -- N=0 Z=0 V=1 C=0 ------------------------
        ;
200$:   ccc
        sev
        ;
        bne     201$            ; yes Z=0
        halt
201$:   beq     299$            ; no  Z=1
        ;
202$:   bge     299$            ; no  (N xor V) = 0
        ;
203$:   blt     204$            ; yes (N xor V) = 1
        halt
204$:   bgt     299$            ; no  (Z or (N xor V)) = 0
        ;
205$:   ble     206$            ; yes (Z or (N xor V)) = 1
        halt
206$:   bpl     207$            ; yes N = 0
        halt
207$:   bmi     299$            ; no  N = 1
        ;
208$:   bhi     209$            ; yes (C or Z) = 0
        halt
209$:   blos    299$            ; no  (C or Z) = 1
        ;
210$:   bvc     299$            ; no  V = 0
        ;
211$:   bvs     212$            ; yes V = 1
        halt
212$:   bcc     213$            ; yes C = 0
        halt
213$:   bcs     299$            ; no  C = 1
        ;
214$:   br      300$
299$:   halt
        ;
        ; case NZVC = 0011 -- N=0 Z=0 V=1 C=1 ------------------------
        ;
300$:   ccc
        <sev!sec>
        ;
        bne     301$            ; yes Z=0
        halt
301$:   beq     399$            ; no  Z=1
        ;
302$:   bge     399$            ; no  (N xor V) = 0
        ;
303$:   blt     304$            ; yes (N xor V) = 1
        halt
304$:   bgt     399$            ; no  (Z or (N xor V)) = 0
        ;
305$:   ble     306$            ; yes (Z or (N xor V)) = 1
        halt
306$:   bpl     307$            ; yes N = 0
        halt
307$:   bmi     399$            ; no  N = 1
        ;
308$:   bhi     399$            ; no  (C or Z) = 0
        ;
309$:   blos    310$            ; yes (C or Z) = 1
        halt
310$:   bvc     399$            ; no  V = 0
        ;
311$:   bvs     312$            ; yes V = 1
        halt
312$:   bcc     399$            ; no  C = 0
        ;
313$:   bcs     314$            ; yes C = 1
        halt
314$:   br      400$
399$:   halt
        ;
        ; case NZVC = 0100 -- N=0 Z=1 V=0 C=0 ------------------------
        ;
400$:   ccc
        sez
        ;
        bne     499$            ; no  Z=0
        ;
401$:   beq     402$            ; yes Z=1
        halt
402$:   bge     403$            ; yes (N xor V) = 0
        halt
403$:   blt     499$            ; no  (N xor V) = 1
        ;
404$:   bgt     499$            ; no  (Z or (N xor V)) = 0
        ;
405$:   ble     406$            ; yes (Z or (N xor V)) = 1
        halt
406$:   bpl     407$            ; yes N = 0
        halt
407$:   bmi     499$            ; no  N = 1
        ;
408$:   bhi     499$            ; no  (C or Z) = 0
        ;
409$:   blos    410$            ; yes (C or Z) = 1
        halt
410$:   bvc     411$            ; yes V = 0
        halt
411$:   bvs     499$            ; no  V = 1
        ;
412$:   bcc     413$            ; yes C = 0
        halt
413$:   bcs     499$            ; no  C = 1
        ;
414$:   br      500$
499$:   halt
        ;
        ; case NZVC = 0101 -- N=0 Z=1 V=0 C=1 ------------------------
        ;
500$:   ccc
        <sez!sec>
        ;
        bne     599$            ; no  Z=0
        ;
501$:   beq     502$            ; yes Z=1
        halt
502$:   bge     503$            ; yes (N xor V) = 0
        halt
503$:   blt     599$            ; no  (N xor V) = 1
        ;
504$:   bgt     599$            ; no  (Z or (N xor V)) = 0
        ;
505$:   ble     506$            ; yes (Z or (N xor V)) = 1
        halt
506$:   bpl     507$            ; yes N = 0
        halt
507$:   bmi     599$            ; no  N = 1
        ;
508$:   bhi     599$            ; no  (C or Z) = 0
        ;
509$:   blos    510$            ; yes (C or Z) = 1
        halt
510$:   bvc     511$            ; yes V = 0
        halt
511$:   bvs     599$            ; no  V = 1
        ;
512$:   bcc     599$            ; no  C = 0
        ;
513$:   bcs     514$            ; yes C = 1
        halt
514$:   br      600$
599$:   halt
        ;
        ; case NZVC = 0110 -- N=0 Z=1 V=1 C=0 ------------------------
        ;
600$:   ccc
        <sez!sev>
        ;
        bne     699$            ; no  Z=0
        ;
601$:   beq     602$            ; yes Z=1
        halt
602$:   bge     699$            ; no  (N xor V) = 0
        ;
603$:   blt     604$            ; yes (N xor V) = 1
        halt
604$:   bgt     699$            ; no  (Z or (N xor V)) = 0
        ;
605$:   ble     606$            ; yes (Z or (N xor V)) = 1
        halt
606$:   bpl     607$            ; yes N = 0
        halt
607$:   bmi     699$            ; no  N = 1
        ;
608$:   bhi     699$            ; no  (C or Z) = 0
        ;
609$:   blos    610$            ; yes (C or Z) = 1
        halt
610$:   bvc     699$            ; no  V = 0
        ;
611$:   bvs     612$            ; yes V = 1
        halt
612$:   bcc     613$            ; yes C = 0
        halt
613$:   bcs     699$            ; no  C = 1
        ;
614$:   br      700$
699$:   halt
        ;
        ; case NZVC = 0111 -- N=0 Z=1 V=1 C=1 ------------------------
        ;
700$:   scc
        cln
        ;
        bne     799$            ; no  Z=0
        ;
701$:   beq     702$            ; yes Z=1
        halt
702$:   bge     799$            ; no  (N xor V) = 0
        ;
703$:   blt     704$            ; yes (N xor V) = 1
        halt
704$:   bgt     799$            ; no  (Z or (N xor V)) = 0
        ;
705$:   ble     706$            ; yes (Z or (N xor V)) = 1
        halt
706$:   bpl     707$            ; yes N = 0
        halt
707$:   bmi     799$            ; no  N = 1
        ;
708$:   bhi     799$            ; no  (C or Z) = 0
        ;
709$:   blos    710$            ; yes (C or Z) = 1
        halt
710$:   bvc     799$            ; no  V = 0
        ;
711$:   bvs     712$            ; yes V = 1
        halt
712$:   bcc     799$            ; no  C = 0
        ;
713$:   bcs     714$            ; yes C = 1
        halt
714$:   br      1000$
799$:   halt
        ;
        ; case NZVC = 1000 -- N=1 Z=0 V=0 C=0 ------------------------
        ;
1000$:  ccc
        sen
        ;
        bne     1001$           ; yes Z=0
        halt
1001$:  beq     1099$           ; no  Z=1
        ;
1002$:  bge     1099$           ; no  (N xor V) = 0
        ;
1003$:  blt     1004$           ; yes (N xor V) = 1
        halt
1004$:  bgt     1099$           ; no  (Z or (N xor V)) = 0
        ;
1005$:  ble     1006$           ; yes (Z or (N xor V)) = 1
        halt
1006$:  bpl     1099$           ; no  N = 0
        ;
1007$:  bmi     1008$           ; yes N = 1
        halt
1008$:  bhi     1009$           ; yes (C or Z) = 0
        halt
1009$:  blos    1099$           ; no  (C or Z) = 1
        ;
1010$:  bvc     1011$           ; yes V = 0
        halt
1011$:  bvs     1099$           ; no  V = 1
        ;
1012$:  bcc     1013$           ; yes C = 0
        halt
1013$:  bcs     1099$           ; no  C = 1
        ;
1014$:  br      1100$
1099$:  halt
        ;
        ; case NZVC = 1001 -- N=1 Z=0 V=0 C=1 ------------------------
        ;
1100$:  ccc
        <sen!sec>
        ;
        bne     1101$           ; yes Z=0
        halt
1101$:  beq     1199$           ; no  Z=1
        ;
1102$:  bge     1199$           ; no  (N xor V) = 0
        ;
1103$:  blt     1104$           ; yes (N xor V) = 1
        halt
1104$:  bgt     1199$           ; no  (Z or (N xor V)) = 0
        ;
1105$:  ble     1106$           ; yes (Z or (N xor V)) = 1
        halt
1106$:  bpl     1199$           ; no  N = 0
        ;
1107$:  bmi     1108$           ; yes N = 1
        halt
1108$:  bhi     1199$           ; no  (C or Z) = 0
        ;
1109$:  blos    1110$           ; yes (C or Z) = 1
        halt
1110$:  bvc     1111$           ; yes V = 0
        halt
1111$:  bvs     1199$           ; no  V = 1
        ;
1112$:  bcc     1199$           ; no  C = 0
        ;
1113$:  bcs     1114$           ; yes C = 1
        halt
1114$:  br      1200$
1199$:  halt
        ;
        ; case NZVC = 1010 -- N=1 Z=0 V=1 C=0 ------------------------
        ;
1200$:  ccc
        <sen!sev>
        ;
        bne     1201$           ; yes Z=0
        halt
1201$:  beq     1299$           ; no  Z=1
        ;
1202$:  bge     1203$           ; yes (N xor V) = 0
        halt
1203$:  blt     1299$           ; no  (N xor V) = 1
        ;
1204$:  bgt     1205$           ; yes (Z or (N xor V)) = 0
        halt
1205$:  ble     1299$           ; no  (Z or (N xor V)) = 1
        ;
1206$:  bpl     1299$           ; no  N = 0
        ;
1207$:  bmi     1208$           ; yes N = 1
        halt
1208$:  bhi     1209$           ; yes (C or Z) = 0
        halt
1209$:  blos    1299$           ; no  (C or Z) = 1
        ;
1210$:  bvc     1299$           ; no  V = 0
        ;
1211$:  bvs     1212$           ; yes V = 1
        halt
1212$:  bcc     1213$           ; yes C = 0
        halt
1213$:  bcs     1299$           ; no  C = 1
        ;
1214$:  br      1300$
1299$:  halt
        ;
        ; case NZVC = 1011 -- N=1 Z=0 V=1 C=1 ------------------------
        ;
1300$:  scc
        clz
        ;
        bne     1301$           ; yes Z=0
        halt
1301$:  beq     1399$           ; no  Z=1
        ;
1302$:  bge     1303$           ; yes (N xor V) = 0
        halt
1303$:  blt     1399$           ; no  (N xor V) = 1
        ;
1304$:  bgt     1305$           ; yes (Z or (N xor V)) = 0
        halt
1305$:  ble     1399$           ; no  (Z or (N xor V)) = 1
        ;
1306$:  bpl     1399$           ; no  N = 0
        ;
1307$:  bmi     1308$           ; yes N = 1
        halt
1308$:  bhi     1399$           ; no  (C or Z) = 0
        ;
1309$:  blos    1310$           ; yes (C or Z) = 1
        halt
1310$:  bvc     1399$           ; no  V = 0
        ;
1311$:  bvs     1312$           ; yes V = 1
        halt
1312$:  bcc     1399$           ; no  C = 0
        ;
1313$:  bcs     1314$           ; yes C = 1
        halt
1314$:  br      1400$
1399$:  halt
        ;
        ; case NZVC = 1100 -- N=1 Z=1 V=0 C=0 ------------------------
        ;
1400$:  ccc
        <sen!sez>
        ;
        bne     1499$           ; no  Z=0
        ;
1401$:  beq     1402$           ; yes Z=1
        halt
1402$:  bge     1499$           ; no  (N xor V) = 0
        ;
1403$:  blt     1404$           ; yes (N xor V) = 1
        halt
1404$:  bgt     1499$           ; no  (Z or (N xor V)) = 0
        ;
1405$:  ble     1406$           ; yes (Z or (N xor V)) = 1
        halt
1406$:  bpl     1499$           ; no  N = 0
        ;
1407$:  bmi     1408$           ; yes N = 1
        halt
1408$:  bhi     1499$           ; no  (C or Z) = 0
        ;
1409$:  blos    1410$           ; yes (C or Z) = 1
        halt
1410$:  bvc     1411$           ; yes V = 0
        halt
1411$:  bvs     1499$           ; no  V = 1
        ;
1412$:  bcc     1413$           ; yes C = 0
        halt
1413$:  bcs     1499$           ; no  C = 1
        ;
1414$:  br      1500$
1499$:  halt
        ;
        ; case NZVC = 1101 -- N=1 Z=1 V=0 C=1 ------------------------
        ;
1500$:  scc
        clv
        ;
        bne     1599$           ; no  Z=0
        ;
1501$:  beq     1502$           ; yes Z=1
        halt
1502$:  bge     1599$           ; no  (N xor V) = 0
        ;
1503$:  blt     1504$           ; yes (N xor V) = 1
        halt
1504$:  bgt     1599$           ; no  (Z or (N xor V)) = 0
        ;
1505$:  ble     1506$           ; yes (Z or (N xor V)) = 1
        halt
1506$:  bpl     1599$           ; no  N = 0
        ;
1507$:  bmi     1508$           ; yes N = 1
        halt
1508$:  bhi     1599$           ; no  (C or Z) = 0
        ;
1509$:  blos    1510$           ; yes (C or Z) = 1
        halt
1510$:  bvc     1511$           ; yes V = 0
        halt
1511$:  bvs     1599$           ; no  V = 1
        ;
1512$:  bcc     1599$           ; no  C = 0
        ;
1513$:  bcs     1514$           ; yes C = 1
        halt
1514$:  br      1600$
1599$:  halt
        ;
        ; case NZVC = 1110 -- N=1 Z=1 V=1 C=0 ------------------------
        ;
1600$:  scc
        clc
        ;
        bne     1699$           ; no  Z=0
        ;
1601$:  beq     1602$           ; yes Z=1
        halt
1602$:  bge     1603$           ; yes (N xor V) = 0
        halt
1603$:  blt     1699$           ; no  (N xor V) = 1
        ;
1604$:  bgt     1699$           ; no  (Z or (N xor V)) = 0
        ;
1605$:  ble     1606$           ; yes (Z or (N xor V)) = 1
        halt
1606$:  bpl     1699$           ; no  N = 0
        ;
1607$:  bmi     1608$           ; yes N = 1
        halt
1608$:  bhi     1699$           ; no  (C or Z) = 0
        ;
1609$:  blos    1610$           ; yes (C or Z) = 1
        halt
1610$:  bvc     1699$           ; no  V = 0
        ;
1611$:  bvs     1612$           ; yes V = 1
        halt
1612$:  bcc     1613$           ; yes C = 0
        halt
1613$:  bcs     1699$           ; no  C = 1
        ;
1614$:  br      1700$
1699$:  halt
        ;
        ; case NZVC = 1111 -- N=1 Z=1 V=1 C=1 ------------------------
        ;
1700$:  scc
        ;
        bne     1799$           ; no  Z=0
        ;
1701$:  beq     1702$           ; yes Z=1
        halt
1702$:  bge     1703$           ; yes (N xor V) = 0
        halt
1703$:  blt     1799$           ; no  (N xor V) = 1
        ;
1704$:  bgt     1799$           ; no  (Z or (N xor V)) = 0
        ;
1705$:  ble     1706$           ; yes (Z or (N xor V)) = 1
        halt
1706$:  bpl     1799$           ; no  N = 0
        ;
1707$:  bmi     1708$           ; yes N = 1
        halt
1708$:  bhi     1799$           ; no  (C or Z) = 0
        ;
1709$:  blos    1710$           ; yes (C or Z) = 1
        halt
1710$:  bvc     1799$           ; no  V = 0
        ;
1711$:  bvs     1712$           ; yes V = 1
        halt
1712$:  bcc     1799$           ; no  C = 0
        ;
1713$:  bcs     1714$           ; yes C = 1
        ;
1714$:  br      9999$
1799$:  halt
        ;
;
9999$:  iot                     ; end of test A1.2
;
; Test A2 -- sob +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     0 111 111 rrr bbb bbb ---- SOB
;
; Test A2.1 -- sob +++++++++++++++++++++++++++++++++++++++++++++++++++
;   check that SOB
;     a. decrements register
;     b. does not change cc
;     c. only falls through when register decremented to zero
;
ta0201: mov     #cp.psw,r5
        clr     (r5)
        mov     #3,r0           ; setup loop count
        ccc                     ; nzvc = 0000
        br      11$             ; branch to 1st SOB
;
10$:    cmp     (r5),#cp0000    ; cc still 0000 ?
        beq     .+4
        halt
        cmp     r0,#2           ; counter dec-ed ?
        beq     .+4
        halt
        scc                     ; now nzvc = 1111
        br      21$             ; branch to 2nd SOB
;
11$:    sob     r0,10$          ; 1st SOB (r0=3)
        halt                    ; should not fall through
;
20$:    cmp     (r5),#cpnzvc    ; cc still 1111 ?
        beq     .+4
        halt
        cmp     r0,#1          ; counter dec-ed ?
        beq     .+4
        halt
        ccc
        <sen!sez>               ; now nzvc = 1100
        br      31$             ; branch to 3rd SOB
;
21$:    sob     r0,20$          ; 2nd SOB (r0=2)
        halt                    ; should not fall through
;
30$:    halt                    ; should not branch now !
31$:    sob     r0,30$          ; 3rd SOB (r0=1 -> fall through)
        cmp     (r5),#cpnz00    ; cc still 1100 ?
        beq     .+4
        halt
        tst     r0              ; counter dec-ed ?
        beq     .+4
        halt
;
; finally a typical simple SOB loop
;
        mov     #2,r0
        clr     r1
100$:   inc     r1
        sob     r0,100$
;
        tst     r0
        beq     .+4
        halt
        cmp     r1,#2
        beq     .+4
        halt
;
9999$:  iot                     ; end of test A2.1
;
; Test A3 -- jmp +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     0 000 000 001 ddd ddd ---- JMP (mode /= R !!)
;
; Test A3.1 -- jmp + dsta +++++++++++++++++++++++++++++++++++++++++++++
;   check that JMP works for all modes
;
ta0301: mov     #10$,r2
        jmp     (r2)            ; mode = 1,reg
        halt
;
10$:    mov     #20$,r2
        jmp     (r2)+           ; mode = 2,reg
        halt
20$:    cmp     r2,#20$+2
        beq     .+4
        halt
;
        mov     #40$+2,r2
        jmp     -(r2)           ; mode = 4,reg
        halt
40$:    cmp     r2,#40$
        beq     .+4
        halt
;
        mov     #60$-10,r2
        jmp     10(r2)          ; mode = 6,reg
;
60$:    jmp     67$             ; mode = 6,pc  (rel)
        halt
;
67$:    jmp     @#37$           ; mode = 3,pc  (abs)
        halt
;
37$:    mov     #1030$,r3
        jmp     @(r3)+          ; mode = 3,reg
        halt
30$:    cmp     r3,#1030$+2
        beq     .+4
        halt
;
        mov     #1050$+2,r3
        jmp     @-(r3)          ; mode = 5,reg
        halt
50$:    cmp     r3,#1050$
        beq     .+4
        halt
;
        mov     #1070$-20,r3
        jmp     @20(r3)         ; mode = 7,reg
        halt
;
70$:    jmp     @1077$          ; mode = 7,pc  (ind)
        halt
;
77$:    br      9999$
;
1030$:  .word   30$
1050$:  .word   50$
1070$:  .word   70$
1077$:  .word   77$
;        
9999$:  iot                     ; end of test A3.1
;
; Test A3.2 -- jmp + cc +++++++++++++++++++++++++++++++++++++++++++++++
;   check that JMP doesnt change cc
;
ta0302: mov     #cp.psw,r5
        clr     (r5)
;
        ccc                     ; nzvc = 0000
        jmp     1$
        halt
1$:     cmp     (r5),#cp0000    ; cc still 0000 ?
        beq     .+4
        halt
;
        scc                     ; nzvc = 1111
        jmp     @1002$
        halt
2$:     cmp     (r5),#cpnzvc    ; cc still 1111 ?
        beq     .+4
        halt
        br      9999$        
;
1002$:  .word   2$
;
9999$:  iot                     ; end of test A3.2
;
; Section B: unary instructions (word) =======================================
;
        jmp     tb0101
;
; test driver for unary instruction tests
;
top1wr: mov     (r5),101$       ; setup cc setter
        mov     2(r5),102$      ; setup instruction
        mov     4(r5),r4        ; setup expect data pointer
        mov     6(r5),r3        ; setup expect end
        mov     #cp.psw,r2
;
100$:   mov     (r4)+,r1        ; setup dst
        ccc                     ; clear cc
101$:   nop                     ; REPLACED with cc setter
102$:   nop                     ; REPLACED with instruction, e.g. inc r1
        cmp     (r2),(r4)+      ; check psw
        beq     .+4
        halt
        cmp     r1,(r4)+        ; check new dst
        beq     .+4
        halt
        cmp     r4,r3           ; more to do ?
        blo     100$
        rts     pc
;
top1wm: mov     (r5),101$       ; setup cc setter
        mov     2(r5),102$      ; setup instruction
        mov     4(r5),r4        ; setup expect data pointer
        mov     6(r5),r3        ; setup expect end
        mov     #200$,r1        ; setup dst pointer
        mov     #cp.psw,r2
;
100$:   mov     (r4)+,(r1)      ; setup old dst
        ccc                     ; clear cc
101$:   nop                     ; REPLACED with cc setter
102$:   nop                     ; REPLACED with instruction, e.g. inc (r1)
        cmp     (r2),(r4)+      ; check psw
        beq     .+4
        halt
        cmp     (r1),(r4)+      ; check new dst
        beq     .+4
        halt
        cmp     r4,r3           ; more to do ?
        blo     100$
        rts     pc
;
200$:   .word   0
;
; Test B1 -- inc +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     0 000 101 010 ddd ddd NZV- INC
;
; Test B1.1 -- inc instruction +++++++++++++++++++++++++++++++++++++++
;
tb0101: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests (with ccc)
        jsr     pc,top1wr
        mov     #2000$,r5       ; mem mode tests (with scc)
        jsr     pc,top1wm
        jmp     9999$
;
1000$:  ccc                     ; c=0
        inc     r1              ; inc preserves c, so stays 0
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
1010$:  .word   000000, cp0000, 000001
        .word   000001, cp0000, 000002
        .word   077776, cp0000, 077777
        .word   077777, cpn0v0, 100000
        .word   100000, cpn000, 100001
        .word   100001, cpn000, 100002
        .word   177776, cpn000, 177777
        .word   177777, cp0z00, 000000
1011$:
;
2000$:  scc                     ; c=1
        inc     (r1)            ; inc preserves c, so stays 1
        .word   2010$
        .word   2011$
;
;               olddst     psw  newdst
2010$:  .word   000000, cp000c, 000001
        .word   000001, cp000c, 000002
        .word   077776, cp000c, 077777
        .word   077777, cpn0vc, 100000
        .word   100000, cpn00c, 100001
        .word   100001, cpn00c, 100002
        .word   177776, cpn00c, 177777
        .word   177777, cp0z0c, 000000
2011$:
;
9999$:  iot                     ; end of test B1.1
;
; Test B2 -- dec +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     0 000 101 011 ddd ddd NZV- DEC
;
; Test B2.1 -- dec instruction +++++++++++++++++++++++++++++++++++++++
;
tb0201: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests (with ccc)
        jsr     pc,top1wr
        mov     #2000$,r5       ; mem mode tests (with scc)
        jsr     pc,top1wm
        jmp     9999$
;
1000$:  ccc                     ; c=0
        dec     r1              ; dec preserves c, so stays 0
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
1010$:  .word   000000, cpn000, 177777
        .word   000001, cp0z00, 000000
        .word   077776, cp0000, 077775
        .word   077777, cp0000, 077776
        .word   100000, cp00v0, 077777
        .word   100001, cpn000, 100000
        .word   177776, cpn000, 177775
        .word   177777, cpn000, 177776
1011$:
;
2000$:  scc                     ; c=1
        dec     (r1)            ; dec preserves c, so stays 1
        .word   2010$
        .word   2011$
;
;               olddst     psw  newdst
2010$:  .word   000000, cpn00c, 177777
        .word   000001, cp0z0c, 000000
        .word   077776, cp000c, 077775
        .word   077777, cp000c, 077776
        .word   100000, cp00vc, 077777
        .word   100001, cpn00c, 100000
        .word   177776, cpn00c, 177775
        .word   177777, cpn00c, 177776 
2011$:
;
9999$:  iot                     ; end of test B2.1
;
; Test B3 -- com +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     0 000 101 001 ddd ddd NZ01 COM
;
; Test B3.1 -- com instruction +++++++++++++++++++++++++++++++++++++++
;
tb0301: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests (with ccc)
        jsr     pc,top1wr
        mov     #2000$,r5       ; mem mode tests (with scc)
        jsr     pc,top1wm
        jmp     9999$
;
1000$:  ccc
        com     r1
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
1010$:  .word   000000, cpn00c, 177777
        .word   000001, cpn00c, 177776
        .word   077777, cpn00c, 100000
        .word   100000, cp000c, 077777
        .word   177777, cp0z0c, 000000
1011$:
;
2000$:  scc
        com     (r1)
        .word   1010$
        .word   1011$
;
9999$:  iot                     ; end of test B3.1
;
; Test B4 -- neg +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     0 000 101 100 ddd ddd NZVC NEG
;
; Test B4.1 -- neg instruction +++++++++++++++++++++++++++++++++++++++
;
tb0401: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests (with ccc)
        jsr     pc,top1wr
        mov     #2000$,r5       ; mem mode tests (with scc)
        jsr     pc,top1wm
        jmp     9999$
;
1000$:  ccc
        neg     r1
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
1010$:  .word   000000, cp0z00, 000000
        .word   000001, cpn00c, 177777
        .word   077777, cpn00c, 100001
        .word   100000, cpn0vc, 100000
        .word   177777, cp000c, 000001
1011$:
;
2000$:  scc
        neg     (r1)
        .word   1010$
        .word   1011$
;
9999$:  iot                     ; end of test B4.1
;
; Test B5 -- adc +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     0 000 101 101 ddd ddd NZVC ADC
;
; Test B5.1 -- adc instruction +++++++++++++++++++++++++++++++++++++++
;
tb0501: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests (with ccc; C=0)
        jsr     pc,top1wr
        mov     #2000$,r5       ; mem mode tests (with scc; C=1)
        jsr     pc,top1wm
        jmp     9999$
;
1000$:  ccc                     ; c=0
        adc     r1
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
1010$:  .word   000000, cp0z00, 000000
        .word   000001, cp0000, 000001
        .word   077777, cp0000, 077777
        .word   100000, cpn000, 100000
        .word   177777, cpn000, 177777
1011$:
;
2000$:  scc                     ; c=1
        adc     (r1)
        .word   2010$
        .word   2011$
;
;               olddst  psw     newdst
2010$:  .word   000000, cp0000, 000001
        .word   000001, cp0000, 000002
        .word   077777, cpn0v0, 100000
        .word   100000, cpn000, 100001
        .word   177777, cp0z0c, 000000
2011$:
;
9999$:  iot                     ; end of test B5.1
;
; Test B6 -- sbc +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     0 000 101 110 ddd ddd NZVC SBC
;
; Test B6.1 -- sbc instruction +++++++++++++++++++++++++++++++++++++++
;
tb0601: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests (with ccc; C=0)
        jsr     pc,top1wr
        mov     #2000$,r5       ; mem mode tests (with scc; C=1)
        jsr     pc,top1wm
        jmp     9999$
;
1000$:  ccc                     ; c=0
        sbc     r1
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
1010$:  .word   000000, cp0z00, 000000
        .word   000001, cp0000, 000001
        .word   077777, cp0000, 077777
        .word   100000, cpn000, 100000
        .word   177777, cpn000, 177777
1011$:
;
2000$:  scc                     ; c=1
        sbc     (r1)
        .word   2010$
        .word   2011$
;
;               olddst  psw     newdst
2010$:  .word   000000, cpn00c, 177777
        .word   000001, cp0z00, 000000
        .word   077777, cp0000, 077776
        .word   100000, cp00v0, 077777
        .word   177777, cpn000, 177776
2011$:
;
9999$:  iot                     ; end of test B6.1
;
; Test B7 -- tst +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     0 000 101 111 ddd ddd NZ00 TST
;
; Test B7.1 -- tst instruction +++++++++++++++++++++++++++++++++++++++
;
tb0701: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests (with ccc)
        jsr     pc,top1wr
        mov     #2000$,r5       ; mem mode tests (with scc)
        jsr     pc,top1wm
        jmp     9999$
;
1000$:  ccc
        tst     r1
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
1010$:  .word   000000, cp0z00, 000000
        .word   000001, cp0000, 000001
        .word   077777, cp0000, 077777
        .word   100000, cpn000, 100000
        .word   177777, cpn000, 177777
1011$:
;
2000$:  scc
        tst     (r1)
        .word   1010$
        .word   1011$
;
9999$:  iot                     ; end of test B7.1
;
; Test B8 -- ror +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     0 000 110 000 ddd ddd NZVC ROR
;
; Test B8.1 -- ror instruction +++++++++++++++++++++++++++++++++++++++
;
tb0801: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests (with ccc; C=0)
        jsr     pc,top1wr
        mov     #2000$,r5       ; mem mode tests (with scc; C=1)
        jsr     pc,top1wm
        jmp     9999$
;
1000$:  ccc                     ; c=0
        ror     r1
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
1010$:  .word   000000, cp0z00, 000000
        .word   000001, cp0zvc, 000000
        .word   100000, cp0000, 040000
        .word   000100, cp0000, 000040
        .word   000101, cp00vc, 000040
        .word   040100, cp0000, 020040
        .word   100100, cp0000, 040040
1011$:
;
2000$:  scc                     ; c=1
        ror     (r1)
        .word   2010$
        .word   2011$
;
;               olddst  psw     newdst
2010$:  .word   000000, cpn0v0, 100000
        .word   000001, cpn00c, 100000
        .word   100000, cpn0v0, 140000
        .word   000100, cpn0v0, 100040
        .word   000101, cpn00c, 100040
        .word   040100, cpn0v0, 120040
        .word   100100, cpn0v0, 140040
2011$:
;
;               olddst  psw     newdst
;
9999$:  iot                     ; end of test B8.1
;
; Test B9 -- rol +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     0 000 110 001 ddd ddd NZVC ROL
;
; Test B9.1 -- rol instruction +++++++++++++++++++++++++++++++++++++++
;
tb0901: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests (with ccc; C=0)
        jsr     pc,top1wr
        mov     #2000$,r5       ; mem mode tests (with scc; C=1)
        jsr     pc,top1wm
        jmp     9999$
;
1000$:  ccc                     ; c=0
        rol     r1
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
1010$:  .word   000000, cp0z00, 000000
        .word   000001, cp0000, 000002
        .word   100000, cp0zvc, 000000
        .word   000100, cp0000, 000200
        .word   000101, cp0000, 000202
        .word   040100, cpn0v0, 100200
        .word   100100, cp00vc, 000200
1011$:
;
2000$:  scc                     ; c=1
        rol     (r1)
        .word   2010$
        .word   2011$
;
;               olddst  psw     newdst
2010$:  .word   000000, cp0000, 000001
        .word   000001, cp0000, 000003
        .word   100000, cp00vc, 000001
        .word   000100, cp0000, 000201
        .word   000101, cp0000, 000203
        .word   040100, cpn0v0, 100201
        .word   100100, cp00vc, 000201
2011$:
;
;               olddst  psw     newdst
;
9999$:  iot                     ; end of test B9.1
;
; Test B10 -- asr ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     0 000 110 010 ddd ddd NZVC ASR
;
; Test B10.1 -- asr instruction ++++++++++++++++++++++++++++++++++++++
;
tb1001: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests (with ccc)
        jsr     pc,top1wr
        mov     #2000$,r5       ; mem mode tests (with scc)
        jsr     pc,top1wm
        jmp     9999$
;
1000$:  ccc
        asr     r1
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
1010$:  .word   000000, cp0z00, 000000
        .word   000001, cp0zvc, 000000
        .word   100000, cpn0v0, 140000
        .word   000100, cp0000, 000040
        .word   000101, cp00vc, 000040
        .word   040100, cp0000, 020040
        .word   100100, cpn0v0, 140040
1011$:
;
2000$:  scc
        asr     (r1)
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
;
9999$:  iot                     ; end of test B10.1
;
; Test B11 -- asl ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     0 000 110 011 ddd ddd NZVC ASL
;
; Test B11.1 -- asl instruction ++++++++++++++++++++++++++++++++++++++
;
tb1101: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests (with ccc)
        jsr     pc,top1wr
        mov     #2000$,r5       ; mem mode tests (with scc)
        jsr     pc,top1wm
        jmp     9999$
;
1000$:  ccc
        asl     r1
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
1010$:  .word   000000, cp0z00, 000000
        .word   000001, cp0000, 000002
        .word   100000, cp0zvc, 000000
        .word   000100, cp0000, 000200
        .word   000101, cp0000, 000202
        .word   040100, cpn0v0, 100200
        .word   100100, cp00vc, 000200
1011$:
;
2000$:  scc
        asl     (r1)
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
;
9999$:  iot                     ; end of test B11.1
;
; Test B12 -- clr ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     0 000 101 000 ddd ddd 0100 CLR
;
; Test B12.1 -- clr instruction ++++++++++++++++++++++++++++++++++++++
;
tb1201: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests (with ccc)
        jsr     pc,top1wr
        mov     #2000$,r5       ; mem mode tests (with scc)
        jsr     pc,top1wm
        jmp     9999$
;
1000$:  ccc
        clr     r1
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
1010$:  .word   000000, cp0z00, 000000
        .word   177777, cp0z00, 000000
1011$:
;
2000$:  scc                     ; c=1
        clr     (r1)
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
;
9999$:  iot                     ; end of test B12.1
;
; Test B13 -- sxt ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     0 000 110 111 ddd ddd -Z0- SXT
;
; Test B13.1 -- sxt instruction ++++++++++++++++++++++++++++++++++++++
;
tb1301: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests (with ccc; N=0)
        jsr     pc,top1wr
        mov     #2000$,r5       ; mem mode tests (with scc; N=1)
        jsr     pc,top1wm
        jmp     9999$
;
1000$:  ccc                     ; n=0
        sxt     r1
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
1010$:  .word   000000, cp0z00, 000000
        .word   177777, cp0z00, 000000
1011$:
;
2000$:  scc                     ; n=1
        sxt     (r1)
        .word   2010$
        .word   2011$
;
;               olddst  psw     newdst
2010$:  .word   000000, cpn00c, 177777
        .word   177777, cpn00c, 177777
2011$:
;
;               olddst  psw     newdst
;
9999$:  iot                     ; end of test B13.1
;
; Test B14 -- swab +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     0 000 000 011 ddd ddd NZ00 SWAB
;
; Test B14.1 -- swab instruction +++++++++++++++++++++++++++++++++++++
;
tb1401: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests (with ccc)
        jsr     pc,top1wr
        mov     #2000$,r5       ; mem mode tests (with scc)
        jsr     pc,top1wm
        jmp     9999$
;
1000$:  ccc
        swab    r1
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
1010$:  .word   000000, cp0z00, 000000
        .word   000001, cp0z00, 000400
        .word   000200, cp0z00, 100000
        .word   000400, cp0000, 000001
        .word   100000, cpn000, 000200
        .word   000401, cp0000, 000401
        .word   000600, cp0000, 100001
        .word   100001, cpn000, 000600
        .word   100200, cpn000, 100200
1011$:
;
2000$:  scc
        swab    (r1)
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
;
9999$:  iot                     ; end of test B14.1
;
; Section C: binary instructions (word) ======================================
;
        jmp     tc0101
;
; test driver for binary instruction tests
;
top2wr: mov     (r5),101$       ; setup cc setter
        mov     2(r5),102$      ; setup instruction
        mov     4(r5),r4        ; setup expect data pointer
        mov     6(r5),r3        ; setup expect end
        mov     #cp.psw,r2
;
100$:   mov     (r4)+,r0        ; setup src
        mov     (r4)+,r1        ; setup old dst
        ccc                     ; clear cc
101$:   nop                     ; REPLACED with cc setter
102$:   nop                     ; REPLACED with instruction, e.g. add r0,r1
        cmp     (r2),(r4)+      ; check psw
        beq     .+4
        halt
        cmp     r1,(r4)+        ; check new dst
        beq     .+4
        halt
        cmp     r4,r3           ; more to do ?
        blo     100$
        rts     pc
;
top2wm: mov     (r5),101$       ; setup cc setter
        mov     2(r5),102$      ; setup instruction
        mov     4(r5),r4        ; setup expect data pointer
        mov     6(r5),r3        ; setup expect end
        mov     #200$,r0        ; setup src pointer
        mov     #300$,r1        ; setup dst pointer
        mov     #cp.psw,r2
;
100$:   mov     (r4)+,(r0)      ; setup src
        mov     (r4)+,(r1)      ; setup old dst
        ccc                     ; clear cc
101$:   nop                     ; REPLACED with cc setter
102$:   nop                     ; REPLACED with instruction, e.g. add (r0),(r1)
        cmp     (r2),(r4)+      ; check psw
        beq     .+4
        halt
        cmp     (r1),(r4)+      ; check new dst
        beq     .+4
        halt
        cmp     r4,r3           ; more to do ?
        blo     100$
        rts     pc
;
200$:   .word   0
300$:   .word   0
;
; Test C1 -- add +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     0 110 sss sss ddd ddd NZVC ADD
;
; Test C1.1 -- add instruction +++++++++++++++++++++++++++++++++++++++
;
tc0101: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests (with ccc)
        jsr     pc,top2wr
        mov     #2000$,r5       ; mem mode tests (with scc)
        jsr     pc,top2wm
        jmp     9999$
;
1000$:  ccc
        add     r0,r1
        .word   1010$
        .word   1011$
;
;                  src  olddst     psw  newdst
1010$:  .word   000000, 000000, cp0z00, 000000
        .word   000001, 000000, cp0000, 000001
        .word   077777, 000000, cp0000, 077777
        .word   100000, 000000, cpn000, 100000
        .word   100001, 000000, cpn000, 100001
        .word   177777, 000000, cpn000, 177777

        .word   000000, 000001, cp0000, 000001
        .word   000001, 000001, cp0000, 000002
        .word   077776, 000001, cp0000, 077777
        .word   077777, 000001, cpn0v0, 100000
        .word   100000, 000001, cpn000, 100001
        .word   100001, 000001, cpn000, 100002
        .word   177776, 000001, cpn000, 177777
        .word   177777, 000001, cp0z0c, 000000

        .word   000001, 077776, cp0000, 077777
        .word   000002, 077776, cpn0v0, 100000
        .word   077777, 077776, cpn0v0, 177775
        .word   100000, 077776, cpn000, 177776
        .word   100001, 077776, cpn000, 177777
        .word   100002, 077776, cp0z0c, 000000
        .word   100003, 077776, cp000c, 000001
        .word   177776, 077776, cp000c, 077774
        .word   177777, 077776, cp000c, 077775

        .word   000001, 077777, cpn0v0, 100000
        .word   000002, 077777, cpn0v0, 100001
        .word   077777, 077777, cpn0v0, 177776
        .word   100000, 077777, cpn000, 177777
        .word   100001, 077777, cp0z0c, 000000
        .word   100002, 077777, cp000c, 000001
        .word   177776, 077777, cp000c, 077775
        .word   177777, 077777, cp000c, 077776

        .word   000001, 100000, cpn000, 100001
        .word   000002, 100000, cpn000, 100002
        .word   077777, 100000, cpn000, 177777
        .word   100000, 100000, cp0zvc, 000000
        .word   100001, 100000, cp00vc, 000001
        .word   100002, 100000, cp00vc, 000002
        .word   177776, 100000, cp00vc, 077776
        .word   177777, 100000, cp00vc, 077777

        .word   000001, 100001, cpn000, 100002
        .word   000002, 100001, cpn000, 100003
        .word   077777, 100001, cp0z0c, 000000
        .word   100000, 100001, cp00vc, 000001
        .word   100001, 100001, cp00vc, 000002
        .word   177776, 100001, cp00vc, 077777
        .word   177777, 100001, cpn00c, 100000

        .word   000001, 177776, cpn000, 177777
        .word   000002, 177776, cp0z0c, 000000
        .word   077777, 177776, cp000c, 077775
        .word   100000, 177776, cp00vc, 077776
        .word   100001, 177776, cp00vc, 077777
        .word   100002, 177776, cpn00c, 100000
        .word   177776, 177776, cpn00c, 177774
        .word   177777, 177776, cpn00c, 177775

        .word   000001, 177777, cp0z0c, 000000
        .word   000002, 177777, cp000c, 000001
        .word   077777, 177777, cp000c, 077776
        .word   100000, 177777, cp00vc, 077777
        .word   100001, 177777, cpn00c, 100000
        .word   100002, 177777, cpn00c, 100001
        .word   177776, 177777, cpn00c, 177775
        .word   177777, 177777, cpn00c, 177776
1011$:
;
2000$:  scc
        add     (r0),(r1)
        .word   1010$
        .word   1011$
;
9999$:  iot                     ; end of test C1.1
;
; Test C2 -- sub +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     1 110 sss sss ddd ddd NZVC SUB
;
; Test C2.1 -- sub instruction +++++++++++++++++++++++++++++++++++++++
;
tc0201: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests (with ccc)
        jsr     pc,top2wr
        mov     #2000$,r5       ; mem mode tests (with scc)
        jsr     pc,top2wm
        jmp     9999$
;
1000$:  ccc
        sub     r0,r1
        .word   1010$
        .word   1011$
;
;                  src  olddst     psw  newdst
1010$:  .word   000000, 000000, cp0z00, 000000
        .word   000001, 000000, cpn00c, 177777
        .word   077777, 000000, cpn00c, 100001
        .word   100000, 000000, cpn0vc, 100000
        .word   100001, 000000, cp000c, 077777
        .word   177777, 000000, cp000c, 000001

        .word   000000, 000001, cp0000, 000001
        .word   000001, 000001, cp0z00, 000000
        .word   077777, 000001, cpn00c, 100002
        .word   100000, 000001, cpn0vc, 100001
        .word   100001, 000001, cpn0vc, 100000
        .word   100002, 000001, cp000c, 077777
        .word   177776, 000001, cp000c, 000003
        .word   177777, 000001, cp000c, 000002

        .word   000001, 077776, cp0000, 077775
        .word   077775, 077776, cp0000, 000001
        .word   077776, 077776, cp0z00, 000000
        .word   077777, 077776, cpn00c, 177777
        .word   100000, 077776, cpn0vc, 177776
        .word   100001, 077776, cpn0vc, 177775
        .word   177775, 077776, cpn0vc, 100001
        .word   177776, 077776, cpn0vc, 100000
        .word   177777, 077776, cp000c, 077777

        .word   000001, 077777, cp0000, 077776
        .word   077775, 077777, cp0000, 000002
        .word   077776, 077777, cp0000, 000001
        .word   077777, 077777, cp0z00, 000000
        .word   100000, 077777, cpn0vc, 177777
        .word   100001, 077777, cpn0vc, 177776
        .word   177776, 077777, cpn0vc, 100001
        .word   177777, 077777, cpn0vc, 100000

        .word   000001, 100000, cp00v0, 077777
        .word   000002, 100000, cp00v0, 077776
        .word   077776, 100000, cp00v0, 000002
        .word   077777, 100000, cp00v0, 000001
        .word   100000, 100000, cp0z00, 000000
        .word   100001, 100000, cpn00c, 177777
        .word   177776, 100000, cpn00c, 100002
        .word   177777, 100000, cpn00c, 100001

        .word   000001, 100001, cpn000, 100000
        .word   000002, 100001, cp00v0, 077777
        .word   077776, 100001, cp00v0, 000003
        .word   077777, 100001, cp00v0, 000002
        .word   100000, 100001, cp0000, 000001
        .word   100001, 100001, cp0z00, 000000
        .word   177776, 100001, cpn00c, 100003
        .word   177777, 100001, cpn00c, 100002

        .word   000001, 177776, cpn000, 177775
        .word   077775, 177776, cpn000, 100001
        .word   077776, 177776, cpn000, 100000
        .word   077777, 177776, cp00v0, 077777
        .word   100000, 177776, cp0000, 077776
        .word   100001, 177776, cp0000, 077775
        .word   177775, 177776, cp0000, 000001
        .word   177776, 177776, cp0z00, 000000
        .word   177777, 177776, cpn00c, 177777

        .word   000001, 177777, cpn000, 177776
        .word   077776, 177777, cpn000, 100001
        .word   077777, 177777, cpn000, 100000
        .word   100000, 177777, cp0000, 077777
        .word   100001, 177777, cp0000, 077776
        .word   177776, 177777, cp0000, 000001
        .word   177777, 177777, cp0z00, 000000
1011$:
;
2000$:  scc
        sub     (r0),(r1)
        .word   1010$
        .word   1011$
;
9999$:  iot                     ; end of test C2.1
;
; Test C3 -- bic +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     0 100 sss sss ddd ddd NZ0- BIC
;
; Test C3.1 -- bic instruction +++++++++++++++++++++++++++++++++++++++
;
tc0301: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests (with ccc)
        jsr     pc,top2wr
        mov     #2000$,r5       ; mem mode tests (with scc)
        jsr     pc,top2wm
        jmp     9999$
;
1000$:  ccc
        bic     r0,r1
        .word   1010$
        .word   1011$
;
;                  src  olddst     psw  newdst
1010$:  .word   000000, 000000, cp0z00, 000000
        .word   177777, 000000, cp0z00, 000000

        .word   000000, 077077, cp0000, 077077
        .word   070007, 077077, cp0000, 007070
        .word   177777, 077077, cp0z00, 000000

        .word   000000, 100770, cpn000, 100770
        .word   000070, 100770, cpn000, 100700
        .word   100700, 100770, cp0000, 000070
        .word   177777, 100770, cp0z00, 000000
1011$:
;
2000$:  scc
        bic     (r0),(r1)
        .word   2010$
        .word   2011$
;
;                  src  olddst     psw  newdst
2010$:  .word   000000, 000000, cp0z0c, 000000
        .word   177777, 000000, cp0z0c, 000000

        .word   000000, 077077, cp000c, 077077
        .word   070007, 077077, cp000c, 007070
        .word   177777, 077077, cp0z0c, 000000

        .word   000000, 100770, cpn00c, 100770
        .word   000070, 100770, cpn00c, 100700
        .word   100700, 100770, cp000c, 000070
        .word   177777, 100770, cp0z0c, 000000

2011$:
;
9999$:  iot                     ; end of test C3.1
;
; Test C4 -- bis +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     0 101 sss sss ddd ddd NZ0- BIS
;
; Test C4.1 -- bis instruction +++++++++++++++++++++++++++++++++++++++
;
tc0401: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests (with ccc)
        jsr     pc,top2wr
        mov     #2000$,r5       ; mem mode tests (with scc)
        jsr     pc,top2wm
        jmp     9999$
;
1000$:  ccc
        bis     r0,r1
        .word   1010$
        .word   1011$
;
;                  src  olddst     psw  newdst
1010$:  .word   000000, 000000, cp0z00, 000000
        .word   077077, 000000, cp0000, 077077
        .word   100770, 000000, cpn000, 100770

        .word   000000, 070007, cp0000, 070007
        .word   007070, 070007, cp0000, 077077
        .word   100770, 070007, cpn000, 170777

        .word   000000, 100770, cpn000, 100770
        .word   007070, 100770, cpn000, 107770
1011$:
;
2000$:  scc
        bis     (r0),(r1)
        .word   2010$
        .word   2011$
;
;                  src  olddst     psw  newdst
2010$:  .word   000000, 000000, cp0z0c, 000000
        .word   077077, 000000, cp000c, 077077
        .word   100770, 000000, cpn00c, 100770

        .word   000000, 070007, cp000c, 070007
        .word   007070, 070007, cp000c, 077077
        .word   100770, 070007, cpn00c, 170777

        .word   000000, 100770, cpn00c, 100770
        .word   007070, 100770, cpn00c, 107770

2011$:
;
9999$:  iot                     ; end of test C4.1
;
; Test C5 -- cmp +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     0 010 sss sss ddd ddd NZVC CMP
;
; Test C5.1 -- cmp instruction +++++++++++++++++++++++++++++++++++++++
;
tc0501: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests (with ccc)
        jsr     pc,top2wr
        mov     #2000$,r5       ; mem mode tests (with scc)
        jsr     pc,top2wm
        jmp     9999$
;
1000$:  ccc
        cmp     r0,r1
        .word   1010$
        .word   1011$
;
;                  src  olddst     psw  newdst    ; src-dst
1010$:  .word   000000, 000000, cp0z00, 000000    ; (000000)
        .word   000001, 000000, cp0000, 000000    ; (000001)
        .word   177777, 000000, cpn000, 000000    ; (177777)
        .word   000000, 000001, cpn00c, 000001    ; (177777+C)
        .word   000001, 000001, cp0z00, 000001    ; (000000)
        .word   177777, 000001, cpn000, 000001    ; (177776)
        .word   077776, 077777, cpn00c, 077777    ; (177777+C)
        .word   077777, 077777, cp0z00, 077777    ; (000000)
        .word   100000, 077777, cp00v0, 077777    ; (000001)
        .word   000001, 077777, cpn00c, 077777    ; (100002+C)
        .word   177777, 077777, cpn000, 077777    ; (100000)
        .word   077777, 100000, cpn0vc, 100000    ; (177777+C)
        .word   100000, 100000, cp0z00, 100000    ; (000000)
        .word   100001, 100000, cp0000, 100000    ; (000001)
        .word   000001, 100000, cpn0vc, 100000    ; (100001+C)
        .word   177777, 100000, cp0000, 100000    ; (077777)
        .word   000000, 177777, cp000c, 177777    ; (000001+C)
        .word   000001, 177777, cp000c, 177777    ; (000002+C)
        .word   177777, 177777, cp0z00, 177777    ; (000000)
1011$:
;
2000$:  scc
        cmp     (r0),(r1)
        .word   1010$
        .word   1011$
;
9999$:  iot                     ; end of test C5.1
;
; Test C6 -- bit +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     0 011 sss sss ddd ddd NZ0- BIT
;
; Test C6.1 -- bit instruction +++++++++++++++++++++++++++++++++++++++
;
tc0601: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests (with ccc)
        jsr     pc,top2wr
        mov     #2000$,r5       ; mem mode tests (with scc)
        jsr     pc,top2wm
        jmp     9999$
;
1000$:  ccc
        bit     r0,r1
        .word   1010$
        .word   1011$
;
;                  src  olddst     psw  newdst    ; src&dst
1010$:  .word   000000, 000000, cp0z00, 000000    ; (000000)
        .word   000011, 000000, cp0z00, 000000    ; (000000)
        .word   000011, 000110, cp0000, 000110    ; (000010)
        .word   000011, 001100, cp0z00, 001100    ; (000000)
        .word   110000, 011000, cp0000, 011000    ; (010000)
        .word   110000, 110000, cpn000, 110000    ; (110000)
1011$:
;
2000$:  scc
        bit     (r0),(r1)
        .word   2010$
        .word   2011$
;
;                  src  olddst     psw  newdst    ; src&dst
2010$:  .word   000000, 000000, cp0z0c, 000000    ; (000000)
        .word   000011, 000000, cp0z0c, 000000    ; (000000)
        .word   000011, 000110, cp000c, 000110    ; (000010)
        .word   000011, 001100, cp0z0c, 001100    ; (000000)
        .word   110000, 011000, cp000c, 011000    ; (010000)
        .word   110000, 110000, cpn00c, 110000    ; (110000)
2011$:
;
9999$:  iot                     ; end of test C6.1
;
; Test C7 -- mov +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     0 001 sss sss ddd ddd NZ0- MOV
;
; Test C7.1 -- mov instruction +++++++++++++++++++++++++++++++++++++++
;
tc0701: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests (with ccc; c=0)
        jsr     pc,top2wr
        mov     #2000$,r5       ; mem mode tests (with scc; c=1)
        jsr     pc,top2wm
        jmp     9999$
;
1000$:  ccc                     ; c=0
        mov     r0,r1
        .word   1010$
        .word   1011$
;
;                  src  olddst     psw  newdst
1010$:  .word   000000, 000000, cp0z00, 000000
        .word   000001, 000000, cp0000, 000001
        .word   100000, 000000, cpn000, 100000
1011$:
;
2000$:  scc                     ; c=1
        mov     (r0),(r1)
        .word   2010$
        .word   2011$
;
;                  src  olddst     psw  newdst
2010$:  .word   000000, 177777, cp0z0c, 000000
        .word   000001, 177777, cp000c, 000001
        .word   100000, 177777, cpn00c, 100000
2011$:
;
9999$:  iot                     ; end of test C7.1
;
; Section D: unary instructions (byte) =======================================
;
        jmp     td0101
;
; test driver for unary instruction tests (byte)
;
top1br: mov     (r5),101$       ; setup cc setter
        mov     2(r5),102$      ; setup instruction
        mov     4(r5),r4        ; setup expect data pointer
        mov     6(r5),r3        ; setup expect end
        mov     #cp.psw,r2
;
100$:   movb    (r4)+,r1        ; setup dst
        ccc                     ; clear cc
101$:   nop                     ; REPLACED with cc setter
102$:   nop                     ; REPLACED with instruction, e.g. inc r1
        cmpb    (r2),(r4)+      ; check psw
        beq     .+4
        halt
        cmpb    r1,(r4)+        ; check new dst
        beq     .+4
        halt
        cmp     r4,r3           ; more to do ?
        blo     100$
        rts     pc
;
top1bm: mov     (r5),101$       ; setup cc setter
        mov     2(r5),102$      ; setup instruction
        mov     4(r5),r4        ; setup expect data pointer
        mov     6(r5),r3        ; setup expect end
        mov     #200$,r1        ; setup dst pointer
        mov     #cp.psw,r2
;
100$:   movb    (r4)+,(r1)      ; setup old dst
        ccc                     ; clear cc
101$:   nop                     ; REPLACED with cc setter
102$:   nop                     ; REPLACED with instruction, e.g. inc (r1)
        cmpb    (r2),(r4)+      ; check psw
        beq     .+4
        halt
        cmpb    (r1),(r4)+      ; check new dst
        beq     .+4
        halt
        cmp     r4,r3           ; more to do ?
        blo     100$
        rts     pc
;
200$:   .word   0
;
; Test D1 -- incb ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     1 000 101 010 ddd ddd NZV- INCB
;
; Test D1.1 -- incb instruction ++++++++++++++++++++++++++++++++++++++++
;
td0101: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests
        jsr     pc,top1br
        mov     #2000$,r5       ; mem mode tests
        jsr     pc,top1bm
        jmp     9999$
;
1000$:  ccc                     ; c=0
        incb    r1              ; incb preserves c, so stays 0
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
1010$:  .byte      000, cp0000,    001
        .byte      001, cp0000,    002
        .byte      176, cp0000,    177
        .byte      177, cpn0v0,    200
        .byte      200, cpn000,    201
        .byte      201, cpn000,    202
        .byte      376, cpn000,    377
        .byte      377, cp0z00,    000
1011$:
        .even
;
2000$:  scc                     ; c=1
        incb    (r1)            ; incb preserves c, so stays 1
        .word   2010$
        .word   2011$
;
;               olddst     psw  newdst
2010$:  .byte      000, cp000c,    001
        .byte      001, cp000c,    002
        .byte      176, cp000c,    177
        .byte      177, cpn0vc,    200
        .byte      200, cpn00c,    201
        .byte      201, cpn00c,    202
        .byte      376, cpn00c,    377
        .byte      377, cp0z0c,    000
2011$:
        .even
;
9999$:  iot                     ; end of test D1.1
;
; Test D2 -- decb ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     1 000 101 011 ddd ddd NZV- DECB
;
; Test D2.1 -- decb instruction ++++++++++++++++++++++++++++++++++++++++
;
td0201: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests
        jsr     pc,top1br
        mov     #2000$,r5       ; mem mode tests
        jsr     pc,top1bm
        jmp     9999$
;
1000$:  ccc                     ; c=0
        decb    r1              ; decb preserves c, so stays 0
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
1010$:  .byte      000, cpn000,    377
        .byte      001, cp0z00,    000
        .byte      176, cp0000,    175
        .byte      177, cp0000,    176
        .byte      200, cp00v0,    177
        .byte      201, cpn000,    200
        .byte      376, cpn000,    375
        .byte      377, cpn000,    376
1011$:
        .even
;
2000$:  scc                     ; c=1
        decb    (r1)            ; decb preserves c, so stays 1
        .word   2010$
        .word   2011$
;
;               olddst     psw  newdst
2010$:  .byte      000, cpn00c,    377
        .byte      001, cp0z0c,    000
        .byte      176, cp000c,    175
        .byte      177, cp000c,    176
        .byte      200, cp00vc,    177
        .byte      201, cpn00c,    200
        .byte      376, cpn00c,    375
        .byte      377, cpn00c,    376
2011$:
        .even
;
9999$:  iot                     ; end of test D2.1
;
; Test D3 -- comb ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     1 000 101 001 ddd ddd NZ01 COMB
;
; Test D3.1 -- comb instruction ++++++++++++++++++++++++++++++++++++++++
;
td0301: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests
        jsr     pc,top1br
        mov     #2000$,r5       ; mem mode tests
        jsr     pc,top1bm
        jmp     9999$
;
1000$:  ccc
        comb    r1
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
1010$:  .byte      000, cpn00c,    377
        .byte      001, cpn00c,    376
        .byte      177, cpn00c,    200
        .byte      200, cp000c,    177
        .byte      377, cp0z0c,    000
1011$:
        .even
;
2000$:  scc
        comb    (r1)
        .word   1010$
        .word   1011$
;
9999$:  iot                     ; end of test D3.1
;
; Test D4 -- negb ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     1 000 101 100 ddd ddd NZVC NEGB
;
; Test D4.1 -- negb instruction ++++++++++++++++++++++++++++++++++++++++
;
td0401: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests
        jsr     pc,top1br
        mov     #2000$,r5       ; mem mode tests
        jsr     pc,top1bm
        jmp     9999$
;
1000$:  ccc
        negb    r1
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
1010$:  .byte      000, cp0z00,    000
        .byte      001, cpn00c,    377
        .byte      177, cpn00c,    201
        .byte      200, cpn0vc,    200
        .byte      377, cp000c,    001
1011$:
        .even
;
2000$:  scc
        negb    (r1)
        .word   1010$
        .word   1011$
;
9999$:  iot                     ; end of test D4.1
;
; Test D5 -- adcb ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     1 000 101 101 ddd ddd NZVC ADCB
;
; Test D5.1 -- adcb instruction ++++++++++++++++++++++++++++++++++++++++
;
td0501: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests
        jsr     pc,top1br
        mov     #2000$,r5       ; mem mode tests
        jsr     pc,top1bm
        jmp     9999$
;
1000$:  ccc                     ; c=0
        adcb    r1
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
1010$:  .byte      000, cp0z00,    000
        .byte      001, cp0000,    001
        .byte      177, cp0000,    177
        .byte      200, cpn000,    200
        .byte      377, cpn000,    377
1011$:
        .even
;
2000$:  scc                     ; c=1
        adcb    (r1)
        .word   2010$
        .word   2011$
;
;               olddst  psw     newdst
2010$:  .byte      000, cp0000,    001
        .byte      001, cp0000,    002
        .byte      177, cpn0v0,    200
        .byte      200, cpn000,    201
        .byte      377, cp0z0c,    000
2011$:
        .even
;
9999$:  iot                     ; end of test D5.1
;
; Test D6 -- sbcb ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     1 000 101 110 ddd ddd NZVC SBCB
;
; Test D6.1 -- sbcb instruction ++++++++++++++++++++++++++++++++++++++++
;
td0601: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests
        jsr     pc,top1br
        mov     #2000$,r5       ; mem mode tests
        jsr     pc,top1bm
        jmp     9999$
;
1000$:  ccc                     ; c=0
        sbcb    r1
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
1010$:  .byte      000, cp0z00,    000
        .byte      001, cp0000,    001
        .byte      177, cp0000,    177
        .byte      200, cpn000,    200
        .byte      377, cpn000,    377
1011$:
        .even
;
2000$:  scc                     ; c=1
        sbcb    (r1)
        .word   2010$
        .word   2011$
;
;               olddst  psw     newdst
2010$:  .byte      000, cpn00c,    377
        .byte      001, cp0z00,    000
        .byte      177, cp0000,    176
        .byte      200, cp00v0,    177
        .byte      377, cpn000,    376
2011$:
        .even
;
9999$:  iot                     ; end of test D6.1
;
; Test D7 -- tstb ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     1 000 101 111 ddd ddd NZ00 TSTB
;
; Test D7.1 -- tstb instruction ++++++++++++++++++++++++++++++++++++++++
;
td0701: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests
        jsr     pc,top1br
        mov     #2000$,r5       ; mem mode tests
        jsr     pc,top1bm
        jmp     9999$
;
1000$:  ccc
        tstb    r1
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
1010$:  .byte      000, cp0z00,    000
        .byte      001, cp0000,    001
        .byte      177, cp0000,    177
        .byte      200, cpn000,    200
        .byte      377, cpn000,    377
1011$:
        .even
;
2000$:  scc
        tstb    (r1)
        .word   1010$
        .word   1011$
;
9999$:  iot                     ; end of test D7.1
;
; Test D8 -- rorb ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     1 000 110 000 ddd ddd NZVC RORB
;
; Test D8.1 -- rorb instruction ++++++++++++++++++++++++++++++++++++++++
;
td0801: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests
        jsr     pc,top1br
        mov     #2000$,r5       ; mem mode tests
        jsr     pc,top1bm
        jmp     9999$
;
1000$:  ccc                     ; c=0
        rorb    r1
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
1010$:  .byte      000, cp0z00,    000
        .byte      001, cp0zvc,    000
        .byte      200, cp0000,    100
        .byte      010, cp0000,    004
        .byte      011, cp00vc,    004
        .byte      110, cp0000,    044
        .byte      210, cp0000,    104
1011$:
        .even
;
2000$:  scc                     ; c=1
        rorb    (r1)
        .word   2010$
        .word   2011$
;
;               olddst  psw     newdst
2010$:  .byte      000, cpn0v0,    200
        .byte      001, cpn00c,    200
        .byte      200, cpn0v0,    300
        .byte      010, cpn0v0,    204
        .byte      011, cpn00c,    204
        .byte      110, cpn0v0,    244
        .byte      210, cpn0v0,    304
2011$:
        .even
;
9999$:  iot                     ; end of test D8.1
;
; Test D9 -- rolb ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     1 000 110 001 ddd ddd NZVC ROLB
;
; Test D9.1 -- rorb instruction ++++++++++++++++++++++++++++++++++++++++
;
td0901: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests
        jsr     pc,top1br
        mov     #2000$,r5       ; mem mode tests
        jsr     pc,top1bm
        jmp     9999$
;
1000$:  ccc                     ; c=0
        rolb    r1
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
1010$:  .byte      000, cp0z00,    000
        .byte      001, cp0000,    002
        .byte      200, cp0zvc,    000
        .byte      010, cp0000,    020
        .byte      011, cp0000,    022
        .byte      110, cpn0v0,    220
        .byte      210, cp00vc,    020
1011$:
        .even
;
2000$:  scc                     ; c=1
        rolb    (r1)
        .word   2010$
        .word   2011$
;
;               olddst  psw     newdst
2010$:  .byte      000, cp0000,    001
        .byte      001, cp0000,    003
        .byte      200, cp00vc,    001
        .byte      010, cp0000,    021
        .byte      011, cp0000,    023
        .byte      110, cpn0v0,    221
        .byte      210, cp00vc,    021
2011$:
        .even
;
9999$:  iot                     ; end of test D9.1
;
; Test D10 -- asrb +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     1 000 110 010 ddd ddd NZVC ASRB
;
; Test D10.1 -- asrb instruction +++++++++++++++++++++++++++++++++++++++
;
td1001: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests
        jsr     pc,top1br
        mov     #2000$,r5       ; mem mode tests
        jsr     pc,top1bm
        jmp     9999$
;
1000$:  ccc
        asrb    r1
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
1010$:  .byte      000, cp0z00,    000
        .byte      001, cp0zvc,    000
        .byte      200, cpn0v0,    300
        .byte      010, cp0000,    004
        .byte      011, cp00vc,    004
        .byte      110, cp0000,    044
        .byte      210, cpn0v0,    304
1011$:
        .even
;
2000$:  scc
        asrb    (r1)
        .word   1010$
        .word   1011$
;
9999$:  iot                     ; end of test D10.1
;
; Test D11 -- aslb +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     1 000 110 011 ddd ddd NZVC ASLB
;
; Test D11.1 -- asrb instruction +++++++++++++++++++++++++++++++++++++++
;
td1101: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests
        jsr     pc,top1br
        mov     #2000$,r5       ; mem mode tests
        jsr     pc,top1bm
        jmp     9999$
;
1000$:  ccc
        aslb    r1
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
1010$:  .byte      000, cp0z00,    000
        .byte      001, cp0000,    002
        .byte      200, cp0zvc,    000
        .byte      010, cp0000,    020
        .byte      011, cp0000,    022
        .byte      110, cpn0v0,    220
        .byte      210, cp00vc,    020
1011$:
        .even
;
2000$:  scc
        aslb    (r1)
        .word   1010$
        .word   1011$
;
9999$:  iot                     ; end of test D11.1
;
; Test D12 -- clrb +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     1 000 101 000 ddd ddd 0100 CLRB
;
; Test D12.1 -- asrb instruction +++++++++++++++++++++++++++++++++++++++
;
td1201: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests
        jsr     pc,top1br
        mov     #2000$,r5       ; mem mode tests
        jsr     pc,top1bm
        jmp     9999$
;
1000$:  ccc
        clrb    r1
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
1010$:  .byte      000, cp0z00,    000
        .byte      377, cp0z00,    000
1011$:
        .even
;
2000$:  scc
        clrb    (r1)
        .word   1010$
        .word   1011$
;
9999$:  iot                     ; end of test D12.1
;
;
; Section E: binary instructions (byte) ======================================
;
        jmp     te0101
;
; test driver for binary instruction tests
;
top2br: mov     (r5),101$       ; setup cc setter
        mov     2(r5),102$      ; setup instruction
        mov     4(r5),r4        ; setup expect data pointer
        mov     6(r5),r3        ; setup expect end
        mov     #cp.psw,r2
;
100$:   movb    (r4)+,r0        ; setup src
        movb    (r4)+,r1        ; setup old dst
        ccc                     ; clear cc
101$:   nop                     ; REPLACED with cc setter
102$:   nop                     ; REPLACED with instruction, e.g. add r0,r1
        cmpb    (r2),(r4)+      ; check psw
        beq     .+4
        halt
        cmpb    r1,(r4)+        ; check new dst
        beq     .+4
        halt
        cmp     r4,r3           ; more to do ?
        blo     100$
        rts     pc
;
top2bm: mov     (r5),101$       ; setup cc setter
        mov     2(r5),102$      ; setup instruction
        mov     4(r5),r4        ; setup expect data pointer
        mov     6(r5),r3        ; setup expect end
        mov     #200$,r0        ; setup src pointer
        mov     #300$,r1        ; setup dst pointer
        mov     #cp.psw,r2
;
100$:   movb    (r4)+,(r0)      ; setup src
        movb    (r4)+,(r1)      ; setup old dst
        ccc                     ; clear cc
101$:   nop                     ; REPLACED with cc setter
102$:   nop                     ; REPLACED with instruction, e.g. add (r0),(r1)
        cmpb    (r2),(r4)+      ; check psw
        beq     .+4
        halt
        cmpb    (r1),(r4)+      ; check new dst
        beq     .+4
        halt
        cmp     r4,r3           ; more to do ?
        blo     100$
        rts     pc
;
200$:   .word   0
300$:   .word   0
;
; Test E1 -- bicb ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     1 100 sss sss ddd ddd NZ0- BICB
;
; Test E1.1 -- bicb instruction ++++++++++++++++++++++++++++++++++++++
;
te0101: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests (with ccc)
        jsr     pc,top2br
        mov     #2000$,r5       ; mem mode tests (with scc)
        jsr     pc,top2bm
        jmp     9999$
;
1000$:  ccc
        bicb    r0,r1
        .word   1010$
        .word   1011$
;
;                  src  olddst     psw  newdst
1010$:  .byte      000,    000, cp0z00,    000
        .byte      003,    000, cp0z00,    000
        .byte      003,    006, cp0000,    004
        .byte      003,    014, cp0000,    014
        .byte      300,    140, cp0000,    040
        .byte      100,    300, cpn000,    200
1011$:
;
2000$:  scc
        bicb    (r0),(r1)
        .word   2010$
        .word   2011$
;
;                  src  olddst     psw  newdst
2010$:  .byte      000,    000, cp0z0c,    000
        .byte      003,    000, cp0z0c,    000
        .byte      003,    006, cp000c,    004
        .byte      003,    014, cp000c,    014
        .byte      300,    140, cp000c,    040
        .byte      100,    300, cpn00c,    200
2011$:
;
9999$:  iot                     ; end of test E1.1
;
; Test E2 -- bisb ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     1 101 sss sss ddd ddd NZ0- BISB
;
; Test E2.1 -- bisb instruction ++++++++++++++++++++++++++++++++++++++
;
te0201: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests (with ccc)
        jsr     pc,top2br
        mov     #2000$,r5       ; mem mode tests (with scc)
        jsr     pc,top2bm
        jmp     9999$
;
1000$:  ccc
        bisb    r0,r1
        .word   1010$
        .word   1011$
;
;                  src  olddst     psw  newdst
1010$:  .byte      000,    000, cp0z00,    000
        .byte      003,    000, cp0000,    003
        .byte      003,    006, cp0000,    007
        .byte      003,    014, cp0000,    017
        .byte      300,    140, cpn000,    340
        .byte      100,    300, cpn000,    300
1011$:
;
2000$:  scc
        bisb    (r0),(r1)
        .word   2010$
        .word   2011$
;
;                  src  olddst     psw  newdst
2010$:  .byte      000,    000, cp0z0c,    000
        .byte      003,    000, cp000c,    003
        .byte      003,    006, cp000c,    007
        .byte      003,    014, cp000c,    017
        .byte      300,    140, cpn00c,    340
        .byte      100,    300, cpn00c,    300
2011$:
;
9999$:  iot                     ; end of test E2.1
;
; Test E3 -- cmpb ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     1 010 sss sss ddd ddd NZVC CMPB
;
; Test E3.1 -- cmpb instruction ++++++++++++++++++++++++++++++++++++++
;
te0301: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests (with ccc)
        jsr     pc,top2br
        mov     #2000$,r5       ; mem mode tests (with scc)
        jsr     pc,top2bm
        jmp     9999$
;
1000$:  ccc
        cmpb    r0,r1
        .word   1010$
        .word   1011$
;
;                  src  olddst     psw  newdst    ; src-dst
1010$:  .byte      000,    000, cp0z00,    000    ; (000)
        .byte      001,    000, cp0000,    000    ; (001)
        .byte      377,    000, cpn000,    000    ; (377)
        .byte      000,    001, cpn00c,    001    ; (377+C)
        .byte      001,    001, cp0z00,    001    ; (000)
        .byte      377,    001, cpn000,    001    ; (376)
        .byte      176,    177, cpn00c,    177    ; (377+C)
        .byte      177,    177, cp0z00,    177    ; (000)
        .byte      200,    177, cp00v0,    177    ; (001)
        .byte      001,    177, cpn00c,    177    ; (202+C)
        .byte      377,    177, cpn000,    177    ; (200)
        .byte      177,    200, cpn0vc,    200    ; (377+C)
        .byte      200,    200, cp0z00,    200    ; (000)
        .byte      201,    200, cp0000,    200    ; (001)
        .byte      001,    200, cpn0vc,    200    ; (201+C)
        .byte      377,    200, cp0000,    200    ; (177)
        .byte      000,    377, cp000c,    377    ; (001+C)
        .byte      001,    377, cp000c,    377    ; (002+C)
        .byte      377,    377, cp0z00,    377    ; (000)
1011$:
;
2000$:  scc
        cmpb    (r0),(r1)
        .word   1010$
        .word   1011$
;
9999$:  iot                     ; end of test E3.1
;
; Test E4 -- bitb ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     1 011 sss sss ddd ddd NZ0- BITB
;
; Test E4.1 -- bitb instruction ++++++++++++++++++++++++++++++++++++++
;
te0401: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests (with ccc)
        jsr     pc,top2br
        mov     #2000$,r5       ; mem mode tests (with scc)
        jsr     pc,top2bm
        jmp     9999$
;
1000$:  ccc
        bitb    r0,r1
        .word   1010$
        .word   1011$
;
;                  src  olddst     psw  newdst    ; src&dst
1010$:  .byte      000,    000, cp0z00,    000    ; (000)
        .byte      003,    000, cp0z00,    000    ; (000)
        .byte      003,    006, cp0000,    006    ; (002)
        .byte      003,    014, cp0z00,    014    ; (000)
        .byte      300,    140, cp0000,    140    ; (100)
        .byte      200,    300, cpn000,    300    ; (200)
1011$:
;
2000$:  scc
        bitb    (r0),(r1)
        .word   2010$
        .word   2011$
;
;                  src  olddst     psw  newdst    ; src&dst
2010$:  .byte      000,    000, cp0z0c,    000    ; (000)
        .byte      003,    000, cp0z0c,    000    ; (000)
        .byte      003,    006, cp000c,    006    ; (002)
        .byte      003,    014, cp0z0c,    014    ; (000)
        .byte      300,    140, cp000c,    140    ; (100)
        .byte      200,    300, cpn00c,    300    ; (200)
2011$:
;
9999$:  iot                     ; end of test E4.1
;
; Test E5 -- movb ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     1 001 sss sss ddd ddd NZ0- MOVB
;
; Test E5.1 -- movb instruction ++++++++++++++++++++++++++++++++++++++
;
te0501: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests (with ccc)
        jsr     pc,top2br
        mov     #2000$,r5       ; mem mode tests (with scc)
        jsr     pc,top2bm
        jmp     9999$
;
1000$:  ccc
        movb    r0,r1
        .word   1010$
        .word   1011$
;
;                  src  olddst     psw  newdst
1010$:  .byte      000,    000, cp0z00,    000
        .byte      001,    000, cp0000,    001
        .byte      200,    000, cpn000,    200
1011$:
;
2000$:  scc
        movb    (r0),(r1)
        .word   2010$
        .word   2011$
;
;                  src  olddst     psw  newdst
2010$:  .byte      000,    000, cp0z0c,    000
        .byte      001,    000, cp000c,    001
        .byte      200,    000, cpn00c,    200
2011$:
;
9999$:  iot                     ; end of test E5.1
;
; END OF ALL TESTS - loop closure ============================================
;
        mov     tstno,r0        ; hack, for easy monitoring ...
        cmp     tstno,#43.      ; all tests done ?
        beq     .+4
        halt
;
        jmp     loop
