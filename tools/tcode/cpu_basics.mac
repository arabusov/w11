; $Id: cpu_basics.mac 1325 2022-12-07 11:52:36Z mueller $
; SPDX-License-Identifier: GPL-3.0-or-later
; Copyright 2015-2022 by Walter F.J. Mueller <W.F.J.Mueller@gsi.de>
;
; Revision History:
; Date         Rev Version  Comment
; 2022-12-06  1324   1.0    Initial version
; 2015-08-30   710   0.1    First draft
;
; Test CPU basics: most instructions except traps, EIS and FPP
;   Section A: ccops + flow control bxx, sob, jmp, jsr, rts, mark
;   Section B: unary instructions (word)
;   Section C: binary instructions (word)
;   Section D: unary instructions (byte)
;   Section E: binary instructions (byte)
;   Section F: miscellaneous (spl, reset, bpt,...)
;
        .include        |lib/tcode_std_base.mac|
        .include        |lib/defs_kwl.mac|
;
; Section A: ccops + flow control bxx, sob, jmp, jsr, rts, mark ==============
;   A1    ccop + bbx
;   A1.1    ccop + psw
;   A1.2    ccop + bxx
;   A2    sob
;   A3    jmp
;   A3.1    jmp + dsta
;   A3.2    jmp + cc
;   A4    jsr + rts
;   A4.1    jsr + dsta
;   A4.2    jsr + cc
;   A4.3    jsr r0-r5
;   A4.4    jsr sp and rts sp
;   A5    mark
;
; Test A1:  ccop + bxx +++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     0 000 000 010 10n zvc NZVC CLx
;     0 000 000 010 11n zvc NZVC SEx
;
;     0 000 000 1bb bbb bbb ---- BR  always
;
;     0 000 001 0bb bbb bbb ---- BNE if Z = 0
;     0 000 001 1bb bbb bbb ---- BEQ if Z = 1
;     0 000 010 0bb bbb bbb ---- BGE if (N xor V) = 0
;     0 000 010 1bb bbb bbb ---- BLT if (N xor V) = 1
;     0 000 011 0bb bbb bbb ---- BGT if (Z or (N xor V)) = 0
;     0 000 011 1bb bbb bbb ---- BLE if (Z or (N xor V)) = 1
;
;     1 000 000 0bb bbb bbb ---- BPL  if N = 0
;     1 000 000 1bb bbb bbb ---- BMI  if N = 1
;     1 000 001 0bb bbb bbb ---- BHI  if (C or Z) = 0
;     1 000 001 1bb bbb bbb ---- BLOS if (C or Z) = 1
;     1 000 010 0bb bbb bbb ---- BVC  if V = 0
;     1 000 010 1bb bbb bbb ---- BVS  if V = 1
;     1 000 011 0bb bbb bbb ---- BCC  if C = 0
;     1 000 011 1bb bbb bbb ---- BCS  if C = 1
;
; Test A1.1 -- ccop + psw ++++++++++++++++++++++++++++++++++++++++++++
;   This test sets and clears all four condition codes and verifies that
;   the psw properly reflects this.
;
ta0101: mov     #cp.psw,r0
        clr     (r0)
;
        ccc                     ; nzvc = 0000
        hcmpeq  (r0),#cp0000
; sec
        ccc
        sec                     ; nzvc = 0001
        hcmpeq  (r0),#cp000c
; sev
        ccc
        sev                     ; nzvc = 0010
        hcmpeq  (r0),#cp00v0
; sez
        ccc
        sez                     ; nzvc = 0100
        hcmpeq  (r0),#cp0z00
; sen
        ccc
        sen                     ; nzvc = 1000
        hcmpeq  (r0),#cpn000
; sen!sec
        ccc
        <sen!sec>               ; nzvc = 1001
        hcmpeq  (r0),#cpn00c
; sez!sev
        ccc
        <sez!sev>               ; nzvc = 1001
        hcmpeq  (r0),#cp0zv0
;
        scc                     ; nzvc = 1111
        hcmpeq  (r0),#cpnzvc
; clc
        scc
        clc                     ; nzvc = 1110
        hcmpeq  (r0),#cpnzv0
; clv
        scc
        clv                     ; nzvc = 1101
        hcmpeq  (r0),#cpnz0c
; clz
        scc
        clz                     ; nzvc = 1011
        hcmpeq  (r0),#cpn0vc
; cln
        scc
        cln                     ; nzvc = 0111
        hcmpeq  (r0),#cp0zvc
; cln!clc
        scc
        <cln!clc>               ; nzvc = 0110
        hcmpeq  (r0),#cp0zv0
; clz!clv
        scc
        <clz!clv>               ; nzvc = 1001
        hcmpeq  (r0),#cpn00c
;
9999$:  iot                     ; end of test A1.1

; Test A1.2 -- ccop + bxx ++++++++++++++++++++++++++++++++++++++++++++
;   This test sets all possible combinations of condition code bits
;   (with cc ops) and verifies the branch instruction response
;   Note: after normal compares N will never be 1 if Z=1 (a number can not
;         zero and negative simultaneously). Thus not all combinations are
;         used in normal code execution. 
;
ta0102: clr     @#cp.psw
        ;
        ; case NZVC = 0000 -- N=0 Z=0 V=0 C=0 ------------------------
        ;
        ccc
        ;
        ;
        bne     1$              ; yes Z=0
        halt
1$:     beq     99$             ; no  Z=1
        ;
2$:     bge     3$              ; yes (N xor V) = 0
        halt
3$:     blt     99$             ; no  (N xor V) = 1
        ;
4$:     bgt     5$              ; yes (Z or (N xor V)) = 0
        halt
5$:     ble     99$             ; no  (Z or (N xor V)) = 1
        ;
6$:     bpl     7$              ; yes N = 0
        halt
7$:     bmi     99$             ; no  N = 1
        ;
8$:     bhi     9$              ; yes (C or Z) = 0
        halt
9$:     blos    99$             ; no  (C or Z) = 1
        ;
10$:    bvc     11$             ; yes V = 0
        halt
11$:    bvs     99$             ; no  V = 1
        ;
12$:    bcc     13$             ; yes C = 0
        halt
13$:    bcs     99$             ; no  C = 1
        ;
14$:    br      100$
99$:    halt
        ;
        ; case NZVC = 0001 -- N=0 Z=0 V=0 C=1 ------------------------
        ;
100$:   ccc
        sec
        ;
        bne     101$            ; yes Z=0
        halt
101$:   beq     199$            ; no  Z=1
        ;
102$:   bge     103$            ; yes (N xor V) = 0
        halt
103$:   blt     199$            ; no  (N xor V) = 1
        ;
104$:   bgt     105$            ; yes (Z or (N xor V)) = 0
        halt
105$:   ble     199$            ; no  (Z or (N xor V)) = 1
        ;
106$:   bpl     107$            ; yes N = 0
        halt
107$:   bmi     199$            ; no  N = 1
        ;
108$:   bhi     199$            ; no  (C or Z) = 0
        ;
109$:   blos    110$            ; yes (C or Z) = 1
        halt
110$:   bvc     111$            ; yes V = 0
        halt
111$:   bvs     199$            ; no  V = 1
        ;
112$:   bcc     199$            ; no  C = 0
        ;
113$:   bcs     114$            ; yes C = 1
        halt
114$:   br      200$
199$:   halt
        ;
        ; case NZVC = 0010 -- N=0 Z=0 V=1 C=0 ------------------------
        ;
200$:   ccc
        sev
        ;
        bne     201$            ; yes Z=0
        halt
201$:   beq     299$            ; no  Z=1
        ;
202$:   bge     299$            ; no  (N xor V) = 0
        ;
203$:   blt     204$            ; yes (N xor V) = 1
        halt
204$:   bgt     299$            ; no  (Z or (N xor V)) = 0
        ;
205$:   ble     206$            ; yes (Z or (N xor V)) = 1
        halt
206$:   bpl     207$            ; yes N = 0
        halt
207$:   bmi     299$            ; no  N = 1
        ;
208$:   bhi     209$            ; yes (C or Z) = 0
        halt
209$:   blos    299$            ; no  (C or Z) = 1
        ;
210$:   bvc     299$            ; no  V = 0
        ;
211$:   bvs     212$            ; yes V = 1
        halt
212$:   bcc     213$            ; yes C = 0
        halt
213$:   bcs     299$            ; no  C = 1
        ;
214$:   br      300$
299$:   halt
        ;
        ; case NZVC = 0011 -- N=0 Z=0 V=1 C=1 ------------------------
        ;
300$:   ccc
        <sev!sec>
        ;
        bne     301$            ; yes Z=0
        halt
301$:   beq     399$            ; no  Z=1
        ;
302$:   bge     399$            ; no  (N xor V) = 0
        ;
303$:   blt     304$            ; yes (N xor V) = 1
        halt
304$:   bgt     399$            ; no  (Z or (N xor V)) = 0
        ;
305$:   ble     306$            ; yes (Z or (N xor V)) = 1
        halt
306$:   bpl     307$            ; yes N = 0
        halt
307$:   bmi     399$            ; no  N = 1
        ;
308$:   bhi     399$            ; no  (C or Z) = 0
        ;
309$:   blos    310$            ; yes (C or Z) = 1
        halt
310$:   bvc     399$            ; no  V = 0
        ;
311$:   bvs     312$            ; yes V = 1
        halt
312$:   bcc     399$            ; no  C = 0
        ;
313$:   bcs     314$            ; yes C = 1
        halt
314$:   br      400$
399$:   halt
        ;
        ; case NZVC = 0100 -- N=0 Z=1 V=0 C=0 ------------------------
        ;
400$:   ccc
        sez
        ;
        bne     499$            ; no  Z=0
        ;
401$:   beq     402$            ; yes Z=1
        halt
402$:   bge     403$            ; yes (N xor V) = 0
        halt
403$:   blt     499$            ; no  (N xor V) = 1
        ;
404$:   bgt     499$            ; no  (Z or (N xor V)) = 0
        ;
405$:   ble     406$            ; yes (Z or (N xor V)) = 1
        halt
406$:   bpl     407$            ; yes N = 0
        halt
407$:   bmi     499$            ; no  N = 1
        ;
408$:   bhi     499$            ; no  (C or Z) = 0
        ;
409$:   blos    410$            ; yes (C or Z) = 1
        halt
410$:   bvc     411$            ; yes V = 0
        halt
411$:   bvs     499$            ; no  V = 1
        ;
412$:   bcc     413$            ; yes C = 0
        halt
413$:   bcs     499$            ; no  C = 1
        ;
414$:   br      500$
499$:   halt
        ;
        ; case NZVC = 0101 -- N=0 Z=1 V=0 C=1 ------------------------
        ;
500$:   ccc
        <sez!sec>
        ;
        bne     599$            ; no  Z=0
        ;
501$:   beq     502$            ; yes Z=1
        halt
502$:   bge     503$            ; yes (N xor V) = 0
        halt
503$:   blt     599$            ; no  (N xor V) = 1
        ;
504$:   bgt     599$            ; no  (Z or (N xor V)) = 0
        ;
505$:   ble     506$            ; yes (Z or (N xor V)) = 1
        halt
506$:   bpl     507$            ; yes N = 0
        halt
507$:   bmi     599$            ; no  N = 1
        ;
508$:   bhi     599$            ; no  (C or Z) = 0
        ;
509$:   blos    510$            ; yes (C or Z) = 1
        halt
510$:   bvc     511$            ; yes V = 0
        halt
511$:   bvs     599$            ; no  V = 1
        ;
512$:   bcc     599$            ; no  C = 0
        ;
513$:   bcs     514$            ; yes C = 1
        halt
514$:   br      600$
599$:   halt
        ;
        ; case NZVC = 0110 -- N=0 Z=1 V=1 C=0 ------------------------
        ;
600$:   ccc
        <sez!sev>
        ;
        bne     699$            ; no  Z=0
        ;
601$:   beq     602$            ; yes Z=1
        halt
602$:   bge     699$            ; no  (N xor V) = 0
        ;
603$:   blt     604$            ; yes (N xor V) = 1
        halt
604$:   bgt     699$            ; no  (Z or (N xor V)) = 0
        ;
605$:   ble     606$            ; yes (Z or (N xor V)) = 1
        halt
606$:   bpl     607$            ; yes N = 0
        halt
607$:   bmi     699$            ; no  N = 1
        ;
608$:   bhi     699$            ; no  (C or Z) = 0
        ;
609$:   blos    610$            ; yes (C or Z) = 1
        halt
610$:   bvc     699$            ; no  V = 0
        ;
611$:   bvs     612$            ; yes V = 1
        halt
612$:   bcc     613$            ; yes C = 0
        halt
613$:   bcs     699$            ; no  C = 1
        ;
614$:   br      700$
699$:   halt
        ;
        ; case NZVC = 0111 -- N=0 Z=1 V=1 C=1 ------------------------
        ;
700$:   scc
        cln
        ;
        bne     799$            ; no  Z=0
        ;
701$:   beq     702$            ; yes Z=1
        halt
702$:   bge     799$            ; no  (N xor V) = 0
        ;
703$:   blt     704$            ; yes (N xor V) = 1
        halt
704$:   bgt     799$            ; no  (Z or (N xor V)) = 0
        ;
705$:   ble     706$            ; yes (Z or (N xor V)) = 1
        halt
706$:   bpl     707$            ; yes N = 0
        halt
707$:   bmi     799$            ; no  N = 1
        ;
708$:   bhi     799$            ; no  (C or Z) = 0
        ;
709$:   blos    710$            ; yes (C or Z) = 1
        halt
710$:   bvc     799$            ; no  V = 0
        ;
711$:   bvs     712$            ; yes V = 1
        halt
712$:   bcc     799$            ; no  C = 0
        ;
713$:   bcs     714$            ; yes C = 1
        halt
714$:   br      1000$
799$:   halt
        ;
        ; case NZVC = 1000 -- N=1 Z=0 V=0 C=0 ------------------------
        ;
1000$:  ccc
        sen
        ;
        bne     1001$           ; yes Z=0
        halt
1001$:  beq     1099$           ; no  Z=1
        ;
1002$:  bge     1099$           ; no  (N xor V) = 0
        ;
1003$:  blt     1004$           ; yes (N xor V) = 1
        halt
1004$:  bgt     1099$           ; no  (Z or (N xor V)) = 0
        ;
1005$:  ble     1006$           ; yes (Z or (N xor V)) = 1
        halt
1006$:  bpl     1099$           ; no  N = 0
        ;
1007$:  bmi     1008$           ; yes N = 1
        halt
1008$:  bhi     1009$           ; yes (C or Z) = 0
        halt
1009$:  blos    1099$           ; no  (C or Z) = 1
        ;
1010$:  bvc     1011$           ; yes V = 0
        halt
1011$:  bvs     1099$           ; no  V = 1
        ;
1012$:  bcc     1013$           ; yes C = 0
        halt
1013$:  bcs     1099$           ; no  C = 1
        ;
1014$:  br      1100$
1099$:  halt
        ;
        ; case NZVC = 1001 -- N=1 Z=0 V=0 C=1 ------------------------
        ;
1100$:  ccc
        <sen!sec>
        ;
        bne     1101$           ; yes Z=0
        halt
1101$:  beq     1199$           ; no  Z=1
        ;
1102$:  bge     1199$           ; no  (N xor V) = 0
        ;
1103$:  blt     1104$           ; yes (N xor V) = 1
        halt
1104$:  bgt     1199$           ; no  (Z or (N xor V)) = 0
        ;
1105$:  ble     1106$           ; yes (Z or (N xor V)) = 1
        halt
1106$:  bpl     1199$           ; no  N = 0
        ;
1107$:  bmi     1108$           ; yes N = 1
        halt
1108$:  bhi     1199$           ; no  (C or Z) = 0
        ;
1109$:  blos    1110$           ; yes (C or Z) = 1
        halt
1110$:  bvc     1111$           ; yes V = 0
        halt
1111$:  bvs     1199$           ; no  V = 1
        ;
1112$:  bcc     1199$           ; no  C = 0
        ;
1113$:  bcs     1114$           ; yes C = 1
        halt
1114$:  br      1200$
1199$:  halt
        ;
        ; case NZVC = 1010 -- N=1 Z=0 V=1 C=0 ------------------------
        ;
1200$:  ccc
        <sen!sev>
        ;
        bne     1201$           ; yes Z=0
        halt
1201$:  beq     1299$           ; no  Z=1
        ;
1202$:  bge     1203$           ; yes (N xor V) = 0
        halt
1203$:  blt     1299$           ; no  (N xor V) = 1
        ;
1204$:  bgt     1205$           ; yes (Z or (N xor V)) = 0
        halt
1205$:  ble     1299$           ; no  (Z or (N xor V)) = 1
        ;
1206$:  bpl     1299$           ; no  N = 0
        ;
1207$:  bmi     1208$           ; yes N = 1
        halt
1208$:  bhi     1209$           ; yes (C or Z) = 0
        halt
1209$:  blos    1299$           ; no  (C or Z) = 1
        ;
1210$:  bvc     1299$           ; no  V = 0
        ;
1211$:  bvs     1212$           ; yes V = 1
        halt
1212$:  bcc     1213$           ; yes C = 0
        halt
1213$:  bcs     1299$           ; no  C = 1
        ;
1214$:  br      1300$
1299$:  halt
        ;
        ; case NZVC = 1011 -- N=1 Z=0 V=1 C=1 ------------------------
        ;
1300$:  scc
        clz
        ;
        bne     1301$           ; yes Z=0
        halt
1301$:  beq     1399$           ; no  Z=1
        ;
1302$:  bge     1303$           ; yes (N xor V) = 0
        halt
1303$:  blt     1399$           ; no  (N xor V) = 1
        ;
1304$:  bgt     1305$           ; yes (Z or (N xor V)) = 0
        halt
1305$:  ble     1399$           ; no  (Z or (N xor V)) = 1
        ;
1306$:  bpl     1399$           ; no  N = 0
        ;
1307$:  bmi     1308$           ; yes N = 1
        halt
1308$:  bhi     1399$           ; no  (C or Z) = 0
        ;
1309$:  blos    1310$           ; yes (C or Z) = 1
        halt
1310$:  bvc     1399$           ; no  V = 0
        ;
1311$:  bvs     1312$           ; yes V = 1
        halt
1312$:  bcc     1399$           ; no  C = 0
        ;
1313$:  bcs     1314$           ; yes C = 1
        halt
1314$:  br      1400$
1399$:  halt
        ;
        ; case NZVC = 1100 -- N=1 Z=1 V=0 C=0 ------------------------
        ;
1400$:  ccc
        <sen!sez>
        ;
        bne     1499$           ; no  Z=0
        ;
1401$:  beq     1402$           ; yes Z=1
        halt
1402$:  bge     1499$           ; no  (N xor V) = 0
        ;
1403$:  blt     1404$           ; yes (N xor V) = 1
        halt
1404$:  bgt     1499$           ; no  (Z or (N xor V)) = 0
        ;
1405$:  ble     1406$           ; yes (Z or (N xor V)) = 1
        halt
1406$:  bpl     1499$           ; no  N = 0
        ;
1407$:  bmi     1408$           ; yes N = 1
        halt
1408$:  bhi     1499$           ; no  (C or Z) = 0
        ;
1409$:  blos    1410$           ; yes (C or Z) = 1
        halt
1410$:  bvc     1411$           ; yes V = 0
        halt
1411$:  bvs     1499$           ; no  V = 1
        ;
1412$:  bcc     1413$           ; yes C = 0
        halt
1413$:  bcs     1499$           ; no  C = 1
        ;
1414$:  br      1500$
1499$:  halt
        ;
        ; case NZVC = 1101 -- N=1 Z=1 V=0 C=1 ------------------------
        ;
1500$:  scc
        clv
        ;
        bne     1599$           ; no  Z=0
        ;
1501$:  beq     1502$           ; yes Z=1
        halt
1502$:  bge     1599$           ; no  (N xor V) = 0
        ;
1503$:  blt     1504$           ; yes (N xor V) = 1
        halt
1504$:  bgt     1599$           ; no  (Z or (N xor V)) = 0
        ;
1505$:  ble     1506$           ; yes (Z or (N xor V)) = 1
        halt
1506$:  bpl     1599$           ; no  N = 0
        ;
1507$:  bmi     1508$           ; yes N = 1
        halt
1508$:  bhi     1599$           ; no  (C or Z) = 0
        ;
1509$:  blos    1510$           ; yes (C or Z) = 1
        halt
1510$:  bvc     1511$           ; yes V = 0
        halt
1511$:  bvs     1599$           ; no  V = 1
        ;
1512$:  bcc     1599$           ; no  C = 0
        ;
1513$:  bcs     1514$           ; yes C = 1
        halt
1514$:  br      1600$
1599$:  halt
        ;
        ; case NZVC = 1110 -- N=1 Z=1 V=1 C=0 ------------------------
        ;
1600$:  scc
        clc
        ;
        bne     1699$           ; no  Z=0
        ;
1601$:  beq     1602$           ; yes Z=1
        halt
1602$:  bge     1603$           ; yes (N xor V) = 0
        halt
1603$:  blt     1699$           ; no  (N xor V) = 1
        ;
1604$:  bgt     1699$           ; no  (Z or (N xor V)) = 0
        ;
1605$:  ble     1606$           ; yes (Z or (N xor V)) = 1
        halt
1606$:  bpl     1699$           ; no  N = 0
        ;
1607$:  bmi     1608$           ; yes N = 1
        halt
1608$:  bhi     1699$           ; no  (C or Z) = 0
        ;
1609$:  blos    1610$           ; yes (C or Z) = 1
        halt
1610$:  bvc     1699$           ; no  V = 0
        ;
1611$:  bvs     1612$           ; yes V = 1
        halt
1612$:  bcc     1613$           ; yes C = 0
        halt
1613$:  bcs     1699$           ; no  C = 1
        ;
1614$:  br      1700$
1699$:  halt
        ;
        ; case NZVC = 1111 -- N=1 Z=1 V=1 C=1 ------------------------
        ;
1700$:  scc
        ;
        bne     1799$           ; no  Z=0
        ;
1701$:  beq     1702$           ; yes Z=1
        halt
1702$:  bge     1703$           ; yes (N xor V) = 0
        halt
1703$:  blt     1799$           ; no  (N xor V) = 1
        ;
1704$:  bgt     1799$           ; no  (Z or (N xor V)) = 0
        ;
1705$:  ble     1706$           ; yes (Z or (N xor V)) = 1
        halt
1706$:  bpl     1799$           ; no  N = 0
        ;
1707$:  bmi     1708$           ; yes N = 1
        halt
1708$:  bhi     1799$           ; no  (C or Z) = 0
        ;
1709$:  blos    1710$           ; yes (C or Z) = 1
        halt
1710$:  bvc     1799$           ; no  V = 0
        ;
1711$:  bvs     1712$           ; yes V = 1
        halt
1712$:  bcc     1799$           ; no  C = 0
        ;
1713$:  bcs     1714$           ; yes C = 1
        ;
1714$:  br      9999$
1799$:  halt
        ;
;
9999$:  iot                     ; end of test A1.2
;
; Test A2 -- sob +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     0 111 111 rrr bbb bbb ---- SOB
;
; Test A2.1 -- sob +++++++++++++++++++++++++++++++++++++++++++++++++++
;   check that SOB
;     a. decrements register
;     b. does not change cc
;     c. only falls through when register decremented to zero
;
ta0201: mov     #cp.psw,r5
        clr     (r5)
        mov     #3,r0           ; setup loop count
        ccc                     ; nzvc = 0000
        br      11$             ; branch to 1st SOB
;
10$:    hcmpeq  (r5),#cp0000    ; cc still 0000 ?
        hcmpeq  r0,#2           ; counter dec-ed ?
        scc                     ; now nzvc = 1111
        br      21$             ; branch to 2nd SOB
;
11$:    sob     r0,10$          ; 1st SOB (r0=3)
        halt                    ; should not fall through
;
20$:    hcmpeq  (r5),#cpnzvc    ; cc still 1111 ?
        hcmpeq  r0,#1           ; counter dec-ed ?
        ccc
        <sen!sez>               ; now nzvc = 1100
        br      31$             ; branch to 3rd SOB
;
21$:    sob     r0,20$          ; 2nd SOB (r0=2)
        halt                    ; should not fall through
;
30$:    halt                    ; should not branch now !
31$:    sob     r0,30$          ; 3rd SOB (r0=1 -> fall through)
        hcmpeq  (r5),#cpnz00    ; cc still 1100 ?
        htsteq  r0              ; counter dec-ed ?
;
; finally a typical simple SOB loop
;
        mov     #2,r0
        clr     r1
100$:   inc     r1
        sob     r0,100$
;
        htsteq  r0
        hcmpeq  r1,#2
;
9999$:  iot                     ; end of test A2.1
;
; Test A3 -- jmp +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     0 000 000 001 ddd ddd ---- JMP (mode /= R !!)
;
; Test A3.1 -- jmp + dsta +++++++++++++++++++++++++++++++++++++++++++++
;   check that JMP works for all modes
;
ta0301: mov     #10$,r2
        jmp     (r2)            ; mode = 1,reg
        halt
;
10$:    mov     #20$,r2
        jmp     (r2)+           ; mode = 2,reg
        halt
20$:    hcmpeq  r2,#20$+2
;
        mov     #40$+2,r2
        jmp     -(r2)           ; mode = 4,reg
        halt
40$:    hcmpeq  r2,#40$
;
        mov     #60$-10,r2
        jmp     10(r2)          ; mode = 6,reg
;
60$:    jmp     67$             ; mode = 6,pc  (rel)
        halt
;
67$:    jmp     @#37$           ; mode = 3,pc  (abs)
        halt
;
37$:    mov     #1030$,r3
        jmp     @(r3)+          ; mode = 3,reg
        halt
30$:    hcmpeq  r3,#1030$+2
;
        mov     #1050$+2,r3
        jmp     @-(r3)          ; mode = 5,reg
        halt
50$:    hcmpeq  r3,#1050$
;
        mov     #1070$-20,r3
        jmp     @20(r3)         ; mode = 7,reg
        halt
;
70$:    jmp     @1077$          ; mode = 7,pc  (ind)
        halt
;
77$:    br      9999$
;
1030$:  .word   30$
1050$:  .word   50$
1070$:  .word   70$
1077$:  .word   77$
;        
9999$:  iot                     ; end of test A3.1
;
; Test A3.2 -- jmp + cc +++++++++++++++++++++++++++++++++++++++++++++++
;   check that JMP doesnt change cc
;
ta0302: mov     #cp.psw,r5
        clr     (r5)
;
        ccc                     ; nzvc = 0000
        jmp     1$
        halt
1$:     hcmpeq  (r5),#cp0000    ; cc still 0000 ?
;
        scc                     ; nzvc = 1111
        jmp     @1002$
        halt
2$:     hcmpeq  (r5),#cpnzvc    ; cc still 1111 ?
        br      9999$        
;
1002$:  .word   2$
;
9999$:  iot                     ; end of test A3.2
;
; Test A4 -- jsr + rts +++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     0 000 100 rrr ddd ddd ---- JSR (mode /= R !!)
;     0 000 000 010 000 rrr ---- RTS
;
; Test A4.1 -- jsr + dsta +++++++++++++++++++++++++++++++++++++++++++++
;   check that JSR PC,xxx works for all modes
;
ta0401: mov     #1006$,r2
        mov     #2000$,r3
        mov     #3000$,r5
        clr     r4
;
        jsr     pc,(r2)+        ; mode = 2,reg  -> 1006  inc 6
        jsr     pc,(r2)         ; mode = 1,reg  -> 1005  inc 5
        jsr     pc,2(r2)        ; mode = 6,reg  -> 1004  inc 4
        jsr     pc,-(r2)        ; mode = 4,reg  -> 1006  inc 6
        jsr     pc,@(r3)+       ; mode = 3,reg  -> 1003  inc 3
        jsr     pc,@2(r3)       ; mode = 7,reg  -> 1001  inc 1
        jsr     pc,@-(r3)       ; mode = 5,reg  -> 1003  inc 3
;
        jmp     9999$
;
1006$:  inc     r4
1005$:  inc     r4
1004$:  inc     r4
1003$:  inc     r4
1002$:  inc     r4
1001$:  inc     r4
        hcmpeq  r4,(r5)+
        rts     pc
;
2000$:  .word   1003$
        .word   1002$
        .word   1001$
;
3000$:  .word   6
        .word   6+5
        .word   6+5+4
        .word   6+5+4+6
        .word   6+5+4+6+3
        .word   6+5+4+6+3+1
        .word   6+5+4+6+3+1+3
;
9999$:  iot                     ; end of test A4.1
;
; Test A4.2 -- jsr + cc +++++++++++++++++++++++++++++++++++++++++++++++
;   check that JSR and RTS doesnt change cc
;
ta0402: mov     #cp.psw,r5
        clr     (r5)
;
        ccc                     ; nzvc = 0000
        jsr     pc,100$         ; call with cp0000
        hcmpeq  (r5),#cpnzvc    ; expect cpnzvc
        scc
        jsr     pc,200$
        hcmpeq  (r5),#cp0000
        jmp     9999$
;
100$:   hcmpeq  (r5),#cp0000    ; expect cp0000
        scc                     ; return with cpnzvc
        rts     pc
;
200$:   hcmpeq  (r5),#cpnzvc    ; expect cpnzvc
        ccc                     ; return with cp0000
        rts     pc
;
9999$:  iot                     ; end of test A4.2
;
; Test A4.3 -- jsr r0-r5 ++++++++++++++++++++++++++++++++++++++++++++++
;   check that JSR and RTS for R0...R5 linkage
;   Note: use reserved opcodes as arguments to detect fall through
;
ta0403: clr     900$            ; reset call counter
        jsr     r0,100$
        jsr     r1,110$
        .word   000211
        jsr     r2,120$
        .word   000212
        jsr     r3,130$
        .word   000213
        jsr     r4,140$
        .word   000214
        jsr     r5,150$
        .word   000215
        .word   000216
        .word   000217
        hcmpeq  900$,#6.        ; check number of calls
        jmp     9999$
;
100$:   inc     900$
        rts     r0
;
110$:   inc     900$
        hcmpeq  (r1)+,#000211
        rts     r1
;
120$:   inc     900$
        hcmpeq  (r2)+,#000212
        rts     r2
;
130$:   inc     900$
        hcmpeq  (r3)+,#000213
        rts     r3
;
140$:   inc     900$
        hcmpeq  (r4)+,#000214
        rts     r4
;
150$:   inc     900$
        hcmpeq  (r5)+,#000215
        hcmpeq  (r5)+,#000216
        hcmpeq  (r5)+,#000217
        rts     r5
;
900$:   .word   0
;
9999$:  iot                     ; end of test A4.3
;
; Test A4.4 -- jsr sp and rts sp ++++++++++++++++++++++++++++++++++++++
;   In case of jsr sp and rts sp, the sp register is used both as linkage
;   register and implicitly as stack pointer. That interferes and gives
;   quite bizarre semantics, certainly never used, but should work
;   - jsr sp,<dst> will
;     - push current SP onto stack
;     - set SP to the location of following instruction
;     - jump to <dst>
;   - rts sp will
;     - set PC to current SP
;     - pop SP of the current stack
;       that will set SP to the opcode of instruction being returned to !
;
ta0404: hcmpeq  sp,#stack       ; check stack is default
        clr     100$            ; clear 'args' after jsr
        clr     100$+2
;
        jsr     sp,300$         ; will push SP to current stack
100$:   .word   0               ; 'args', will be overwritten
        .word   0               ;
;
200$:   clr     r1              ; return instruction, also loaded SP
        hcmpeq  sp,200$         ; check loaded SP
        mov     #stack-2,sp     ; restore stack to where jsr pushed it
;
; w11 saves original sp, 11/70,SimH,e11 save sp after it was decremented
; This is considered a minor deviation (jsr sp never used!)
;
        mov     #stack,r1
        tstb    systyp          ; check environment
        bge     210$            ; >=0 is on w11
        sub     #2,r1           ; if not, subtract 2 (now sp-2)
210$:   hcmpeq  (sp)+,r1        ; check jsr stored stack pointer
        hcmpeq  100$,#123       ; check writes via SP in routine
        hcmpeq  100$+2,#345     ; check writes via SP in routine
        jmp     9999$
;
; this routine must never 'push' that will overwrite the calling jsr !!
300$:   mov     #123,(sp)+
        mov     #345,(sp)+
        rts     sp
;
9999$:  iot                     ; end of test A4.4
;
; Test A5 -- mark ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     0 000 110 100 nnn nnn ---- MARK
;
; Test A5.1 -- mark +++++++++++++++++++++++++++++++++++++++++++++++++++
;   check that MARK works
;   Note: this instruction is a bastard, the only PDP-11 instruction which
;         is outright ugly and should have neven been invented.
;         Not used in all surviving OS so this test is most likely the only
;         occasion where MARK is executed on a target system.
;
ta0501: mov     #123456,r5      ; token
        mov     r5,-(sp)        ; from here processor handbook example
        mov     #101,-(sp)      ; push 1st parameter
        mov     #102,-(sp)      ; push 2nd parameter
        mov     #103,-(sp)      ; push 3rd parameter
        mov     #<mark!3>,-(sp) ; push MARK 3
        mov     sp,r5           ; push address of MARK 3
        jsr     pc,100$         ; call procedure
        hcmpeq  r5,#123456      ; check token
        jmp     9999$
;
; stack of procedure when called:
;                        content
;        12(sp)  10(r5)  old r5
;        10(sp)   6(r5)  param1
;         6(sp)   4(r5)  param2
;         4(sp)   2(r5)  param3
;         2(sp)    (r5)  mark 3
;          (sp)          return pc
;
100$:   hcmpeq  6(r5),#101      ; check 1st parameter
        hcmpeq  4(r5),#102      ; check 2nd parameter
        hcmpeq  2(r5),#103      ; check 3rd parameter
        rts     r5              ; return
;
9999$:  iot                     ; end of test A5.1
;
; Section B: unary instructions (word) =======================================
;   B1    inc
;   B2    dec
;   B3    com
;   B4    neg
;   B5    adc
;   B6    sbc
;   B7    tst
;   B8    ror
;   B9    rol
;   B10   asr
;   B11   asl
;   B12   clr
;   B13   sxt
;   B14   swab
;
        jmp     tb0101
;
; test driver for unary instruction tests
;
top1wr: mov     (r5),101$       ; setup cc setter
        mov     2(r5),102$      ; setup instruction
        mov     4(r5),r4        ; setup expect data pointer
        mov     6(r5),r3        ; setup expect end
        mov     #cp.psw,r2
;
100$:   mov     (r4)+,r1        ; setup dst
        ccc                     ; clear cc
101$:   nop                     ; REPLACED with cc setter
102$:   nop                     ; REPLACED with instruction, e.g. inc r1
        hcmpeq  (r2),(r4)+      ; check psw
        hcmpeq  r1,(r4)+        ; check new dst
        cmp     r4,r3           ; more to do ?
        blo     100$
        return
;
top1wm: mov     (r5),101$       ; setup cc setter
        mov     2(r5),102$      ; setup instruction
        mov     4(r5),r4        ; setup expect data pointer
        mov     6(r5),r3        ; setup expect end
        mov     #200$,r1        ; setup dst pointer
        mov     #cp.psw,r2
;
100$:   mov     (r4)+,(r1)      ; setup old dst
        ccc                     ; clear cc
101$:   nop                     ; REPLACED with cc setter
102$:   nop                     ; REPLACED with instruction, e.g. inc (r1)
        hcmpeq  (r2),(r4)+      ; check psw
        hcmpeq  (r1),(r4)+      ; check new dst
        cmp     r4,r3           ; more to do ?
        blo     100$
        return
;
200$:   .word   0
;
; Test B1 -- inc +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     0 000 101 010 ddd ddd NZV- INC
;
; Test B1.1 -- inc instruction +++++++++++++++++++++++++++++++++++++++
;
tb0101: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests (with ccc)
        call    top1wr
        mov     #2000$,r5       ; mem mode tests (with scc)
        call    top1wm
        jmp     9999$
;
1000$:  ccc                     ; c=0
        inc     r1              ; inc preserves c, so stays 0
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
1010$:  .word   000000, cp0000, 000001
        .word   000001, cp0000, 000002
        .word   077776, cp0000, 077777
        .word   077777, cpn0v0, 100000
        .word   100000, cpn000, 100001
        .word   100001, cpn000, 100002
        .word   177776, cpn000, 177777
        .word   177777, cp0z00, 000000
1011$:
;
2000$:  scc                     ; c=1
        inc     (r1)            ; inc preserves c, so stays 1
        .word   2010$
        .word   2011$
;
;               olddst     psw  newdst
2010$:  .word   000000, cp000c, 000001
        .word   000001, cp000c, 000002
        .word   077776, cp000c, 077777
        .word   077777, cpn0vc, 100000
        .word   100000, cpn00c, 100001
        .word   100001, cpn00c, 100002
        .word   177776, cpn00c, 177777
        .word   177777, cp0z0c, 000000
2011$:
;
9999$:  iot                     ; end of test B1.1
;
; Test B2 -- dec +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     0 000 101 011 ddd ddd NZV- DEC
;
; Test B2.1 -- dec instruction +++++++++++++++++++++++++++++++++++++++
;
tb0201: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests (with ccc)
        call    top1wr
        mov     #2000$,r5       ; mem mode tests (with scc)
        call    top1wm
        jmp     9999$
;
1000$:  ccc                     ; c=0
        dec     r1              ; dec preserves c, so stays 0
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
1010$:  .word   000000, cpn000, 177777
        .word   000001, cp0z00, 000000
        .word   077776, cp0000, 077775
        .word   077777, cp0000, 077776
        .word   100000, cp00v0, 077777
        .word   100001, cpn000, 100000
        .word   177776, cpn000, 177775
        .word   177777, cpn000, 177776
1011$:
;
2000$:  scc                     ; c=1
        dec     (r1)            ; dec preserves c, so stays 1
        .word   2010$
        .word   2011$
;
;               olddst     psw  newdst
2010$:  .word   000000, cpn00c, 177777
        .word   000001, cp0z0c, 000000
        .word   077776, cp000c, 077775
        .word   077777, cp000c, 077776
        .word   100000, cp00vc, 077777
        .word   100001, cpn00c, 100000
        .word   177776, cpn00c, 177775
        .word   177777, cpn00c, 177776 
2011$:
;
9999$:  iot                     ; end of test B2.1
;
; Test B3 -- com +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     0 000 101 001 ddd ddd NZ01 COM
;
; Test B3.1 -- com instruction +++++++++++++++++++++++++++++++++++++++
;
tb0301: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests (with ccc)
        call    top1wr
        mov     #2000$,r5       ; mem mode tests (with scc)
        call    top1wm
        jmp     9999$
;
1000$:  ccc
        com     r1
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
1010$:  .word   000000, cpn00c, 177777
        .word   000001, cpn00c, 177776
        .word   077777, cpn00c, 100000
        .word   100000, cp000c, 077777
        .word   177777, cp0z0c, 000000
1011$:
;
2000$:  scc
        com     (r1)
        .word   1010$
        .word   1011$
;
9999$:  iot                     ; end of test B3.1
;
; Test B4 -- neg +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     0 000 101 100 ddd ddd NZVC NEG
;
; Test B4.1 -- neg instruction +++++++++++++++++++++++++++++++++++++++
;
tb0401: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests (with ccc)
        call    top1wr
        mov     #2000$,r5       ; mem mode tests (with scc)
        call    top1wm
        jmp     9999$
;
1000$:  ccc
        neg     r1
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
1010$:  .word   000000, cp0z00, 000000
        .word   000001, cpn00c, 177777
        .word   077777, cpn00c, 100001
        .word   100000, cpn0vc, 100000
        .word   177777, cp000c, 000001
1011$:
;
2000$:  scc
        neg     (r1)
        .word   1010$
        .word   1011$
;
9999$:  iot                     ; end of test B4.1
;
; Test B5 -- adc +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     0 000 101 101 ddd ddd NZVC ADC
;
; Test B5.1 -- adc instruction +++++++++++++++++++++++++++++++++++++++
;
tb0501: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests (with ccc; C=0)
        call    top1wr
        mov     #2000$,r5       ; mem mode tests (with scc; C=1)
        call    top1wm
        jmp     9999$
;
1000$:  ccc                     ; c=0
        adc     r1
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
1010$:  .word   000000, cp0z00, 000000
        .word   000001, cp0000, 000001
        .word   077777, cp0000, 077777
        .word   100000, cpn000, 100000
        .word   177777, cpn000, 177777
1011$:
;
2000$:  scc                     ; c=1
        adc     (r1)
        .word   2010$
        .word   2011$
;
;               olddst  psw     newdst
2010$:  .word   000000, cp0000, 000001
        .word   000001, cp0000, 000002
        .word   077777, cpn0v0, 100000
        .word   100000, cpn000, 100001
        .word   177777, cp0z0c, 000000
2011$:
;
9999$:  iot                     ; end of test B5.1
;
; Test B6 -- sbc +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     0 000 101 110 ddd ddd NZVC SBC
;
; Test B6.1 -- sbc instruction +++++++++++++++++++++++++++++++++++++++
;
tb0601: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests (with ccc; C=0)
        call    top1wr
        mov     #2000$,r5       ; mem mode tests (with scc; C=1)
        call    top1wm
        jmp     9999$
;
1000$:  ccc                     ; c=0
        sbc     r1
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
1010$:  .word   000000, cp0z00, 000000
        .word   000001, cp0000, 000001
        .word   077777, cp0000, 077777
        .word   100000, cpn000, 100000
        .word   177777, cpn000, 177777
1011$:
;
2000$:  scc                     ; c=1
        sbc     (r1)
        .word   2010$
        .word   2011$
;
;               olddst  psw     newdst
2010$:  .word   000000, cpn00c, 177777
        .word   000001, cp0z00, 000000
        .word   077777, cp0000, 077776
        .word   100000, cp00v0, 077777
        .word   177777, cpn000, 177776
2011$:
;
9999$:  iot                     ; end of test B6.1
;
; Test B7 -- tst +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     0 000 101 111 ddd ddd NZ00 TST
;
; Test B7.1 -- tst instruction +++++++++++++++++++++++++++++++++++++++
;
tb0701: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests (with ccc)
        call    top1wr
        mov     #2000$,r5       ; mem mode tests (with scc)
        call    top1wm
        jmp     9999$
;
1000$:  ccc
        tst     r1
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
1010$:  .word   000000, cp0z00, 000000
        .word   000001, cp0000, 000001
        .word   077777, cp0000, 077777
        .word   100000, cpn000, 100000
        .word   177777, cpn000, 177777
1011$:
;
2000$:  scc
        tst     (r1)
        .word   1010$
        .word   1011$
;
9999$:  iot                     ; end of test B7.1
;
; Test B8 -- ror +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     0 000 110 000 ddd ddd NZVC ROR
;
; Test B8.1 -- ror instruction +++++++++++++++++++++++++++++++++++++++
;
tb0801: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests (with ccc; C=0)
        call    top1wr
        mov     #2000$,r5       ; mem mode tests (with scc; C=1)
        call    top1wm
        jmp     9999$
;
1000$:  ccc                     ; c=0
        ror     r1
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
1010$:  .word   000000, cp0z00, 000000
        .word   000001, cp0zvc, 000000
        .word   100000, cp0000, 040000
        .word   000100, cp0000, 000040
        .word   000101, cp00vc, 000040
        .word   040100, cp0000, 020040
        .word   100100, cp0000, 040040
1011$:
;
2000$:  scc                     ; c=1
        ror     (r1)
        .word   2010$
        .word   2011$
;
;               olddst  psw     newdst
2010$:  .word   000000, cpn0v0, 100000
        .word   000001, cpn00c, 100000
        .word   100000, cpn0v0, 140000
        .word   000100, cpn0v0, 100040
        .word   000101, cpn00c, 100040
        .word   040100, cpn0v0, 120040
        .word   100100, cpn0v0, 140040
2011$:
;
;               olddst  psw     newdst
;
9999$:  iot                     ; end of test B8.1
;
; Test B9 -- rol +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     0 000 110 001 ddd ddd NZVC ROL
;
; Test B9.1 -- rol instruction +++++++++++++++++++++++++++++++++++++++
;
tb0901: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests (with ccc; C=0)
        call    top1wr
        mov     #2000$,r5       ; mem mode tests (with scc; C=1)
        call    top1wm
        jmp     9999$
;
1000$:  ccc                     ; c=0
        rol     r1
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
1010$:  .word   000000, cp0z00, 000000
        .word   000001, cp0000, 000002
        .word   100000, cp0zvc, 000000
        .word   000100, cp0000, 000200
        .word   000101, cp0000, 000202
        .word   040100, cpn0v0, 100200
        .word   100100, cp00vc, 000200
1011$:
;
2000$:  scc                     ; c=1
        rol     (r1)
        .word   2010$
        .word   2011$
;
;               olddst  psw     newdst
2010$:  .word   000000, cp0000, 000001
        .word   000001, cp0000, 000003
        .word   100000, cp00vc, 000001
        .word   000100, cp0000, 000201
        .word   000101, cp0000, 000203
        .word   040100, cpn0v0, 100201
        .word   100100, cp00vc, 000201
2011$:
;
;               olddst  psw     newdst
;
9999$:  iot                     ; end of test B9.1
;
; Test B10 -- asr ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     0 000 110 010 ddd ddd NZVC ASR
;
; Test B10.1 -- asr instruction ++++++++++++++++++++++++++++++++++++++
;
tb1001: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests (with ccc)
        call    top1wr
        mov     #2000$,r5       ; mem mode tests (with scc)
        call    top1wm
        jmp     9999$
;
1000$:  ccc
        asr     r1
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
1010$:  .word   000000, cp0z00, 000000
        .word   000001, cp0zvc, 000000
        .word   100000, cpn0v0, 140000
        .word   000100, cp0000, 000040
        .word   000101, cp00vc, 000040
        .word   040100, cp0000, 020040
        .word   100100, cpn0v0, 140040
1011$:
;
2000$:  scc
        asr     (r1)
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
;
9999$:  iot                     ; end of test B10.1
;
; Test B11 -- asl ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     0 000 110 011 ddd ddd NZVC ASL
;
; Test B11.1 -- asl instruction ++++++++++++++++++++++++++++++++++++++
;
tb1101: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests (with ccc)
        call    top1wr
        mov     #2000$,r5       ; mem mode tests (with scc)
        call    top1wm
        jmp     9999$
;
1000$:  ccc
        asl     r1
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
1010$:  .word   000000, cp0z00, 000000
        .word   000001, cp0000, 000002
        .word   100000, cp0zvc, 000000
        .word   000100, cp0000, 000200
        .word   000101, cp0000, 000202
        .word   040100, cpn0v0, 100200
        .word   100100, cp00vc, 000200
1011$:
;
2000$:  scc
        asl     (r1)
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
;
9999$:  iot                     ; end of test B11.1
;
; Test B12 -- clr ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     0 000 101 000 ddd ddd 0100 CLR
;
; Test B12.1 -- clr instruction ++++++++++++++++++++++++++++++++++++++
;
tb1201: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests (with ccc)
        call    top1wr
        mov     #2000$,r5       ; mem mode tests (with scc)
        call    top1wm
        jmp     9999$
;
1000$:  ccc
        clr     r1
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
1010$:  .word   000000, cp0z00, 000000
        .word   177777, cp0z00, 000000
1011$:
;
2000$:  scc                     ; c=1
        clr     (r1)
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
;
9999$:  iot                     ; end of test B12.1
;
; Test B13 -- sxt ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     0 000 110 111 ddd ddd -Z0- SXT
;
; Test B13.1 -- sxt instruction ++++++++++++++++++++++++++++++++++++++
;
tb1301: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests (with ccc; N=0)
        call    top1wr
        mov     #2000$,r5       ; mem mode tests (with scc; N=1)
        call    top1wm
        jmp     9999$
;
1000$:  ccc                     ; n=0
        sxt     r1
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
1010$:  .word   000000, cp0z00, 000000
        .word   177777, cp0z00, 000000
1011$:
;
2000$:  scc                     ; n=1
        sxt     (r1)
        .word   2010$
        .word   2011$
;
;               olddst  psw     newdst
2010$:  .word   000000, cpn00c, 177777
        .word   177777, cpn00c, 177777
2011$:
;
;               olddst  psw     newdst
;
9999$:  iot                     ; end of test B13.1
;
; Test B14 -- swab +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     0 000 000 011 ddd ddd NZ00 SWAB
;
; Test B14.1 -- swab instruction +++++++++++++++++++++++++++++++++++++
;
tb1401: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests (with ccc)
        call    top1wr
        mov     #2000$,r5       ; mem mode tests (with scc)
        call    top1wm
        jmp     9999$
;
1000$:  ccc
        swab    r1
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
1010$:  .word   000000, cp0z00, 000000
        .word   000001, cp0z00, 000400
        .word   000200, cp0z00, 100000
        .word   000400, cp0000, 000001
        .word   100000, cpn000, 000200
        .word   000401, cp0000, 000401
        .word   000600, cp0000, 100001
        .word   100001, cpn000, 000600
        .word   100200, cpn000, 100200
1011$:
;
2000$:  scc
        swab    (r1)
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
;
9999$:  iot                     ; end of test B14.1
;
; Section C: binary instructions (word) ======================================
;   C1    add
;   C2    sub
;   C3    bic
;   C4    bis
;   C5    cmp
;   C6    bit
;   C7    mov
;
        jmp     tc0101
;
; test driver for binary instruction tests
;
top2wr: mov     (r5),101$       ; setup cc setter
        mov     2(r5),102$      ; setup instruction
        mov     4(r5),r4        ; setup expect data pointer
        mov     6(r5),r3        ; setup expect end
        mov     #cp.psw,r2
;
100$:   mov     (r4)+,r0        ; setup src
        mov     (r4)+,r1        ; setup old dst
        ccc                     ; clear cc
101$:   nop                     ; REPLACED with cc setter
102$:   nop                     ; REPLACED with instruction, e.g. add r0,r1
        hcmpeq  (r2),(r4)+      ; check psw
        hcmpeq  r1,(r4)+        ; check new dst
        cmp     r4,r3           ; more to do ?
        blo     100$
        return
;
top2wm: mov     (r5),101$       ; setup cc setter
        mov     2(r5),102$      ; setup instruction
        mov     4(r5),r4        ; setup expect data pointer
        mov     6(r5),r3        ; setup expect end
        mov     #200$,r0        ; setup src pointer
        mov     #300$,r1        ; setup dst pointer
        mov     #cp.psw,r2
;
100$:   mov     (r4)+,(r0)      ; setup src
        mov     (r4)+,(r1)      ; setup old dst
        ccc                     ; clear cc
101$:   nop                     ; REPLACED with cc setter
102$:   nop                     ; REPLACED with instruction, e.g. add (r0),(r1)
        hcmpeq  (r2),(r4)+      ; check psw
        hcmpeq  (r1),(r4)+      ; check new dst
        cmp     r4,r3           ; more to do ?
        blo     100$
        return
;
200$:   .word   0
300$:   .word   0
;
; Test C1 -- add +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     0 110 sss sss ddd ddd NZVC ADD
;
; Test C1.1 -- add instruction +++++++++++++++++++++++++++++++++++++++
;
tc0101: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests (with ccc)
        call    top2wr
        mov     #2000$,r5       ; mem mode tests (with scc)
        call    top2wm
        jmp     9999$
;
1000$:  ccc
        add     r0,r1
        .word   1010$
        .word   1011$
;
;                  src  olddst     psw  newdst
1010$:  .word   000000, 000000, cp0z00, 000000
        .word   000001, 000000, cp0000, 000001
        .word   077777, 000000, cp0000, 077777
        .word   100000, 000000, cpn000, 100000
        .word   100001, 000000, cpn000, 100001
        .word   177777, 000000, cpn000, 177777

        .word   000000, 000001, cp0000, 000001
        .word   000001, 000001, cp0000, 000002
        .word   077776, 000001, cp0000, 077777
        .word   077777, 000001, cpn0v0, 100000
        .word   100000, 000001, cpn000, 100001
        .word   100001, 000001, cpn000, 100002
        .word   177776, 000001, cpn000, 177777
        .word   177777, 000001, cp0z0c, 000000

        .word   000001, 077776, cp0000, 077777
        .word   000002, 077776, cpn0v0, 100000
        .word   077777, 077776, cpn0v0, 177775
        .word   100000, 077776, cpn000, 177776
        .word   100001, 077776, cpn000, 177777
        .word   100002, 077776, cp0z0c, 000000
        .word   100003, 077776, cp000c, 000001
        .word   177776, 077776, cp000c, 077774
        .word   177777, 077776, cp000c, 077775

        .word   000001, 077777, cpn0v0, 100000
        .word   000002, 077777, cpn0v0, 100001
        .word   077777, 077777, cpn0v0, 177776
        .word   100000, 077777, cpn000, 177777
        .word   100001, 077777, cp0z0c, 000000
        .word   100002, 077777, cp000c, 000001
        .word   177776, 077777, cp000c, 077775
        .word   177777, 077777, cp000c, 077776

        .word   000001, 100000, cpn000, 100001
        .word   000002, 100000, cpn000, 100002
        .word   077777, 100000, cpn000, 177777
        .word   100000, 100000, cp0zvc, 000000
        .word   100001, 100000, cp00vc, 000001
        .word   100002, 100000, cp00vc, 000002
        .word   177776, 100000, cp00vc, 077776
        .word   177777, 100000, cp00vc, 077777

        .word   000001, 100001, cpn000, 100002
        .word   000002, 100001, cpn000, 100003
        .word   077777, 100001, cp0z0c, 000000
        .word   100000, 100001, cp00vc, 000001
        .word   100001, 100001, cp00vc, 000002
        .word   177776, 100001, cp00vc, 077777
        .word   177777, 100001, cpn00c, 100000

        .word   000001, 177776, cpn000, 177777
        .word   000002, 177776, cp0z0c, 000000
        .word   077777, 177776, cp000c, 077775
        .word   100000, 177776, cp00vc, 077776
        .word   100001, 177776, cp00vc, 077777
        .word   100002, 177776, cpn00c, 100000
        .word   177776, 177776, cpn00c, 177774
        .word   177777, 177776, cpn00c, 177775

        .word   000001, 177777, cp0z0c, 000000
        .word   000002, 177777, cp000c, 000001
        .word   077777, 177777, cp000c, 077776
        .word   100000, 177777, cp00vc, 077777
        .word   100001, 177777, cpn00c, 100000
        .word   100002, 177777, cpn00c, 100001
        .word   177776, 177777, cpn00c, 177775
        .word   177777, 177777, cpn00c, 177776
1011$:
;
2000$:  scc
        add     (r0),(r1)
        .word   1010$
        .word   1011$
;
9999$:  iot                     ; end of test C1.1
;
; Test C2 -- sub +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     1 110 sss sss ddd ddd NZVC SUB
;
; Test C2.1 -- sub instruction +++++++++++++++++++++++++++++++++++++++
;
tc0201: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests (with ccc)
        call    top2wr
        mov     #2000$,r5       ; mem mode tests (with scc)
        call    top2wm
        jmp     9999$
;
1000$:  ccc
        sub     r0,r1
        .word   1010$
        .word   1011$
;
;                  src  olddst     psw  newdst
1010$:  .word   000000, 000000, cp0z00, 000000
        .word   000001, 000000, cpn00c, 177777
        .word   077777, 000000, cpn00c, 100001
        .word   100000, 000000, cpn0vc, 100000
        .word   100001, 000000, cp000c, 077777
        .word   177777, 000000, cp000c, 000001

        .word   000000, 000001, cp0000, 000001
        .word   000001, 000001, cp0z00, 000000
        .word   077777, 000001, cpn00c, 100002
        .word   100000, 000001, cpn0vc, 100001
        .word   100001, 000001, cpn0vc, 100000
        .word   100002, 000001, cp000c, 077777
        .word   177776, 000001, cp000c, 000003
        .word   177777, 000001, cp000c, 000002

        .word   000001, 077776, cp0000, 077775
        .word   077775, 077776, cp0000, 000001
        .word   077776, 077776, cp0z00, 000000
        .word   077777, 077776, cpn00c, 177777
        .word   100000, 077776, cpn0vc, 177776
        .word   100001, 077776, cpn0vc, 177775
        .word   177775, 077776, cpn0vc, 100001
        .word   177776, 077776, cpn0vc, 100000
        .word   177777, 077776, cp000c, 077777

        .word   000001, 077777, cp0000, 077776
        .word   077775, 077777, cp0000, 000002
        .word   077776, 077777, cp0000, 000001
        .word   077777, 077777, cp0z00, 000000
        .word   100000, 077777, cpn0vc, 177777
        .word   100001, 077777, cpn0vc, 177776
        .word   177776, 077777, cpn0vc, 100001
        .word   177777, 077777, cpn0vc, 100000

        .word   000001, 100000, cp00v0, 077777
        .word   000002, 100000, cp00v0, 077776
        .word   077776, 100000, cp00v0, 000002
        .word   077777, 100000, cp00v0, 000001
        .word   100000, 100000, cp0z00, 000000
        .word   100001, 100000, cpn00c, 177777
        .word   177776, 100000, cpn00c, 100002
        .word   177777, 100000, cpn00c, 100001

        .word   000001, 100001, cpn000, 100000
        .word   000002, 100001, cp00v0, 077777
        .word   077776, 100001, cp00v0, 000003
        .word   077777, 100001, cp00v0, 000002
        .word   100000, 100001, cp0000, 000001
        .word   100001, 100001, cp0z00, 000000
        .word   177776, 100001, cpn00c, 100003
        .word   177777, 100001, cpn00c, 100002

        .word   000001, 177776, cpn000, 177775
        .word   077775, 177776, cpn000, 100001
        .word   077776, 177776, cpn000, 100000
        .word   077777, 177776, cp00v0, 077777
        .word   100000, 177776, cp0000, 077776
        .word   100001, 177776, cp0000, 077775
        .word   177775, 177776, cp0000, 000001
        .word   177776, 177776, cp0z00, 000000
        .word   177777, 177776, cpn00c, 177777

        .word   000001, 177777, cpn000, 177776
        .word   077776, 177777, cpn000, 100001
        .word   077777, 177777, cpn000, 100000
        .word   100000, 177777, cp0000, 077777
        .word   100001, 177777, cp0000, 077776
        .word   177776, 177777, cp0000, 000001
        .word   177777, 177777, cp0z00, 000000
1011$:
;
2000$:  scc
        sub     (r0),(r1)
        .word   1010$
        .word   1011$
;
9999$:  iot                     ; end of test C2.1
;
; Test C3 -- bic +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     0 100 sss sss ddd ddd NZ0- BIC
;
; Test C3.1 -- bic instruction +++++++++++++++++++++++++++++++++++++++
;
tc0301: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests (with ccc)
        call    top2wr
        mov     #2000$,r5       ; mem mode tests (with scc)
        call    top2wm
        jmp     9999$
;
1000$:  ccc
        bic     r0,r1
        .word   1010$
        .word   1011$
;
;                  src  olddst     psw  newdst
1010$:  .word   000000, 000000, cp0z00, 000000
        .word   177777, 000000, cp0z00, 000000

        .word   000000, 077077, cp0000, 077077
        .word   070007, 077077, cp0000, 007070
        .word   177777, 077077, cp0z00, 000000

        .word   000000, 100770, cpn000, 100770
        .word   000070, 100770, cpn000, 100700
        .word   100700, 100770, cp0000, 000070
        .word   177777, 100770, cp0z00, 000000
1011$:
;
2000$:  scc
        bic     (r0),(r1)
        .word   2010$
        .word   2011$
;
;                  src  olddst     psw  newdst
2010$:  .word   000000, 000000, cp0z0c, 000000
        .word   177777, 000000, cp0z0c, 000000

        .word   000000, 077077, cp000c, 077077
        .word   070007, 077077, cp000c, 007070
        .word   177777, 077077, cp0z0c, 000000

        .word   000000, 100770, cpn00c, 100770
        .word   000070, 100770, cpn00c, 100700
        .word   100700, 100770, cp000c, 000070
        .word   177777, 100770, cp0z0c, 000000

2011$:
;
9999$:  iot                     ; end of test C3.1
;
; Test C4 -- bis +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     0 101 sss sss ddd ddd NZ0- BIS
;
; Test C4.1 -- bis instruction +++++++++++++++++++++++++++++++++++++++
;
tc0401: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests (with ccc)
        call    top2wr
        mov     #2000$,r5       ; mem mode tests (with scc)
        call    top2wm
        jmp     9999$
;
1000$:  ccc
        bis     r0,r1
        .word   1010$
        .word   1011$
;
;                  src  olddst     psw  newdst
1010$:  .word   000000, 000000, cp0z00, 000000
        .word   077077, 000000, cp0000, 077077
        .word   100770, 000000, cpn000, 100770

        .word   000000, 070007, cp0000, 070007
        .word   007070, 070007, cp0000, 077077
        .word   100770, 070007, cpn000, 170777

        .word   000000, 100770, cpn000, 100770
        .word   007070, 100770, cpn000, 107770
1011$:
;
2000$:  scc
        bis     (r0),(r1)
        .word   2010$
        .word   2011$
;
;                  src  olddst     psw  newdst
2010$:  .word   000000, 000000, cp0z0c, 000000
        .word   077077, 000000, cp000c, 077077
        .word   100770, 000000, cpn00c, 100770

        .word   000000, 070007, cp000c, 070007
        .word   007070, 070007, cp000c, 077077
        .word   100770, 070007, cpn00c, 170777

        .word   000000, 100770, cpn00c, 100770
        .word   007070, 100770, cpn00c, 107770

2011$:
;
9999$:  iot                     ; end of test C4.1
;
; Test C5 -- cmp +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     0 010 sss sss ddd ddd NZVC CMP
;
; Test C5.1 -- cmp instruction +++++++++++++++++++++++++++++++++++++++
;
tc0501: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests (with ccc)
        call    top2wr
        mov     #2000$,r5       ; mem mode tests (with scc)
        call    top2wm
        jmp     9999$
;
1000$:  ccc
        cmp     r0,r1
        .word   1010$
        .word   1011$
;
;                  src  olddst     psw  newdst    ; src-dst
1010$:  .word   000000, 000000, cp0z00, 000000    ; (000000)
        .word   000001, 000000, cp0000, 000000    ; (000001)
        .word   177777, 000000, cpn000, 000000    ; (177777)
        .word   000000, 000001, cpn00c, 000001    ; (177777+C)
        .word   000001, 000001, cp0z00, 000001    ; (000000)
        .word   177777, 000001, cpn000, 000001    ; (177776)
        .word   077776, 077777, cpn00c, 077777    ; (177777+C)
        .word   077777, 077777, cp0z00, 077777    ; (000000)
        .word   100000, 077777, cp00v0, 077777    ; (000001)
        .word   000001, 077777, cpn00c, 077777    ; (100002+C)
        .word   177777, 077777, cpn000, 077777    ; (100000)
        .word   077777, 100000, cpn0vc, 100000    ; (177777+C)
        .word   100000, 100000, cp0z00, 100000    ; (000000)
        .word   100001, 100000, cp0000, 100000    ; (000001)
        .word   000001, 100000, cpn0vc, 100000    ; (100001+C)
        .word   177777, 100000, cp0000, 100000    ; (077777)
        .word   000000, 177777, cp000c, 177777    ; (000001+C)
        .word   000001, 177777, cp000c, 177777    ; (000002+C)
        .word   177777, 177777, cp0z00, 177777    ; (000000)
1011$:
;
2000$:  scc
        cmp     (r0),(r1)
        .word   1010$
        .word   1011$
;
9999$:  iot                     ; end of test C5.1
;
; Test C6 -- bit +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     0 011 sss sss ddd ddd NZ0- BIT
;
; Test C6.1 -- bit instruction +++++++++++++++++++++++++++++++++++++++
;
tc0601: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests (with ccc)
        call    top2wr
        mov     #2000$,r5       ; mem mode tests (with scc)
        call    top2wm
        jmp     9999$
;
1000$:  ccc
        bit     r0,r1
        .word   1010$
        .word   1011$
;
;                  src  olddst     psw  newdst    ; src&dst
1010$:  .word   000000, 000000, cp0z00, 000000    ; (000000)
        .word   000011, 000000, cp0z00, 000000    ; (000000)
        .word   000011, 000110, cp0000, 000110    ; (000010)
        .word   000011, 001100, cp0z00, 001100    ; (000000)
        .word   110000, 011000, cp0000, 011000    ; (010000)
        .word   110000, 110000, cpn000, 110000    ; (110000)
1011$:
;
2000$:  scc
        bit     (r0),(r1)
        .word   2010$
        .word   2011$
;
;                  src  olddst     psw  newdst    ; src&dst
2010$:  .word   000000, 000000, cp0z0c, 000000    ; (000000)
        .word   000011, 000000, cp0z0c, 000000    ; (000000)
        .word   000011, 000110, cp000c, 000110    ; (000010)
        .word   000011, 001100, cp0z0c, 001100    ; (000000)
        .word   110000, 011000, cp000c, 011000    ; (010000)
        .word   110000, 110000, cpn00c, 110000    ; (110000)
2011$:
;
9999$:  iot                     ; end of test C6.1
;
; Test C7 -- mov +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     0 001 sss sss ddd ddd NZ0- MOV
;
; Test C7.1 -- mov instruction +++++++++++++++++++++++++++++++++++++++
;
tc0701: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests (with ccc; c=0)
        call    top2wr
        mov     #2000$,r5       ; mem mode tests (with scc; c=1)
        call    top2wm
        jmp     9999$
;
1000$:  ccc                     ; c=0
        mov     r0,r1
        .word   1010$
        .word   1011$
;
;                  src  olddst     psw  newdst
1010$:  .word   000000, 000000, cp0z00, 000000
        .word   000001, 000000, cp0000, 000001
        .word   100000, 000000, cpn000, 100000
1011$:
;
2000$:  scc                     ; c=1
        mov     (r0),(r1)
        .word   2010$
        .word   2011$
;
;                  src  olddst     psw  newdst
2010$:  .word   000000, 177777, cp0z0c, 000000
        .word   000001, 177777, cp000c, 000001
        .word   100000, 177777, cpn00c, 100000
2011$:
;
9999$:  iot                     ; end of test C7.1
;
; Section D: unary instructions (byte) =======================================
;   D1    incb
;   D2    decb
;   D3    comb
;   D4    negb
;   D5    adcb
;   D6    sbcb
;   D7    tstb
;   D8    rorb
;   D9    rolb
;   D10   asrb
;   D11   aslb
;   D12   clrb
;
        jmp     td0101
;
; test driver for unary instruction tests (byte)
;
top1br: mov     (r5),101$       ; setup cc setter
        mov     2(r5),102$      ; setup instruction
        mov     4(r5),r4        ; setup expect data pointer
        mov     6(r5),r3        ; setup expect end
        mov     #cp.psw,r2
;
100$:   movb    (r4)+,r1        ; setup dst
        ccc                     ; clear cc
101$:   nop                     ; REPLACED with cc setter
102$:   nop                     ; REPLACED with instruction, e.g. inc r1
        hcmbeq  (r2),(r4)+      ; check psw
        hcmbeq  r1,(r4)+        ; check new dst
        cmp     r4,r3           ; more to do ?
        blo     100$
        return
;
top1bm: mov     (r5),101$       ; setup cc setter
        mov     2(r5),102$      ; setup instruction
        mov     4(r5),r4        ; setup expect data pointer
        mov     6(r5),r3        ; setup expect end
        mov     #200$,r1        ; setup dst pointer
        mov     #cp.psw,r2
;
100$:   movb    (r4)+,(r1)      ; setup old dst
        ccc                     ; clear cc
101$:   nop                     ; REPLACED with cc setter
102$:   nop                     ; REPLACED with instruction, e.g. inc (r1)
        hcmbeq  (r2),(r4)+      ; check psw
        hcmbeq  (r1),(r4)+      ; check new dst
        cmp     r4,r3           ; more to do ?
        blo     100$
        return
;
200$:   .word   0
;
; Test D1 -- incb ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     1 000 101 010 ddd ddd NZV- INCB
;
; Test D1.1 -- incb instruction ++++++++++++++++++++++++++++++++++++++++
;
td0101: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests
        call    top1br
        mov     #2000$,r5       ; mem mode tests
        call    top1bm
        jmp     9999$
;
1000$:  ccc                     ; c=0
        incb    r1              ; incb preserves c, so stays 0
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
1010$:  .byte      000, cp0000,    001
        .byte      001, cp0000,    002
        .byte      176, cp0000,    177
        .byte      177, cpn0v0,    200
        .byte      200, cpn000,    201
        .byte      201, cpn000,    202
        .byte      376, cpn000,    377
        .byte      377, cp0z00,    000
1011$:
        .even
;
2000$:  scc                     ; c=1
        incb    (r1)            ; incb preserves c, so stays 1
        .word   2010$
        .word   2011$
;
;               olddst     psw  newdst
2010$:  .byte      000, cp000c,    001
        .byte      001, cp000c,    002
        .byte      176, cp000c,    177
        .byte      177, cpn0vc,    200
        .byte      200, cpn00c,    201
        .byte      201, cpn00c,    202
        .byte      376, cpn00c,    377
        .byte      377, cp0z0c,    000
2011$:
        .even
;
9999$:  iot                     ; end of test D1.1
;
; Test D2 -- decb ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     1 000 101 011 ddd ddd NZV- DECB
;
; Test D2.1 -- decb instruction ++++++++++++++++++++++++++++++++++++++++
;
td0201: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests
        call    top1br
        mov     #2000$,r5       ; mem mode tests
        call    top1bm
        jmp     9999$
;
1000$:  ccc                     ; c=0
        decb    r1              ; decb preserves c, so stays 0
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
1010$:  .byte      000, cpn000,    377
        .byte      001, cp0z00,    000
        .byte      176, cp0000,    175
        .byte      177, cp0000,    176
        .byte      200, cp00v0,    177
        .byte      201, cpn000,    200
        .byte      376, cpn000,    375
        .byte      377, cpn000,    376
1011$:
        .even
;
2000$:  scc                     ; c=1
        decb    (r1)            ; decb preserves c, so stays 1
        .word   2010$
        .word   2011$
;
;               olddst     psw  newdst
2010$:  .byte      000, cpn00c,    377
        .byte      001, cp0z0c,    000
        .byte      176, cp000c,    175
        .byte      177, cp000c,    176
        .byte      200, cp00vc,    177
        .byte      201, cpn00c,    200
        .byte      376, cpn00c,    375
        .byte      377, cpn00c,    376
2011$:
        .even
;
9999$:  iot                     ; end of test D2.1
;
; Test D3 -- comb ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     1 000 101 001 ddd ddd NZ01 COMB
;
; Test D3.1 -- comb instruction ++++++++++++++++++++++++++++++++++++++++
;
td0301: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests
        call    top1br
        mov     #2000$,r5       ; mem mode tests
        call    top1bm
        jmp     9999$
;
1000$:  ccc
        comb    r1
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
1010$:  .byte      000, cpn00c,    377
        .byte      001, cpn00c,    376
        .byte      177, cpn00c,    200
        .byte      200, cp000c,    177
        .byte      377, cp0z0c,    000
1011$:
        .even
;
2000$:  scc
        comb    (r1)
        .word   1010$
        .word   1011$
;
9999$:  iot                     ; end of test D3.1
;
; Test D4 -- negb ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     1 000 101 100 ddd ddd NZVC NEGB
;
; Test D4.1 -- negb instruction ++++++++++++++++++++++++++++++++++++++++
;
td0401: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests
        call    top1br
        mov     #2000$,r5       ; mem mode tests
        call    top1bm
        jmp     9999$
;
1000$:  ccc
        negb    r1
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
1010$:  .byte      000, cp0z00,    000
        .byte      001, cpn00c,    377
        .byte      177, cpn00c,    201
        .byte      200, cpn0vc,    200
        .byte      377, cp000c,    001
1011$:
        .even
;
2000$:  scc
        negb    (r1)
        .word   1010$
        .word   1011$
;
9999$:  iot                     ; end of test D4.1
;
; Test D5 -- adcb ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     1 000 101 101 ddd ddd NZVC ADCB
;
; Test D5.1 -- adcb instruction ++++++++++++++++++++++++++++++++++++++++
;
td0501: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests
        call    top1br
        mov     #2000$,r5       ; mem mode tests
        call    top1bm
        jmp     9999$
;
1000$:  ccc                     ; c=0
        adcb    r1
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
1010$:  .byte      000, cp0z00,    000
        .byte      001, cp0000,    001
        .byte      177, cp0000,    177
        .byte      200, cpn000,    200
        .byte      377, cpn000,    377
1011$:
        .even
;
2000$:  scc                     ; c=1
        adcb    (r1)
        .word   2010$
        .word   2011$
;
;               olddst  psw     newdst
2010$:  .byte      000, cp0000,    001
        .byte      001, cp0000,    002
        .byte      177, cpn0v0,    200
        .byte      200, cpn000,    201
        .byte      377, cp0z0c,    000
2011$:
        .even
;
9999$:  iot                     ; end of test D5.1
;
; Test D6 -- sbcb ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     1 000 101 110 ddd ddd NZVC SBCB
;
; Test D6.1 -- sbcb instruction ++++++++++++++++++++++++++++++++++++++++
;
td0601: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests
        call    top1br
        mov     #2000$,r5       ; mem mode tests
        call    top1bm
        jmp     9999$
;
1000$:  ccc                     ; c=0
        sbcb    r1
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
1010$:  .byte      000, cp0z00,    000
        .byte      001, cp0000,    001
        .byte      177, cp0000,    177
        .byte      200, cpn000,    200
        .byte      377, cpn000,    377
1011$:
        .even
;
2000$:  scc                     ; c=1
        sbcb    (r1)
        .word   2010$
        .word   2011$
;
;               olddst  psw     newdst
2010$:  .byte      000, cpn00c,    377
        .byte      001, cp0z00,    000
        .byte      177, cp0000,    176
        .byte      200, cp00v0,    177
        .byte      377, cpn000,    376
2011$:
        .even
;
9999$:  iot                     ; end of test D6.1
;
; Test D7 -- tstb ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     1 000 101 111 ddd ddd NZ00 TSTB
;
; Test D7.1 -- tstb instruction ++++++++++++++++++++++++++++++++++++++++
;
td0701: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests
        call    top1br
        mov     #2000$,r5       ; mem mode tests
        call    top1bm
        jmp     9999$
;
1000$:  ccc
        tstb    r1
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
1010$:  .byte      000, cp0z00,    000
        .byte      001, cp0000,    001
        .byte      177, cp0000,    177
        .byte      200, cpn000,    200
        .byte      377, cpn000,    377
1011$:
        .even
;
2000$:  scc
        tstb    (r1)
        .word   1010$
        .word   1011$
;
9999$:  iot                     ; end of test D7.1
;
; Test D8 -- rorb ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     1 000 110 000 ddd ddd NZVC RORB
;
; Test D8.1 -- rorb instruction ++++++++++++++++++++++++++++++++++++++++
;
td0801: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests
        call    top1br
        mov     #2000$,r5       ; mem mode tests
        call    top1bm
        jmp     9999$
;
1000$:  ccc                     ; c=0
        rorb    r1
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
1010$:  .byte      000, cp0z00,    000
        .byte      001, cp0zvc,    000
        .byte      200, cp0000,    100
        .byte      010, cp0000,    004
        .byte      011, cp00vc,    004
        .byte      110, cp0000,    044
        .byte      210, cp0000,    104
1011$:
        .even
;
2000$:  scc                     ; c=1
        rorb    (r1)
        .word   2010$
        .word   2011$
;
;               olddst  psw     newdst
2010$:  .byte      000, cpn0v0,    200
        .byte      001, cpn00c,    200
        .byte      200, cpn0v0,    300
        .byte      010, cpn0v0,    204
        .byte      011, cpn00c,    204
        .byte      110, cpn0v0,    244
        .byte      210, cpn0v0,    304
2011$:
        .even
;
9999$:  iot                     ; end of test D8.1
;
; Test D9 -- rolb ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     1 000 110 001 ddd ddd NZVC ROLB
;
; Test D9.1 -- rorb instruction ++++++++++++++++++++++++++++++++++++++++
;
td0901: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests
        call    top1br
        mov     #2000$,r5       ; mem mode tests
        call    top1bm
        jmp     9999$
;
1000$:  ccc                     ; c=0
        rolb    r1
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
1010$:  .byte      000, cp0z00,    000
        .byte      001, cp0000,    002
        .byte      200, cp0zvc,    000
        .byte      010, cp0000,    020
        .byte      011, cp0000,    022
        .byte      110, cpn0v0,    220
        .byte      210, cp00vc,    020
1011$:
        .even
;
2000$:  scc                     ; c=1
        rolb    (r1)
        .word   2010$
        .word   2011$
;
;               olddst  psw     newdst
2010$:  .byte      000, cp0000,    001
        .byte      001, cp0000,    003
        .byte      200, cp00vc,    001
        .byte      010, cp0000,    021
        .byte      011, cp0000,    023
        .byte      110, cpn0v0,    221
        .byte      210, cp00vc,    021
2011$:
        .even
;
9999$:  iot                     ; end of test D9.1
;
; Test D10 -- asrb +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     1 000 110 010 ddd ddd NZVC ASRB
;
; Test D10.1 -- asrb instruction +++++++++++++++++++++++++++++++++++++++
;
td1001: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests
        call    top1br
        mov     #2000$,r5       ; mem mode tests
        call    top1bm
        jmp     9999$
;
1000$:  ccc
        asrb    r1
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
1010$:  .byte      000, cp0z00,    000
        .byte      001, cp0zvc,    000
        .byte      200, cpn0v0,    300
        .byte      010, cp0000,    004
        .byte      011, cp00vc,    004
        .byte      110, cp0000,    044
        .byte      210, cpn0v0,    304
1011$:
        .even
;
2000$:  scc
        asrb    (r1)
        .word   1010$
        .word   1011$
;
9999$:  iot                     ; end of test D10.1
;
; Test D11 -- aslb +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     1 000 110 011 ddd ddd NZVC ASLB
;
; Test D11.1 -- asrb instruction +++++++++++++++++++++++++++++++++++++++
;
td1101: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests
        call    top1br
        mov     #2000$,r5       ; mem mode tests
        call    top1bm
        jmp     9999$
;
1000$:  ccc
        aslb    r1
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
1010$:  .byte      000, cp0z00,    000
        .byte      001, cp0000,    002
        .byte      200, cp0zvc,    000
        .byte      010, cp0000,    020
        .byte      011, cp0000,    022
        .byte      110, cpn0v0,    220
        .byte      210, cp00vc,    020
1011$:
        .even
;
2000$:  scc
        aslb    (r1)
        .word   1010$
        .word   1011$
;
9999$:  iot                     ; end of test D11.1
;
; Test D12 -- clrb +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     1 000 101 000 ddd ddd 0100 CLRB
;
; Test D12.1 -- asrb instruction +++++++++++++++++++++++++++++++++++++++
;
td1201: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests
        call    top1br
        mov     #2000$,r5       ; mem mode tests
        call    top1bm
        jmp     9999$
;
1000$:  ccc
        clrb    r1
        .word   1010$
        .word   1011$
;
;               olddst  psw     newdst
1010$:  .byte      000, cp0z00,    000
        .byte      377, cp0z00,    000
1011$:
        .even
;
2000$:  scc
        clrb    (r1)
        .word   1010$
        .word   1011$
;
9999$:  iot                     ; end of test D12.1
;
;
; Section E: binary instructions (byte) ======================================
;   E1    bicb
;   E2    bisb
;   E3    cmpb
;   E4    bitb
;   E5    movb
;
        jmp     te0101
;
; test driver for binary instruction tests
;
top2br: mov     (r5),101$       ; setup cc setter
        mov     2(r5),102$      ; setup instruction
        mov     4(r5),r4        ; setup expect data pointer
        mov     6(r5),r3        ; setup expect end
        mov     #cp.psw,r2
;
100$:   movb    (r4)+,r0        ; setup src
        movb    (r4)+,r1        ; setup old dst
        ccc                     ; clear cc
101$:   nop                     ; REPLACED with cc setter
102$:   nop                     ; REPLACED with instruction, e.g. add r0,r1
        hcmbeq  (r2),(r4)+      ; check psw
        hcmbeq  r1,(r4)+        ; check new dst
        cmp     r4,r3           ; more to do ?
        blo     100$
        return
;
top2bm: mov     (r5),101$       ; setup cc setter
        mov     2(r5),102$      ; setup instruction
        mov     4(r5),r4        ; setup expect data pointer
        mov     6(r5),r3        ; setup expect end
        mov     #200$,r0        ; setup src pointer
        mov     #300$,r1        ; setup dst pointer
        mov     #cp.psw,r2
;
100$:   movb    (r4)+,(r0)      ; setup src
        movb    (r4)+,(r1)      ; setup old dst
        ccc                     ; clear cc
101$:   nop                     ; REPLACED with cc setter
102$:   nop                     ; REPLACED with instruction, e.g. add (r0),(r1)
        hcmbeq  (r2),(r4)+      ; check psw
        hcmbeq  (r1),(r4)+      ; check new dst
        cmp     r4,r3           ; more to do ?
        blo     100$
        return
;
200$:   .word   0
300$:   .word   0
;
; Test E1 -- bicb ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     1 100 sss sss ddd ddd NZ0- BICB
;
; Test E1.1 -- bicb instruction ++++++++++++++++++++++++++++++++++++++
;
te0101: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests (with ccc)
        call    top2br
        mov     #2000$,r5       ; mem mode tests (with scc)
        call    top2bm
        jmp     9999$
;
1000$:  ccc
        bicb    r0,r1
        .word   1010$
        .word   1011$
;
;                  src  olddst     psw  newdst
1010$:  .byte      000,    000, cp0z00,    000
        .byte      003,    000, cp0z00,    000
        .byte      003,    006, cp0000,    004
        .byte      003,    014, cp0000,    014
        .byte      300,    140, cp0000,    040
        .byte      100,    300, cpn000,    200
1011$:
;
2000$:  scc
        bicb    (r0),(r1)
        .word   2010$
        .word   2011$
;
;                  src  olddst     psw  newdst
2010$:  .byte      000,    000, cp0z0c,    000
        .byte      003,    000, cp0z0c,    000
        .byte      003,    006, cp000c,    004
        .byte      003,    014, cp000c,    014
        .byte      300,    140, cp000c,    040
        .byte      100,    300, cpn00c,    200
2011$:
;
9999$:  iot                     ; end of test E1.1
;
; Test E2 -- bisb ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     1 101 sss sss ddd ddd NZ0- BISB
;
; Test E2.1 -- bisb instruction ++++++++++++++++++++++++++++++++++++++
;
te0201: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests (with ccc)
        call    top2br
        mov     #2000$,r5       ; mem mode tests (with scc)
        call    top2bm
        jmp     9999$
;
1000$:  ccc
        bisb    r0,r1
        .word   1010$
        .word   1011$
;
;                  src  olddst     psw  newdst
1010$:  .byte      000,    000, cp0z00,    000
        .byte      003,    000, cp0000,    003
        .byte      003,    006, cp0000,    007
        .byte      003,    014, cp0000,    017
        .byte      300,    140, cpn000,    340
        .byte      100,    300, cpn000,    300
1011$:
;
2000$:  scc
        bisb    (r0),(r1)
        .word   2010$
        .word   2011$
;
;                  src  olddst     psw  newdst
2010$:  .byte      000,    000, cp0z0c,    000
        .byte      003,    000, cp000c,    003
        .byte      003,    006, cp000c,    007
        .byte      003,    014, cp000c,    017
        .byte      300,    140, cpn00c,    340
        .byte      100,    300, cpn00c,    300
2011$:
;
9999$:  iot                     ; end of test E2.1
;
; Test E3 -- cmpb ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     1 010 sss sss ddd ddd NZVC CMPB
;
; Test E3.1 -- cmpb instruction ++++++++++++++++++++++++++++++++++++++
;
te0301: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests (with ccc)
        call    top2br
        mov     #2000$,r5       ; mem mode tests (with scc)
        call    top2bm
        jmp     9999$
;
1000$:  ccc
        cmpb    r0,r1
        .word   1010$
        .word   1011$
;
;                  src  olddst     psw  newdst    ; src-dst
1010$:  .byte      000,    000, cp0z00,    000    ; (000)
        .byte      001,    000, cp0000,    000    ; (001)
        .byte      377,    000, cpn000,    000    ; (377)
        .byte      000,    001, cpn00c,    001    ; (377+C)
        .byte      001,    001, cp0z00,    001    ; (000)
        .byte      377,    001, cpn000,    001    ; (376)
        .byte      176,    177, cpn00c,    177    ; (377+C)
        .byte      177,    177, cp0z00,    177    ; (000)
        .byte      200,    177, cp00v0,    177    ; (001)
        .byte      001,    177, cpn00c,    177    ; (202+C)
        .byte      377,    177, cpn000,    177    ; (200)
        .byte      177,    200, cpn0vc,    200    ; (377+C)
        .byte      200,    200, cp0z00,    200    ; (000)
        .byte      201,    200, cp0000,    200    ; (001)
        .byte      001,    200, cpn0vc,    200    ; (201+C)
        .byte      377,    200, cp0000,    200    ; (177)
        .byte      000,    377, cp000c,    377    ; (001+C)
        .byte      001,    377, cp000c,    377    ; (002+C)
        .byte      377,    377, cp0z00,    377    ; (000)
1011$:
;
2000$:  scc
        cmpb    (r0),(r1)
        .word   1010$
        .word   1011$
;
9999$:  iot                     ; end of test E3.1
;
; Test E4 -- bitb ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     1 011 sss sss ddd ddd NZ0- BITB
;
; Test E4.1 -- bitb instruction ++++++++++++++++++++++++++++++++++++++
;
te0401: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests (with ccc)
        call    top2br
        mov     #2000$,r5       ; mem mode tests (with scc)
        call    top2bm
        jmp     9999$
;
1000$:  ccc
        bitb    r0,r1
        .word   1010$
        .word   1011$
;
;                  src  olddst     psw  newdst    ; src&dst
1010$:  .byte      000,    000, cp0z00,    000    ; (000)
        .byte      003,    000, cp0z00,    000    ; (000)
        .byte      003,    006, cp0000,    006    ; (002)
        .byte      003,    014, cp0z00,    014    ; (000)
        .byte      300,    140, cp0000,    140    ; (100)
        .byte      200,    300, cpn000,    300    ; (200)
1011$:
;
2000$:  scc
        bitb    (r0),(r1)
        .word   2010$
        .word   2011$
;
;                  src  olddst     psw  newdst    ; src&dst
2010$:  .byte      000,    000, cp0z0c,    000    ; (000)
        .byte      003,    000, cp0z0c,    000    ; (000)
        .byte      003,    006, cp000c,    006    ; (002)
        .byte      003,    014, cp0z0c,    014    ; (000)
        .byte      300,    140, cp000c,    140    ; (100)
        .byte      200,    300, cpn00c,    300    ; (200)
2011$:
;
9999$:  iot                     ; end of test E4.1
;
; Test E5 -- movb ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     1 001 sss sss ddd ddd NZ0- MOVB
;
; Test E5.1 -- movb instruction ++++++++++++++++++++++++++++++++++++++
;
te0501: clr     cp.psw
        mov     #1000$,r5       ; reg mode tests (with ccc)
        call    top2br
        mov     #2000$,r5       ; mem mode tests (with scc)
        call    top2bm
        jmp     9999$
;
1000$:  ccc
        movb    r0,r1
        .word   1010$
        .word   1011$
;
;                  src  olddst     psw  newdst
1010$:  .byte      000,    000, cp0z00,    000
        .byte      001,    000, cp0000,    001
        .byte      200,    000, cpn000,    200
1011$:
;
2000$:  scc
        movb    (r0),(r1)
        .word   2010$
        .word   2011$
;
;                  src  olddst     psw  newdst
2010$:  .byte      000,    000, cp0z0c,    000
        .byte      001,    000, cp000c,    001
        .byte      200,    000, cpn00c,    200
2011$:
;
9999$:  iot                     ; end of test E5.1
;
; Section F: miscellaneous (spl, reset) ======================================
;   F1    spl
;   F1.1    spl in kernel mode
;   F1.2    spl in supervisor and user mode
;   F2    reset
;   F2.1    reset in kernel mode
;   F2.2    reset in supervisor and user mode
;   F2.3    reset settling time
;   F3      trap instructions: bpt,iot,emt,trap
;
; Test F1:  spl ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     0 000 000 010 011 nnn ---- SPL
;
; Test F1.1 -- spl in kernel mode ++++++++++++++++++++++++++++++++++++
;   Test that PSW is changed
;
tf0101: mov     #cp.psw,r0
        clr     (r0)
;
        ccc
        sen
        spl     1
        hcmpeq  (r0),#<cp.pr1!cpn000>
;
        ccc
        sez
        spl     2
        hcmpeq  (r0),#<cp.pr2!cp0z00>
;
        ccc
        sev
        spl     3
        hcmpeq  (r0),#<cp.pr3!cp00v0>
;
        ccc
        sec
        spl     4
        hcmpeq  (r0),#<cp.pr4!cp000c>
;
        scc
        cln
        spl     5
        hcmpeq  (r0),#<cp.pr5!cp0zvc>
;
        scc
        clz
        spl     6
        hcmpeq  (r0),#<cp.pr6!cpn0vc>
;
        scc
        clv
        spl     7
        hcmpeq  (r0),#<cp.pr7!cpnz0c>
;
        scc
        clc
        spl     0
        hcmpeq  (r0),#<cp.pr0!cpnzv0>
;
9999$:  iot                     ; end of test F1.1
;
; Test F1.2 -- spl in supervisor and user mode +++++++++++++++++++++++
;   Test that SPL is nop when not in kernel mode
;
tf0102: mov     #cp.psw,r0
;
        mov     #cp.cms,(r0)    ; to supervisor mode
        ccc
        spl     4
        hcmpeq  (r0),#<cp.cms!cp.pr0!cp0000>
;
        mov     #cp.cmu,(r0)    ; to user mode
        scc
        spl     5
        hcmpeq  (r0),#<cp.cmu!cp.pr0!cpnzvc>
;
        clr     (r0)            ; back to kernel mode
;
9999$:  iot                     ; end of test F1.2
;
; Test F2:  reset ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     0 000 000 000 000 101 ---- RESET
;
; Test F2.1 -- reset in kernel mode ++++++++++++++++++++++++++++++++++
;   This test checks whether
;   - KW11-L line clock csr is cleared (representing all devices)
;   - PIRQ   is cleared
;   - STKLIM is cleared
;   Effect on MMR0 and MMR3 is tested in MMU test cpu_mmu.mac
;
tf0201: mov     #cp.psw,r0
        mov     #cp.pr7,(r0)    ; lock-out interrupts
        mov     #kl.ie,kl.csr   ; enable KW11-L interrupt
        hbitne  #kl.ie,kl.csr   ; check that kl.ie bit is set
        movb    #bit01,cp.pir+1 ; set PIRQ bit
        hcmbeq  #bit01,cp.pir+1 ; check
        mov     #400,cp.slr     ; bump STKLIM
        hcmpeq  #400,cp.slr     ; check
;
        reset                   ; and RESET
        hbiteq  #kl.ie,kl.csr   ; check that kl.ie bit is cleared
        htsbeq  cp.pir+1        ; check that PIRQ cleared
        htsteq  cp.slr          ; check that STKLIM cleared
        ccc                     ; clear cc
        hcmpeq  (r0),#cp.pr7    ; check that prio still 7 (CPU not(!) reset)
        clr     (r0)            ; back to normal
;
9999$:  iot                     ; end of test F2.1
;
; Test F2.2 -- reset in supervisor and user mode +++++++++++++++++++++
;   This test checks whether
;   - KW11-L line clock csr is not(!) cleared (representing all devices)
;
tf0202: mov     #cp.psw,r0
        mov     #cp.pr7,(r0)    ; lock-out interrupts
        mov     #kl.ie,kl.csr   ; enable KW11-L interrupt
;
        mov     #<cp.cms!cp.pr7>,(r0)   ; supervisor mode, keep pr7 !
        reset                   ; and RESET
        hbitne  #kl.ie,kl.csr   ; check that bit is set
;
        mov     #<cp.cmu!cp.pr7>,(r0)   ; user mode, keep pr7 !
        reset                   ; and RESET
        hbitne  #kl.ie,kl.csr   ; check that bit is set
;
        mov     #<cp.pr7>,(r0)  ; kernel mode, keep pr7 !
        clr     kl.csr          ; disable KW11-L interrupt
        clr     (r0)            ; back to normal
;
9999$:  iot                     ; end of test F2.2
;
; Test F2.3 -- reset settling time +++++++++++++++++++++++++++++++++++
;   This test checks whether interrupt requests are canceled when the
;   reset instruction completes. Done with PIRQ, checks that not
;   interrupt taken after reset.
;
tf0203: cmpb    systyp,#sy.sih          ; skip on SimH (no SPL 11/70 semantics)
        beq     9999$
        mov     #100$,v..pir            ; set up PIRQ handler
        mov     #cp.pr7,v..pir+2
        spl     7
        movb    #bit01,cp.pir+1         ; request PIRQ 1
        spl     0                       ; SPL enforces execution of next inst
        reset                           ; cancel PIRQ
        br      200$                    ; no interrupt should happen
;
100$:   halt
;
200$:   mov     #v..pir+2,v..pir
        clr     v..pir+2

9999$:  iot                     ; end of test F2.3
;
; Test F3: trap instructions: bpt,iot,emt,trap +++++++++++++++++++++++++++++++
;   This sub-section verifies
;     x xxx xxx xxx xxx xxx NZVC Instruction / Remark
;     0 000 000 000 000 011 NZVC BPT
;     0 000 000 000 000 100 NZVC IOT
;     1 000 100 0ii iii iii NZVC EMT
;     1 000 100 1ii iii iii NZVC TRAP
;     0 000 000 000 000 010 NZVC RTI
;
; Test F3.1 trap instructions: bpt,iot,emt,trap ++++++++++++++++++++++
;
tf0301: mov     #v..iot+2,v..iot ; block iot handler
        clr     v..iot+2
        clr     cp.psw          ; clear psw
        mov     #3000$,r5       ; setup expect buffer
;
; test bpt
;
        mov     #2000$,v..bpt   ; setup bpt handler: nzvc = 0011
        mov     #cp.pr7!cp00vc,v..bpt+2
        spl     1
        ccc
        sec
        bpt                     ; bpt with pr1 + nzvc = 0001
        mov     #v..bpt+2,v..bpt ; block bpt again
        clr     v..bpt+2
;
; test iot
;
        mov     #2000$,v..iot   ; setup bpt handler: nzvc = 0100
        mov     #cp.pr7!cp0z00,v..iot+2
        spl     2
        ccc
        sev
        iot                     ; iot with pr2 + nzvc = 0010
        mov     #v..iot+2,v..iot ; block iot again
        clr     v..iot+2
;
; test emt 123
;
        mov     #2000$,v..emt   ; setup emt handler: nzvc = 0101
        mov     #cp.pr7!cp0z0c,v..emt+2
        spl     3
        ccc
        sez
        emt     123              ; emt with pr3 + nzvc = 0100
; test emt 234
        spl     4
        ccc
        sez
        emt     234              ; emt with pr4 + nzvc = 0100
        mov     #v..emt+2,v..emt ; block emt again
        clr     v..emt+2
;
; test trap 321
;
        mov     #2000$,v..trp   ; setup trap handler: nzvc = 0110
        mov     #cp.pr7!cp0zv0,v..trp+2
        spl     5
        ccc
        sen
        trap    321              ; trap with pr5 + nzvc = 1000
; test trap 135
        spl     6
        ccc
        sen
        trap    135              ; trap with pr6 + nzvc = 1000
        mov     #v..trp+2,v..trp ; block trap again
        clr     v..trp+2
;
; end of trap instruction tests
;
        cmp     r5,#3001$
        mov     #vh.iot,v..iot  ; restore iot handler
        mov     #cp.pr7,v..iot+2
        jmp     9999$
;
; vector handler (used for all trap type instructions)
2000$:  hcmpeq  cp.psw,(r5)+    ; check new psw
        hcmpeq  2(sp),(r5)+     ; check saved saved psw
        mov     (sp),r0         ; get return address
        hcmpeq  -2(r0),(r5)+    ; check instruction
        rti
;
; expect:       new psw        saved psw      instruction
3000$:  .word   cp.pr7!cp00vc, cp.pr1!cp000c, <bpt>
        .word   cp.pr7!cp0z00, cp.pr2!cp00v0, <iot>
        .word   cp.pr7!cp0z0c, cp.pr3!cp0z00, <emt!123>
        .word   cp.pr7!cp0z0c, cp.pr4!cp0z00, <emt!234>
        .word   cp.pr7!cp0zv0, cp.pr5!cpn000, <trap!321>
        .word   cp.pr7!cp0zv0, cp.pr6!cpn000, <trap!135>
3001$:
;
9999$:  iot                     ; end of test F3.1
;
; END OF ALL TESTS - loop closure ============================================
;
        mov     tstno,r0        ; hack, for easy monitoring ...
        hcmpeq  tstno,#54.      ; all tests done ?
;
        jmp     loop
;
        .end    start
